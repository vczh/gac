/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/

/***********************************************************************
BASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Basic

Classes:
	NotCopyable									：不可复制对象
	Error										：内部错误，检查到了不可出现的变量、参数或状态错误
	Object										：对象基类

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			：检查内部错误
***********************************************************************/

#ifndef VCZH_BASIC
#define VCZH_BASIC

#include <intrin.h>

namespace vl
{

/***********************************************************************
32位/64位兼容
***********************************************************************/

#ifdef _WIN64
#define VCZH_64
#endif

#ifdef VCZH_64
	typedef __int64					vint;
	typedef signed __int64			vsint;
	typedef unsigned __int64		vuint;
#else
	typedef __int32					vint;
	typedef signed __int32			vsint;
	typedef unsigned __int32		vuint;
#endif

typedef signed __int64	pos_t;

#ifdef VCZH_64
#define ITOA_S		_i64toa_s
#define ITOW_S		_i64tow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#define INCRC(x)	(_InterlockedIncrement64(x))
#define DECRC(x)	(_InterlockedDecrement64(x))
#else
#define ITOA_S		_itoa_s
#define ITOW_S		_itow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#define INCRC(x)	(_InterlockedIncrement((volatile long*)(x)))
#define DECRC(x)	(_InterlockedDecrement((volatile long*)(x)))
#endif

#ifndef _MSC_VER
#define override
#define abstract
#endif

/***********************************************************************
基础
***********************************************************************/

	class NotCopyable
	{
	private:
		NotCopyable(const NotCopyable&);
		NotCopyable& operator=(const NotCopyable&);
	public:
		NotCopyable();
	};

	class Error
	{
	private:
		wchar_t*			description;
	public:
		Error(wchar_t* _description);

		wchar_t*			Description()const;
	};

#ifdef _DEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)
#endif
#ifdef NDEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION)
#endif

#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)

#define SCOPE_VARIABLE(TYPE, VARIABLE, VALUE)\
	if(bool __scope_variable_flag__=true)\
		for(TYPE VARIABLE = VALUE;__scope_variable_flag__;__scope_variable_flag__=false)

/***********************************************************************
类型计算
***********************************************************************/

	template<typename T>
	struct RemoveReference
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveReference<T&>
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveReference<T&&>
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveConst
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveConst<const T>
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveVolatile
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveVolatile<volatile T>
	{
		typedef T			Type;
	};

	template<typename T>
	struct RemoveCVR
	{
		typedef T								Type;
	};

	template<typename T>
	struct RemoveCVR<T&>
	{
		typedef typename RemoveCVR<T>::Type		Type;
	};

	template<typename T>
	struct RemoveCVR<T&&>
	{
		typedef typename RemoveCVR<T>::Type		Type;
	};

	template<typename T>
	struct RemoveCVR<const T>
	{
		typedef typename RemoveCVR<T>::Type		Type;
	};

	template<typename T>
	struct RemoveCVR<volatile T>
	{
		typedef typename RemoveCVR<T>::Type		Type;
	};

	template<typename T>
	typename RemoveReference<T>::Type&& MoveValue(T&& value)
	{
		return (typename RemoveReference<T>::Type&&)value;
	}

/***********************************************************************
基础
***********************************************************************/

	class Object
	{
	public:
		virtual ~Object();
	};

	template<typename T>
	class ObjectBox : public Object
	{
	private:
		T					object;
	public:
		ObjectBox(const T& _object)
			:object(_object)
		{
		}

		ObjectBox(T&& _object)
			:object(MoveValue(_object))
		{
		}

		ObjectBox(const ObjectBox<T>& value)
			:object(value.object)
		{
		}

		ObjectBox(ObjectBox<T>&& value)
			:object(MoveValue(value.object))
		{
		}

		ObjectBox<T>& operator=(const T& _object)
		{
			object=_object;
		}

		ObjectBox<T>& operator=(const ObjectBox<T>& value)
		{
			object=value.object;
		}

		ObjectBox<T>& operator=(ObjectBox<T>&& value)
		{
			object=MoveValue(value.object);
		}

		const T& Unbox()
		{
			return object;
		}
	};

	template<typename T>
	class Nullable
	{
	private:
		T*					object;
	public:
		Nullable()
			:object(0)
		{
		}

		Nullable(const T& value)
			:object(new T(value))
		{
		}

		Nullable(T&& value)
			:object(new T(MoveValue(value)))
		{
		}

		Nullable(const Nullable<T>& nullable)
			:object(nullable.object?new T(*nullable.object):0)
		{
		}

		Nullable(Nullable<T>&& nullable)
			:object(nullable.object)
		{
			nullable.object=0;
		}

		~Nullable()
		{
			if(object)
			{
				delete object;
				object=0;
			}
		}

		Nullable<T>& operator=(const T& value)
		{
			if(object)
			{
				delete object;
				object=0;
			}
			object=new T(value);
			return *this;
		}

		Nullable<T>& operator=(const Nullable<T>& nullable)
		{
			if(this!=&nullable)
			{
				if(object)
				{
					delete object;
					object=0;
				}
				if(nullable.object)
				{
					object=new T(*nullable.object);
				}
			}
			return *this;
		}

		Nullable<T>& operator=(Nullable<T>&& nullable)
		{
			if(this!=&nullable)
			{
				if(object)
				{
					delete object;
					object=0;
				}
				object=nullable.object;
				nullable.object=0;
			}
			return *this;
		}

		static bool Equals(const Nullable<T>& a, const Nullable<T>& b)
		{
			return
				a.object
				?b.object
					?*a.object==*b.object
					:false
				:b.object
					?false
					:true;
		}

		static vint Compare(const Nullable<T>& a, const Nullable<T>& b)
		{
			return
				a.object
				?b.object
					?(*a.object==*b.object?0:*a.object<*b.object?-1:1)
					:1
				:b.object
					?-1
					:0;
		}

		bool operator==(const Nullable<T>& nullable)const
		{
			return Equals(*this, nullable);
		}

		bool operator!=(const Nullable<T>& nullable)const
		{
			return !Equals(*this, nullable);
		}

		bool operator<(const Nullable<T>& nullable)const
		{
			return Compare(*this, nullable)<0;
		}

		bool operator<=(const Nullable<T>& nullable)const
		{
			return Compare(*this, nullable)<=0;
		}

		bool operator>(const Nullable<T>& nullable)const
		{
			return Compare(*this, nullable)>0;
		}

		bool operator>=(const Nullable<T>& nullable)const
		{
			return Compare(*this, nullable)>=0;
		}

		operator bool()const
		{
			return object!=0;
		}

		const T& Value()const
		{
			return *object;
		}
	};

	template<typename T, size_t minSize>
	union BinaryRetriver
	{
		T t;
		char binary[sizeof(T)>minSize?sizeof(T):minSize];
	};

/***********************************************************************
配置
***********************************************************************/

	template<typename T>
	struct KeyType
	{
	public:
		typedef T Type;

		static T GetKeyValue(const T& value)
		{
			return value;
		}
	};

	template<typename T>
	struct POD
	{
		static const bool Result=false;
	};

	template<>struct POD<bool>{static const bool Result=true;};
	template<>struct POD<unsigned __int8>{static const bool Result=true;};
	template<>struct POD<signed __int8>{static const bool Result=true;};
	template<>struct POD<unsigned __int16>{static const bool Result=true;};
	template<>struct POD<signed __int16>{static const bool Result=true;};
	template<>struct POD<unsigned __int32>{static const bool Result=true;};
	template<>struct POD<signed __int32>{static const bool Result=true;};
	template<>struct POD<unsigned __int64>{static const bool Result=true;};
	template<>struct POD<signed __int64>{static const bool Result=true;};
	template<>struct POD<char>{static const bool Result=true;};
	template<>struct POD<wchar_t>{static const bool Result=true;};
	template<typename T>struct POD<T*>{static const bool Result=true;};
	template<typename T>struct POD<T&>{static const bool Result=true;};
	template<typename T, typename C>struct POD<T C::*>{static const bool Result=true;};
	template<typename T, vint _Size>struct POD<T[_Size]>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<volatile T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const volatile T>{static const bool Result=POD<T>::Result;};

/***********************************************************************
时间
***********************************************************************/

	struct DateTime
	{
		vint				year;
		vint				month;
		vint				dayOfWeek;
		vint				day;
		vint				hour;
		vint				minute;
		vint				second;
		vint				milliseconds;

		unsigned __int64	totalMilliseconds;
		unsigned __int64	filetime;

		static DateTime		LocalTime();
		static DateTime		UtcTime();
		static DateTime		FromDateTime(vint _year, vint _month, vint _day, vint _hour=0, vint _minute=0, vint _second=0, vint _milliseconds=0);
		static DateTime		FromFileTime(unsigned __int64 filetime);

		DateTime();

		DateTime			ToLocalTime();
		DateTime			ToUtcTime();
		DateTime			Forward(unsigned __int64 milliseconds);
		DateTime			Backward(unsigned __int64 milliseconds);

		bool operator==(const DateTime& value)const { return filetime==value.filetime; }
		bool operator!=(const DateTime& value)const { return filetime!=value.filetime; }
		bool operator<(const DateTime& value)const { return filetime<value.filetime; }
		bool operator<=(const DateTime& value)const { return filetime<=value.filetime; }
		bool operator>(const DateTime& value)const { return filetime>value.filetime; }
		bool operator>=(const DateTime& value)const { return filetime>=value.filetime; }
	};

/***********************************************************************
接口
***********************************************************************/

	class Interface : private NotCopyable
	{
	public:
		virtual ~Interface();
	};

/***********************************************************************
类型萃取
***********************************************************************/

	struct YesType{};
	struct NoType{};

	template<typename T, typename YesOrNo>
	struct AcceptType
	{
	};

	template<typename T>
	struct AcceptType<T, YesType>
	{
		typedef T Type;
	};

	template<typename YesOrNo>
	struct AcceptValue
	{
		static const bool Result=false;
	};

	template<>
	struct AcceptValue<YesType>
	{
		static const bool Result=true;
	};

	template<typename TFrom, typename TTo>
	struct RequiresConvertable
	{
		static YesType Test(TTo* value);
		static NoType Test(void* value);
		
		typedef decltype(Test((TFrom*)0)) YesNoType;
	};
}

#endif

/***********************************************************************
STRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::String

Classes:
	AString										：Mbcs字符串
	WString										：Utf-16字符串
***********************************************************************/

#ifndef VCZH_STRING
#define VCZH_STRING

#include <memory.h>

namespace vl
{
	template<typename T>
	class ObjectString : public Object
	{
	private:
		static const T	zero=0;

		mutable T*					buffer;
		mutable volatile vint*		counter;
		mutable vint				start;
		mutable vint				length;
		mutable vint				realLength;

		static vint CalculateLength(const T* buffer)
		{
			vint result=0;
			while(*buffer++)result++;
			return result;
		}

		static vint Compare(const T* bufA, const ObjectString<T>& strB)
		{
			const T* bufB=strB.buffer+strB.start;
			const T* bufAOld=bufA;
			vint length=strB.length;
			while(length-- && *bufA)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return CalculateLength(bufAOld)-strB.length;
		}

	public:

		static vint Compare(const ObjectString<T>& strA, const ObjectString<T>& strB)
		{
			const T* bufA=strA.buffer+strA.start;
			const T* bufB=strB.buffer+strB.start;
			vint length=strA.length<strB.length?strA.length:strB.length;
			while(length--)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return strA.length-strB.length;
		}

	private:

		void Inc()const
		{
			if(counter)
			{
				INCRC(counter);
			}
		}

		void Dec()const
		{
			if(counter)
			{
				if(DECRC(counter)==0)
				{
					delete[] buffer;
					delete counter;
				}
			}
		}

		ObjectString(const ObjectString<T>& string, vint _start, vint _length)
		{
			if(_length<=0)
			{
				buffer=(T*)&zero;
				counter=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=string.buffer;
				counter=string.counter;
				start=string.start+_start;
				length=_length;
				realLength=string.realLength;
				Inc();
			}
		}

		ObjectString(const ObjectString<T>& dest, const ObjectString<T>& source, vint index, vint count)
		{
			if(index==0 && count==dest.length && source.length==0)
			{
				buffer=(T*)&zero;
				counter=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				counter=new vint(1);
				start=0;
				length=dest.length-count+source.length;
				realLength=length;
				buffer=new T[length+1];
				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);
				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);
				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));
				buffer[length]=0;
			}
		}
	public:
		static ObjectString<T>	Empty;

		ObjectString()
		{
			buffer=(T*)&zero;
			counter=0;
			start=0;
			length=0;
			realLength=0;
		}

		ObjectString(const T& _char)
		{
			counter=new vint(1);
			start=0;
			length=1;
			buffer=new T[2];
			buffer[0]=_char;
			buffer[1]=0;
			realLength=length;
		}

		ObjectString(const T* _buffer, vint _length)
		{
			if(_length<=0)
			{
				buffer=(T*)&zero;
				counter=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=new T[_length+1];
				memcpy(buffer, _buffer, _length*sizeof(T));
				buffer[_length]=0;
				counter=new vint(1);
				start=0;
				length=_length;
				realLength=_length;
			}
		}

		ObjectString(const T* _buffer, bool copy = true)
		{
			CHECK_ERROR(_buffer!=0, L"ObjectString<T>::ObjectString(const T*, bool)#不能用空指针构造字符串。");
			if(copy)
			{
				counter=new vint(1);
				start=0;
				length=CalculateLength(_buffer);
				buffer=new T[length+1];
				memcpy(buffer, _buffer, sizeof(T)*(length+1));
				realLength=length;
			}
			else
			{
				buffer=(T*)_buffer;
				counter=0;
				start=0;
				length=CalculateLength(_buffer);
				realLength=length;
			}
		}

		ObjectString(const ObjectString<T>& string)
		{
			buffer=string.buffer;
			counter=string.counter;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			Inc();
		}

		ObjectString(ObjectString<T>&& string)
		{
			buffer=string.buffer;
			counter=string.counter;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			
			string.buffer=(T*)&zero;
			string.counter=0;
			string.start=0;
			string.length=0;
			string.realLength=0;
		}

		~ObjectString()
		{
			Dec();
		}

		const T* Buffer()const
		{
			if(start+length!=realLength)
			{
				T* newBuffer=new T[length+1];
				memcpy(newBuffer, buffer+start, sizeof(T)*length);
				newBuffer[length]=0;
				Dec();
				buffer=newBuffer;
				counter=new vint(1);
				start=0;
				realLength=length;
			}
			return buffer+start;
		}

		ObjectString<T>& operator=(const ObjectString<T>& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				counter=string.counter;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
				Inc();
			}
			return *this;
		}

		ObjectString<T>& operator=(ObjectString<T>&& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				counter=string.counter;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
			
				string.buffer=(T*)&zero;
				string.counter=0;
				string.start=0;
				string.length=0;
				string.realLength=0;
			}
			return *this;
		}

		ObjectString<T>& operator+=(const ObjectString<T>& string)
		{
			return *this=*this+string;
		}

		ObjectString<T> operator+(const ObjectString<T>& string)const
		{
			return ObjectString<T>(*this, string, length, 0);
		}

		bool operator==(const ObjectString<T>& string)const
		{
			return Compare(*this, string)==0;
		}

		bool operator!=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)!=0;
		}

		bool operator>(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>0;
		}

		bool operator>=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>=0;
		}

		bool operator<(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<0;
		}

		bool operator<=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<=0;
		}

		bool operator==(const T* buffer)const
		{
			return Compare(buffer, *this)==0;
		}

		bool operator!=(const T* buffer)const
		{
			return Compare(buffer, *this)!=0;
		}

		bool operator>(const T* buffer)const
		{
			return Compare(buffer, *this)<0;
		}

		bool operator>=(const T* buffer)const
		{
			return Compare(buffer, *this)<=0;
		}

		bool operator<(const T* buffer)const
		{
			return Compare(buffer, *this)>0;
		}

		bool operator<=(const T* buffer)const
		{
			return Compare(buffer, *this)>=0;
		}

		T operator[](vint index)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString:<T>:operator[](vint)#参数index越界。");
			return buffer[start+index];
		}

		vint Length()const
		{
			return length;
		}

		vint IndexOf(T c)const
		{
			const T* reading=buffer+start;
			for(vint i=0;i<length;i++)
			{
				if(reading[i]==c)
					return i;
			}
			return -1;
		}

		ObjectString<T> Left(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Left(vint)#参数count越界。");
			return ObjectString<T>(*this, 0, count);
		}

		ObjectString<T> Right(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Right(vint)#参数count越界。");
			return ObjectString<T>(*this, length-count, count);
		}

		ObjectString<T> Sub(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Sub(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Sub(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, index, count);
		}

		ObjectString<T> Remove(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Remove(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Remove(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, ObjectString<T>(), index, count);
		}

		ObjectString<T> Insert(vint index, const ObjectString<T>& string)const
		{
			CHECK_ERROR(index>=0 && index<=length, L"ObjectString<T>::Insert(vint)#参数count越界。");
			return ObjectString<T>(*this, string, index, 0);
		}

		friend bool operator<(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<0;
		}

		friend bool operator<=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<=0;
		}

		friend bool operator>(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>0;
		}

		friend bool operator>=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>=0;
		}

		friend bool operator==(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)==0;
		}

		friend bool operator!=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)!=0;
		}

		friend ObjectString<T> operator+(const T* left, const ObjectString<T>& right)
		{
			return WString(left, false)+right;
		}
	};

	template<typename T>
	ObjectString<T> ObjectString<T>::Empty=ObjectString<T>();

	typedef ObjectString<char>		AString;
	typedef ObjectString<wchar_t>	WString;

	extern vint					atoi_test(const AString& string, bool& success);
	extern vint					wtoi_test(const WString& string, bool& success);
	extern __int64				atoi64_test(const AString& string, bool& success);
	extern __int64				wtoi64_test(const WString& string, bool& success);
	extern vuint				atou_test(const AString& string, bool& success);
	extern vuint				wtou_test(const WString& string, bool& success);
	extern unsigned __int64		atou64_test(const AString& string, bool& success);
	extern unsigned __int64		wtou64_test(const WString& string, bool& success);
	extern double				atof_test(const AString& string, bool& success);
	extern double				wtof_test(const WString& string, bool& success);

	extern vint					atoi(const AString& string);
	extern vint					wtoi(const WString& string);
	extern __int64				atoi64(const AString& string);
	extern __int64				wtoi64(const WString& string);
	extern vuint				atou(const AString& string);
	extern vuint				wtou(const WString& string);
	extern unsigned __int64		atou64(const AString& string);
	extern unsigned __int64		wtou64(const WString& string);
	extern double				atof(const AString& string);
	extern double				wtof(const WString& string);

	extern AString				itoa(vint number);
	extern WString				itow(vint number);
	extern AString				i64toa(__int64 number);
	extern WString				i64tow(__int64 number);
	extern AString				utoa(vuint number);
	extern WString				utow(vuint number);
	extern AString				u64toa(unsigned __int64 number);
	extern WString				u64tow(unsigned __int64 number);
	extern AString				ftoa(double number);
	extern WString				ftow(double number);

	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);
	extern AString				wtoa(const WString& string);
	extern vint					_atow(const char* a, wchar_t* w, vint chars);
	extern WString				atow(const AString& string);
	extern AString				alower(const AString& string);
	extern WString				wlower(const WString& string);
	extern AString				aupper(const AString& string);
	extern WString				wupper(const WString& string);
}

#endif

/***********************************************************************
CONSOLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
UI::Console

***********************************************************************/

#ifndef VCZH_CONSOLE
#define VCZH_CONSOLE


namespace vl
{
	namespace console
	{
		class Console abstract
		{
		public:
			static void Write(const wchar_t* string, vint length);
			static void Write(const wchar_t* string);
			static void Write(const WString& string);
			static void WriteLine(const WString& string);
			static WString Read();
			static void SetColor(bool red, bool green, bool blue, bool light);
			static void SetTitle(const WString& string);
		};
	}
}

#endif

/***********************************************************************
EXCEPTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Exception

Classes:
	Exception									：异常
	ArgumentException							：预料的的参数错误
***********************************************************************/

#ifndef VCZH_EXCEPTION
#define VCZH_EXCEPTION


namespace vl
{
	class Exception : public Object
	{
	protected:
		WString						message;

	public:
		Exception(const WString& _message=WString::Empty);

		const WString&				Message()const;
	};

	class ArgumentException : public Exception
	{
	protected:
		WString						function;
		WString						name;

	public:
		ArgumentException(const WString& _message=WString::Empty, const WString& _function=WString::Empty, const WString& _name=WString::Empty);

		const WString&				GetFunction()const;
		const WString&				GetName()const;
	};

	class ParsingException : public Exception
	{
	protected:
		vint							position;
		WString						expression;

	public:
		ParsingException(const WString& _message, const WString& _expression, vint _position);

		const WString&				GetExpression()const;
		vint							GetPosition()const;
	};
}

#endif

/***********************************************************************
COLLECTIONS\PAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Pair

Classes:
	Pair<K, V>							：二元组
***********************************************************************/

#ifndef VCZH_COLLECTIONS_PAIR
#define VCZH_COLLECTIONS_PAIR


namespace vl
{
	namespace collections
	{
		template<typename K, typename V>
		class Pair
		{
		public:
			K				key;
			V				value;

			Pair()
			{
			}

			Pair(const K& _key, const V& _value)
			{
				key=_key;
				value=_value;
			}

			Pair(const Pair<K, V>& pair)
			{
				key=pair.key;
				value=pair.value;
			}

			vint CompareTo(const Pair<K, V>& pair)const
			{
				if(key<pair.key)
				{
					return -1;
				}
				else if(key>pair.key)
				{
					return 1;
				}
				else if(value<pair.value)
				{
					return -1;
				}
				else if(value>pair.value)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)==0;
			}

			bool operator!=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)!=0;
			}

			bool operator<(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<0;
			}

			bool operator<=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<=0;
			}

			bool operator>(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>0;
			}

			bool operator>=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>=0;
			}
		};
	}

	template<typename K, typename V>
	struct POD<collections::Pair<K, V>>
	{
		static const bool Result=POD<K>::Result && POD<V>::Result;
	};
}

#endif

/***********************************************************************
COLLECTIONS\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator<T>									：枚举器
	IEnumerable<T>									：可枚举对象
***********************************************************************/

#ifndef VCZH_COLLECTIONS_INTERFACES
#define VCZH_COLLECTIONS_INTERFACES


namespace vl
{
	namespace collections
	{

/***********************************************************************
接口
***********************************************************************/

		template<typename T>
		class IEnumerator : public virtual Interface
		{
		public:
			typedef T									ElementType;

			virtual IEnumerator<T>*						Clone()const=0;
			virtual const T&							Current()const=0;
			virtual vint								Index()const=0;
			virtual bool								Next()=0;
			virtual void								Reset()=0;

			virtual bool								Evaluated()const{return false;}
		};

		template<typename T>
		class IEnumerable : public virtual Interface
		{
		public:
			typedef T									ElementType;

			virtual IEnumerator<T>*						CreateEnumerator()const=0;
		};

/***********************************************************************
随机存取
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable
			{
				static const bool							CanRead = false;
				static const bool							CanResize = false;
			};

			template<typename T>
			struct RandomAccess
			{
				static vint GetCount(const T& t)
				{
					return t.Count();
				}

				static const typename T::ElementType& GetValue(const T& t, vint index)
				{
					return t.Get(index);
				}

				static void SetCount(T& t, vint count)
				{
					t.Resize(count);
				}

				static void SetValue(T& t, vint index, const typename T::ElementType& value)
				{
					t.Set(index, value);
				}

				static void AppendValue(T& t, const typename T::ElementType& value)
				{
					t.Add(value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\LIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List

Classes:
	ListStore<T,PODType>				：列表存储复制算法
	ListBase<T,K>						：列表基类
	Array<T,K>							：数组
	List<T,K>							：列表
	SortedList<T,K>						：有序列表
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LIST
#define VCZH_COLLECTIONS_LIST

#include <string.h>

namespace vl
{
	namespace collections
	{

/***********************************************************************
储存结构
***********************************************************************/

		template<typename T, bool PODType>
		class ListStore abstract : public Object
		{
		};
		
		template<typename T>
		class ListStore<T, false> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(dest<source)
				{
					for(vint i=0;i<count;i++)
					{
						dest[i]=MoveValue(source[i]);
					}
				}
				else if(dest>source)
				{
					for(vint i=count-1;i>=0;i--)
					{
						dest[i]=MoveValue(source[i]);
					}
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
				for(vint i=0;i<count;i++)
				{
					dest[i]=T();
				}
			}
		public:
		};
		
		template<typename T>
		class ListStore<T, true> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(count)
				{
					memmove(dest, source, sizeof(T)*count);
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
			}
		public:
		};
		
		template<typename T>
		class ArrayBase abstract : public ListStore<T,POD<T>::Result>, public virtual IEnumerable<T>
		{
		protected:
			class Enumerator : public Object, public virtual IEnumerator<T>
			{
			private:
				const ArrayBase<T>*				container;
				vint							index;

			public:
				Enumerator(const ArrayBase<T>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const T& Current()const
				{
					return container->Get(index);
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
				}
			};
			
			T*						buffer;
			vint					count;
		public:
			ArrayBase()
				:buffer(0)
				,count(0)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ListBase abstract : public ArrayBase<T>
		{
		protected:
			vint					capacity;
			bool					lessMemoryMode;

			vint CalculateCapacity(vint expected)
			{
				vint result=capacity;
				while(result<expected)
				{
					result=result*5/4+1;
				}
				return result;
			}

			void MakeRoom(vint index, vint _count)
			{
				vint newCount=count+_count;
				if(newCount>capacity)
				{
					vint newCapacity=CalculateCapacity(newCount);
					T* newBuffer=new T[newCapacity];
					CopyObjects(newBuffer, buffer, index);
					CopyObjects(newBuffer+index+_count, buffer+index, count-index);
					delete[] buffer;
					capacity=newCapacity;
					buffer=newBuffer;
				}
				else
				{
					CopyObjects(buffer+index+_count, buffer+index, count-index);
				}
				count=newCount;
			}

			void ReleaseUnnecessaryBuffer(vint previousCount)
			{
				if(buffer && count<previousCount)
				{
					ClearObjects(&buffer[count], previousCount-count);
				}
				if(lessMemoryMode && count<=capacity/2)
				{
					vint newCapacity=capacity*5/8;
					if(count<newCapacity)
					{
						T* newBuffer=new T[newCapacity];
						CopyObjects(newBuffer, buffer, count);
						delete[] buffer;
						capacity=newCapacity;
						buffer=newBuffer;
					}
				}
			}
		public:
			ListBase()
			{
				count=0;
				capacity=0;
				buffer=0;
				lessMemoryMode=true;
			}

			~ListBase()
			{
				delete[] buffer;
			}

			void SetLessMemoryMode(bool mode)
			{
				lessMemoryMode=mode;
			}

			bool RemoveAt(vint index)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::RemoveAt(vint)#参数index越界。");
				CopyObjects(buffer+index,buffer+index+1,count-index-1);
				count--;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool RemoveRange(vint index, vint _count)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<=count, L"ListBase<T, K>::RemoveRange(vint, vint)#参数index越界。");
				CHECK_ERROR(index+_count>=0 && index+_count<=count, L"ListBase<T,K>::RemoveRange(vint, vint)#参数_count越界。");
				CopyObjects(buffer+index, buffer+index+_count, count-index-_count);
				count-=_count;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool Clear()
			{
				vint previousCount=count;
				count=0;
				if(lessMemoryMode)
				{
					capacity=0;
					delete[] buffer;
					buffer=0;
				}
				else
				{
					ReleaseUnnecessaryBuffer(previousCount);
				}
				return true;
			}
		};

/***********************************************************************
列表对象
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class Array : public ArrayBase<T>
		{
		protected:
			void Create(vint size)
			{
				if(size>0)
				{
					count=size;
					buffer=new T[size];
				}
				else
				{
					count=0;
					buffer=0;
				}
			}

			void Destroy()
			{
				count=0;
				delete[] buffer;
				buffer=0;
			}
		public:
			Array(vint size=0)
			{
				Create(size);
			}

			Array(const T* _buffer, vint size)
			{
				Create(size);
				CopyObjects(buffer, _buffer, size);
			}

			~Array()
			{
				Destroy();
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			void Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
			}

			using ArrayBase<T>::operator[];
			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			void Resize(vint size)
			{
				vint oldCount=count;
				T* oldBuffer=buffer;
				Create(size);
				CopyObjects(buffer, oldBuffer, (count<oldCount?count:oldCount));
				delete[] oldBuffer;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class List : public ListBase<T, K>
		{
		public:
			List()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			vint Add(const T& item)
			{
				MakeRoom(count, 1);
				buffer[count-1]=item;
				return count-1;
			}

			vint Insert(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<=count, L"List<T, K>::Insert(vint, const T&)#参数index越界。");
				MakeRoom(index,1);
				buffer[index]=item;
				return index;
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
				return true;
			}
			
			using ListBase<T, K>::operator[];
			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class SortedList : public ListBase<T, K>
		{
		public:
			SortedList()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			template<typename Key>
			vint IndexOf(const Key& item)const
			{
				vint start=0;
				vint end=count-1;
				while(start<=end)
				{
					vint index=start+(end-start)/2;
					if(buffer[index]==item)
					{
						return index;
					}
					else if(buffer[index]>item)
					{
						end=index-1;
					}
					else
					{
						start=index+1;
					}
				}
				return -1;
			}

			vint IndexOf(const K& item)const
			{
				return IndexOf<K>(item);
			}

			vint Add(const T& item)
			{
				if(count==0)
				{
					MakeRoom(0, 1);
					buffer[0]=item;
					return 0;
				}
				else
				{
					vint start=0;
					vint end=count-1;
					vint index=-1;
					while(start<=end)
					{
						index=(start+end)/2;
						if(buffer[index]==item)
						{
							goto SORTED_LIST_INSERT;
						}
						else if(buffer[index]>item)
						{
							end=index-1;
						}
						else
						{
							start=index+1;
						}
					}
					CHECK_ERROR(index>=0 && index<count, L"SortedList<T, K>::Add(const T&)#内部错误，变量index越界");
					if(buffer[index]<item)
					{
						index++;
					}
SORTED_LIST_INSERT:
					MakeRoom(index, 1);
					buffer[index]=item;
					return index;
				}
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}
		};

/***********************************************************************
随机访问
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T, typename K>
			struct RandomAccessable<Array<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};

			template<typename T, typename K>
			struct RandomAccessable<List<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};

			template<typename T, typename K>
			struct RandomAccessable<SortedList<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\DICTIONARY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary

Classes:
	Dictionary<KT, VT, KK, VK>					：映射
	Group<KT, VT, KK, VK>						：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARY
#define VCZH_COLLECTIONS_DICTIONARY


namespace vl
{
	namespace collections
	{
		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type, 
			typename VK=typename KeyType<VT>::Type
		>
		class Dictionary : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
		public:
			typedef SortedList<KT, KK>			KeyContainer;
			typedef List<VT, VK>				ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Dictionary<KT, VT, KK, VK>*	container;
				vint								index;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(index<container->Count())
					{
						current.key=container->Keys().Get(index);
						current.value=container->Values().Get(index);
					}
				}
			public:
				Enumerator(const Dictionary<KT, VT, KK, VK>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					UpdateCurrent();
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
					UpdateCurrent();
				}
			};

			KeyContainer						keys;
			ValueContainer						values;
		public:
			Dictionary()
			{
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			void SetLessMemoryMode(bool mode)
			{
				keys.SetLessMemoryMode(mode);
				values.SetLessMemoryMode(mode);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			const ValueContainer& Values()const
			{
				return values;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const VT& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			const VT& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			bool Set(const KT& key, const VT& value)
			{
				vint index=keys.IndexOf(KeyType<KT>::GetKeyValue(key));
				if(index==-1)
				{
					index=keys.Add(key);
					values.Insert(index, value);
				}
				else
				{
					values[index]=value;
				}
				return true;
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				CHECK_ERROR(!keys.Contains(KeyType<KT>::GetKeyValue(key)), L"Dictionary<KT, KK, ValueContainer, VT, VK>::Add(const KT&, const VT&)#key已存在。");
				vint index=keys.Add(key);
				values.Insert(index, value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					values.RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				keys.Clear();
				values.Clear();
				return true;
			}
		};

		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type,
			typename VK=typename KeyType<VT>::Type
		>
		class Group : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
			typedef SortedList<KT, KK>		KeyContainer;
			typedef List<VT, VK>			ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Group<KT, VT, KK, VK>*		container;
				vint								keyIndex;
				vint								valueIndex;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(keyIndex<container->Count())
					{
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							current.key=container->Keys().Get(keyIndex);
							current.value=values.Get(valueIndex);
						}
					}
				}
			public:
				Enumerator(const Group<KT, VT, KK, VK>* _container, vint _keyIndex=-1, vint _valueIndex=-1)
				{
					container=_container;
					keyIndex=_keyIndex;
					valueIndex=_valueIndex;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, keyIndex, valueIndex);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					if(0<=keyIndex && keyIndex<container->Count())
					{
						vint index=0;
						for(vint i=0;i<keyIndex;i++)
						{
							index+=container->GetByIndex(i).Count();
						}
						return index+valueIndex;
					}
					else
					{
						return -1;
					}
				}

				bool Next()
				{
					if(keyIndex==-1)
					{
						keyIndex=0;
					}
					while(keyIndex<container->Count())
					{
						valueIndex++;
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							UpdateCurrent();
							return true;
						}
						else
						{
							keyIndex++;
							valueIndex=-1;
						}
					}
					return false;
				}

				void Reset()
				{
					keyIndex=-1;
					valueIndex=-1;
					UpdateCurrent();
				}
			};

			KeyContainer					keys;
			List<ValueContainer*>			values;
		public:
			Group()
			{
			}

			~Group()
			{
				Clear();
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const ValueContainer& Get(const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			const ValueContainer& GetByIndex(vint index)const
			{
				return *values.Get(index);
			}

			const ValueContainer& operator[](const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			bool Contains(const KK& key)const
			{
				return keys.Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					return values.Get(index)->Contains(value);
				}
				else
				{
					return false;
				}
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				ValueContainer* target=0;
				vint index=keys.IndexOf(KeyType<KT>::GetKeyValue(key));
				if(index==-1)
				{
					target=new ValueContainer;
					values.Insert(keys.Add(key), target);
				}
				else
				{
					target=values[index];
				}
				target->Add(value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					List<VT, VK>* target=values[index];
					values.RemoveAt(index);
					delete target;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Remove(const KK& key, const VK& value)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					List<VT, VK>* target=values[index];
					target->Remove(value);
					if(target->Count()==0)
					{
						keys.RemoveAt(index);
						values.RemoveAt(index);
						delete target;
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				for(vint i=0;i<values.Count();i++)
				{
					delete values[i];
				}
				keys.Clear();
				values.Clear();
				return true;
			}
		};

/***********************************************************************
随机访问
***********************************************************************/
		namespace randomaccess_internal
		{
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccessable<Dictionary<KT, VT, KK, VK>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccess<Dictionary<KT, VT, KK, VK>>
			{
				static vint GetCount(const Dictionary<KT, VT, KK, VK>& t)
				{
					return t.Count();
				}

				static Pair<KT, VT> GetValue(const Dictionary<KT, VT, KK, VK>& t, vint index)
				{
					return Pair<KT, VT>(t.Keys().Get(index), t.Values().Get(index));
				}

				static void AppendValue(Dictionary<KT, VT, KK, VK>& t, const Pair<KT, VT>& value)
				{
					t.Set(value.key, value.value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
HTTPUTILITY.H
***********************************************************************/
#ifndef VCZH_HTTPUTILITY
#define VCZH_HTTPUTILITY


namespace vl
{

/***********************************************************************
HTTP Utility
***********************************************************************/

	class HttpRequest
	{
		typedef collections::Array<char>					BodyBuffer;
		typedef collections::List<WString>					StringList;
		typedef collections::Dictionary<WString, WString>	HeaderMap;
	public:
		WString				server;
		vint				port;
		WString				query;
		bool				secure;
		WString				username;
		WString				password;
		WString				method;
		WString				cookie;
		BodyBuffer			body;
		WString				contentType;
		StringList			acceptTypes;
		HeaderMap			extraHeaders;

		HttpRequest();
		bool				SetHost(const WString& inputQuery);
		void				SetBodyUtf8(const WString& bodyString);
	};

	class HttpResponse
	{
		typedef collections::Array<char>		BodyBuffer;
	public:
		vint				statusCode;
		BodyBuffer			body;
		WString				cookie;

		HttpResponse();
		WString				GetBodyUtf8();
	};

	extern bool				HttpQuery(const HttpRequest& request, HttpResponse& response);
	extern WString			UrlEncodeQuery(const WString& query);
}

#endif

/***********************************************************************
POINTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr<T>							：智能指针
***********************************************************************/

#ifndef VCZH_POINTER
#define VCZH_POINTER


namespace vl
{

/***********************************************************************
ReferenceCounterOperator
***********************************************************************/

	template<typename T, typename Enabled=YesType>
	struct ReferenceCounterOperator
	{
		static __forceinline volatile vint* CreateCounter(T* reference)
		{
			return new vint(0);
		}

		static __forceinline void DeleteReference(volatile vint* counter, void* reference)
		{
			delete counter;
			delete (T*)reference;
		}
	};

/***********************************************************************
Ptr
***********************************************************************/

	template<typename T>
	class Ptr
	{
		 template<typename X>
		 friend class Ptr;
	protected:
		typedef void		(*Destructor)(volatile vint*, void*);

		volatile vint*		counter;
		T*					reference;
		void*				originalReference;
		Destructor			originalDestructor;

		void Inc()
		{
			if(counter)
			{
				INCRC(counter);
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(DECRC(counter)==0)
				{
					originalDestructor(counter, originalReference);
					counter=0;
					reference=0;
					originalReference=0;
					originalDestructor=0;
				}
			}
		}

		volatile vint* Counter()const
		{
			return counter;
		}

		Ptr(volatile vint* _counter, T* _reference, void* _originalReference, Destructor _originalDestructor)
			:counter(_counter)
			,reference(_reference)
			,originalReference(_originalReference)
			,originalDestructor(_originalDestructor)
		{
			Inc();
		}
	public:

		Ptr()
			:counter(0)
			,reference(0)
			,originalReference(0)
			,originalDestructor(0)
		{
		}

		Ptr(T* pointer)
			:counter(0)
			,reference(0)
			,originalReference(0)
			,originalDestructor(0)
		{
			if(pointer)
			{
				counter=ReferenceCounterOperator<T>::CreateCounter(pointer);
				reference=pointer;
				originalReference=pointer;
				originalDestructor=&ReferenceCounterOperator<T>::DeleteReference;
				Inc();
			}
		}

		Ptr(const Ptr<T>& pointer)
			:counter(pointer.counter)
			,reference(pointer.reference)
			,originalReference(pointer.originalReference)
			,originalDestructor(pointer.originalDestructor)
		{
			Inc();
		}

		Ptr(Ptr<T>&& pointer)
			:counter(pointer.counter)
			,reference(pointer.reference)
			,originalReference(pointer.originalReference)
			,originalDestructor(pointer.originalDestructor)
		{
			pointer.counter=0;
			pointer.reference=0;
			pointer.originalReference=0;
			pointer.originalDestructor=0;
		}

		template<typename C>
		Ptr(const Ptr<C>& pointer)
			:counter(0)
			,reference(0)
			,originalReference(0)
			,originalDestructor(0)
		{
			T* converted=pointer.Obj();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				originalReference=pointer.originalReference;
				originalDestructor=pointer.originalDestructor;
				Inc();
			}
		}

		~Ptr()
		{
			Dec();
		}

		template<typename C>
		Ptr<C> Cast()const
		{
			C* converted=dynamic_cast<C*>(reference);
			return Ptr<C>((converted?counter:0), converted, originalReference, originalDestructor);
		}

		Ptr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=ReferenceCounterOperator<T>::CreateCounter(pointer);
				reference=pointer;
				originalReference=pointer;
				originalDestructor=&ReferenceCounterOperator<T>::DeleteReference;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
				originalReference=0;
				originalDestructor=0;
			}
			return *this;
		}

		Ptr<T>& operator=(const Ptr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				originalReference=pointer.originalReference;
				originalDestructor=pointer.originalDestructor;
				Inc();
			}
			return *this;
		}

		Ptr<T>& operator=(Ptr<T>&& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				originalReference=pointer.originalReference;
				originalDestructor=pointer.originalDestructor;
				
				pointer.counter=0;
				pointer.reference=0;
				pointer.originalReference=0;
				pointer.originalDestructor=0;
			}
			return *this;
		}

		template<typename C>
		Ptr<T>& operator=(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			Dec();
			if(converted)
			{
				counter=pointer.counter;
				reference=converted;
				originalReference=pointer.originalReference;
				originalDestructor=pointer.originalDestructor;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
				originalReference=0;
				originalDestructor=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const Ptr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const Ptr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const Ptr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const Ptr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const Ptr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const Ptr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

/***********************************************************************
ComPtr
***********************************************************************/

	template<typename T>
	class ComPtr
	{
	protected:
		volatile vint*		counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				INCRC(counter);
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(DECRC(counter)==0)
				{
					delete counter;
					reference->Release();
					counter=0;
					reference=0;
				}
			}
		}

		volatile vint* Counter()const
		{
			return counter;
		}

		ComPtr(volatile vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		ComPtr()
		{
			counter=0;
			reference=0;
		}

		ComPtr(T* pointer)
		{
			if(pointer)
			{
				counter=new volatile vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		ComPtr(const ComPtr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		ComPtr(ComPtr<T>&& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			
			pointer.counter=0;
			pointer.reference=0;
		}

		~ComPtr()
		{
			Dec();
		}

		ComPtr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		ComPtr<T>& operator=(const ComPtr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		ComPtr<T>& operator=(ComPtr<T>&& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				
				pointer.counter=0;
				pointer.reference=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const ComPtr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const ComPtr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const ComPtr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const ComPtr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const ComPtr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const ComPtr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

/***********************************************************************
Traits
***********************************************************************/

	template<typename T>
	struct KeyType<Ptr<T>>
	{
		typedef T* Type;

		static T* GetKeyValue(const Ptr<T>& key)
		{
			return key.Obj();
		}
	};

	template<typename T>
	struct POD<Ptr<T>>
	{
		static const bool Result=false;
	};

	template<typename T>
	struct KeyType<ComPtr<T>>
	{
		typedef T* Type;

		static T* GetKeyValue(const ComPtr<T>& key)
		{
			return key.Obj();
		}
	};

	template<typename T>
	struct POD<ComPtr<T>>
	{
		static const bool Result=false;
	};
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONFOREACH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

扩展：
	实现一个函数重载IteratorType CreateForEachIterator(const CollectionType& collection);
	CollectionType是所需要的容器类型
	IteratorType继承自ForEachIterator<T>
	必须写在vl::collections命名空间里
***********************************************************************/

#ifndef VCZH_COLLECTIONS_FOREACH
#define VCZH_COLLECTIONS_FOREACH

namespace vl
{
	namespace collections
	{

/***********************************************************************
ForEach基础设施
***********************************************************************/

		template<typename T>
		class ForEachIterator : public Object
		{
		public:
			virtual bool				Next(T& variable)const=0;

			operator bool()const
			{
				return true;
			}
		};

/***********************************************************************
IEnumerable<T>支持
***********************************************************************/

		template<typename T>
		class EnumerableForEachIterator : public ForEachIterator<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumerator;
		public:
			EnumerableForEachIterator(const IEnumerable<T>& enumerable)
				:enumerator(enumerable.CreateEnumerator())
			{
			}

			EnumerableForEachIterator(const EnumerableForEachIterator<T>& enumerableIterator)
				:enumerator(enumerableIterator.iterator)
			{
			}

			bool Next(T& variable)const
			{
				if(enumerator->Next())
				{
					variable=enumerator->Current();
					return true;
				}
				else
				{
					return false;
				}
			}
		};

		template<typename T>
		EnumerableForEachIterator<T> CreateForEachIterator(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

/***********************************************************************
ForEach宏
***********************************************************************/

#define FOREACH(TYPE, VARIABLE, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);)

#define FOREACH_INDEXER(TYPE, VARIABLE, INDEXER, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		SCOPE_VARIABLE(vint, INDEXER, 0)\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);INDEXER++)
	}
}

#endif

/***********************************************************************
LOCALE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Locale

Interfaces:
***********************************************************************/

#ifndef VCZH_LOCALE
#define VCZH_LOCALE


namespace vl
{
	class Locale : public Object
	{
	protected:
		WString						localeName;

	public:
		Locale(const WString& _localeName=WString::Empty);
		~Locale();

		bool operator==(const Locale& value)const { return localeName==value.localeName; }
		bool operator!=(const Locale& value)const { return localeName!=value.localeName; }
		bool operator<(const Locale& value)const { return localeName<value.localeName; }
		bool operator<=(const Locale& value)const { return localeName<=value.localeName; }
		bool operator>(const Locale& value)const { return localeName>value.localeName; }
		bool operator>=(const Locale& value)const { return localeName>=value.localeName; }

		static Locale				Invariant();
		static Locale				SystemDefault();
		static Locale				UserDefault();
		static void					Enumerate(collections::List<Locale>& locales);

		const WString&				GetName()const;

		void						GetShortDateFormats(collections::List<WString>& formats)const;
		void						GetLongDateFormats(collections::List<WString>& formats)const;
		void						GetYearMonthDateFormats(collections::List<WString>& formats)const;
		void						GetLongTimeFormats(collections::List<WString>& formats)const;
		void						GetShortTimeFormats(collections::List<WString>& formats)const;

		WString						FormatDate(const WString& format, DateTime date)const;
		WString						FormatTime(const WString& format, DateTime time)const;
		WString						FormatNumber(const WString& number)const;
		WString						FormatCurrency(const WString& currency)const;

		WString						GetShortDayOfWeekName(vint dayOfWeek)const;
		WString						GetLongDayOfWeekName(vint dayOfWeek)const;
		WString						GetShortMonthName(vint month)const;
		WString						GetLongMonthName(vint month)const;

		WString						ToFullWidth(const WString& str)const;
		WString						ToHalfWidth(const WString& str)const;
		WString						ToHiragana(const WString& str)const;
		WString						ToKatagana(const WString& str)const;
		WString						ToLower(const WString& str)const;
		WString						ToUpper(const WString& str)const;
		WString						ToLinguisticLower(const WString& str)const;
		WString						ToLinguisticUpper(const WString& str)const;
		WString						ToSimplifiedChinese(const WString& str)const;
		WString						ToTraditionalChinese(const WString& str)const;
		WString						ToTileCase(const WString& str)const;

		enum Normalization
		{
			None=0,
			IgnoreCase=1,
			IgnoreCaseLinguistic=2,
			IgnoreKanaType=4,
			IgnoreNonSpace=8,
			IgnoreSymbol=16,
			IgnoreWidth=32,
			DigitsAsNumbers=64,
			StringSoft=128,
		};
		vint									Compare(const WString& s1, const WString& s2, Normalization normalization)const;
		vint									CompareOrdinal(const WString& s1, const WString& s2)const;
		vint									CompareOrdinalIgnoreCase(const WString& s1, const WString& s2)const;
		collections::Pair<vint, vint>			FindFirst(const WString& text, const WString& find, Normalization normalization)const;
		collections::Pair<vint, vint>			FindLast(const WString& text, const WString& find, Normalization normalization)const;
		bool									StartsWith(const WString& text, const WString& find, Normalization normalization)const;
		bool									EndsWidth(const WString& text, const WString& find, Normalization normalization)const;
	};

#define INVLOC vl::Locale::Invariant()
}

#endif

/***********************************************************************
REGEX\REGEX.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Regular Expression

Classes:
	RegexString						：字符串匹配结果
	RegexMatch						：匹配结果
	Regex							：正则表达式引擎
	RegexToken						：词法记号
	RegexTokens						：词法记号表
	RegexLexer						：词法分析器
***********************************************************************/

#ifndef VCZH_REGEX_REGEX
#define VCZH_REGEX_REGEX


namespace vl
{
	namespace regex_internal
	{
		class PureResult;
		class PureInterpretor;
		class RichResult;
		class RichInterpretor;
	}

	namespace regex
	{

/***********************************************************************
正则表达式引擎数据结构
***********************************************************************/

		class RegexString : public Object
		{
		protected:
			WString										value;
			vint										start;
			vint										length;

		public:
			RegexString(vint _start=0);
			RegexString(const WString& _string, vint _start, vint _length);

			vint										Start()const;
			vint										Length()const;
			const WString&								Value()const;
			bool										operator==(const RegexString& string)const;
		};

		class RegexMatch : public Object, private NotCopyable
		{
			friend class Regex;
		public:
			typedef Ptr<RegexMatch>										Ref;
			typedef collections::List<Ref>								List;
			typedef collections::List<RegexString>						CaptureList;
			typedef collections::Group<WString, RegexString>			CaptureGroup;
		protected:
			collections::List<RegexString>				captures;
			collections::Group<WString, RegexString>	groups;
			bool										success;
			RegexString									result;

			RegexMatch(const WString& _string, regex_internal::PureResult* _result);
			RegexMatch(const WString& _string, regex_internal::RichResult* _result, regex_internal::RichInterpretor* _rich);
			RegexMatch(const RegexString& _result);
		public:
			
			bool										Success()const;
			const RegexString&							Result()const;
			const CaptureList&							Captures()const;
			const CaptureGroup&							Groups()const;
		};

/***********************************************************************
正则表达式引擎
***********************************************************************/

		class Regex : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			regex_internal::RichInterpretor*			rich;

			void										Process(const WString& text, bool keepEmpty, bool keepSuccess, bool keepFail, RegexMatch::List& matches)const;
		public:
			Regex(const WString& code, bool preferPure=true);
			~Regex();

			bool										IsPureMatch()const;
			bool										IsPureTest()const;

			RegexMatch::Ref								MatchHead(const WString& text)const;
			RegexMatch::Ref								Match(const WString& text)const;
			bool										TestHead(const WString& text)const;
			bool										Test(const WString& text)const;
			void										Search(const WString& text, RegexMatch::List& matches)const;
			void										Split(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
			void										Cut(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
		};

/***********************************************************************
正则表达式词法分析器
***********************************************************************/

		class RegexToken
		{
		public:
			vint										start;
			vint										length;
			vint										token;
			const wchar_t*								reading;
			vint										codeIndex;

			vint										rowStart;
			vint										columnStart;
			vint										rowEnd;
			vint										columnEnd;

			bool										operator==(const RegexToken& _token)const;
			bool										operator==(const wchar_t* _token)const;
		};

		class RegexTokens : public Object, public collections::IEnumerable<RegexToken>
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			WString										code;
			vint										codeIndex;
			
			RegexTokens(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens, const WString& _code, vint _codeIndex);
		public:

			collections::IEnumerator<RegexToken>*		CreateEnumerator()const;
			void										ReadToEnd(collections::List<RegexToken>& tokens, bool(*discard)(vint)=0)const;
		};

		class RegexLexerWalker : public Object
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			
			RegexLexerWalker(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens);
		public:
			RegexLexerWalker(const RegexLexerWalker& walker);
			~RegexLexerWalker();

			vint										GetStartState()const;
			vint										GetRelatedToken(vint state)const;
			void										Walk(wchar_t input, vint& state, vint& token, bool& finalState, bool& previousTokenStop)const;
			vint										Walk(wchar_t input, vint state)const;
			bool										IsClosedToken(const wchar_t* input, vint length)const;
			bool										IsClosedToken(const WString& input)const;
		};

		class RegexLexerColorizer : public Object
		{
			friend class RegexLexer;
		public:
			typedef void(*TokenProc)(void* argument, vint start, vint length, vint token);

		protected:
			RegexLexerWalker							walker;
			vint										currentState;

			RegexLexerColorizer(const RegexLexerWalker& _walker);
		public:
			RegexLexerColorizer(const RegexLexerColorizer& colorizer);
			~RegexLexerColorizer();

			void										Reset(vint state);
			void										Pass(wchar_t input);
			vint										GetStartState()const;
			vint										GetCurrentState()const;
			void										Colorize(const wchar_t* input, vint length, TokenProc tokenProc, void* tokenProcArgument);
		};

		class RegexLexer : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			collections::Array<vint>					ids;
			collections::Array<vint>					stateTokens;
		public:
			RegexLexer(const collections::IEnumerable<WString>& tokens);
			~RegexLexer();

			RegexTokens									Parse(const WString& code, vint codeIndex=-1)const;
			RegexLexerWalker							Walk()const;
			RegexLexerColorizer							Colorize()const;
		};
	}
}

#endif

/***********************************************************************
STREAM\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Interfaces

Interfaces:
	IStream							：流
***********************************************************************/

#ifndef VCZH_STREAM_INTERFACES
#define VCZH_STREAM_INTERFACES


namespace vl
{
	namespace stream
	{
		class IStream : public virtual Interface
		{
		public:
			virtual bool					CanRead()const=0;
			virtual bool					CanWrite()const=0;
			virtual bool					CanSeek()const=0;
			virtual bool					CanPeek()const=0;
			virtual bool					IsLimited()const=0;
			virtual bool					IsAvailable()const=0;
			virtual void					Close()=0;
			virtual pos_t					Position()const=0;
			virtual pos_t					Size()const=0;
			virtual void					Seek(pos_t _size)=0;
			virtual void					SeekFromBegin(pos_t _size)=0;
			virtual void					SeekFromEnd(pos_t _size)=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
			virtual vint					Peek(void* _buffer, vint _size)=0;
		};

		class IEncoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
		};

		class IDecoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
		};
	}
}

#endif

/***********************************************************************
STREAM\ACCESSOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Accessor

Classes:
	TextReader						：字符串阅读器
	TextWriter						：字符串书写器
	StreamReader					：流阅读器
	StreamWriter					：流书写器
	EncoderStream					：编码流
	DecoderStream					：解码流
***********************************************************************/

#ifndef VCZH_STREAM_ACCESSOR
#define VCZH_STREAM_ACCESSOR


namespace vl
{
	namespace stream
	{

/***********************************************************************
流控制器
***********************************************************************/

		class TextReader : public Object, private NotCopyable
		{
		public:
			virtual bool				IsEnd()=0;
			virtual wchar_t				ReadChar()=0;
			virtual WString				ReadString(vint length);
			virtual WString				ReadLine();
			virtual WString				ReadToEnd();
		};

		class TextWriter : public Object, private NotCopyable
		{
		public:
			virtual void				WriteChar(wchar_t c)=0;
			virtual void				WriteString(const wchar_t* string, vint charCount);
			virtual void				WriteString(const wchar_t* string);
			virtual void				WriteString(const WString& string);
			virtual void				WriteLine(const wchar_t* string, vint charCount);
			virtual void				WriteLine(const wchar_t* string);
			virtual void				WriteLine(const WString& string);

			virtual void				WriteMonospacedEnglishTable(collections::Array<WString>& tableByRow, vint rows, vint columns);
		};

		class StringReader : public TextReader
		{
		protected:
			WString						string;
			vint						current;
			bool						lastCallIsReadLine;

			void						PrepareIfLastCallIsReadLine();
		public:
			StringReader(const WString& _string);

			bool						IsEnd();
			wchar_t						ReadChar();
			WString						ReadString(vint length);
			WString						ReadLine();
			WString						ReadToEnd();
		};

		class StreamReader : public TextReader
		{
		protected:
			IStream*					stream;
		public:
			StreamReader(IStream& _stream);

			bool						IsEnd();
			wchar_t						ReadChar();
		};

		class StreamWriter : public TextWriter
		{
		protected:
			IStream*					stream;
		public:
			StreamWriter(IStream& _stream);
			using TextWriter::WriteString;

			void						WriteChar(wchar_t c);
			void						WriteString(const wchar_t* string, vint charCount);
		};

/***********************************************************************
编码解码
***********************************************************************/

		class EncoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IEncoder*					encoder;
			pos_t						position;

		public:
			EncoderStream(IStream& _stream, IEncoder& _encoder);
			~EncoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};

		class DecoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IDecoder*					decoder;
			pos_t						position;

		public:
			DecoderStream(IStream& _stream, IDecoder& _decoder);
			~DecoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCOPYFROM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCOPYFROM
#define VCZH_COLLECTIONS_OPERATIONCOPYFROM


namespace vl
{
	namespace collections
	{

/***********************************************************************
容器复制
***********************************************************************/

		namespace copyfrom_internal
		{
			using namespace randomaccess_internal;

			template<typename Ds, typename Ss, bool DsRA, bool SsRA>
			struct CopyFromAlgorithm
			{
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::SetValue(ds, index+i, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::AppendValue(ds, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator;
					vint copyCount=0;

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						copyCount++;
					}

					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::SetValue(ds, index++, enumerator->Current());
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::AppendValue(ds, enumerator->Current());
					}
				}
			};

			template<typename T>
			struct Slice
			{
				const T*	items;
				vint		count;
			};
		}

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable<copyfrom_internal::Slice<T>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};
		
			template<typename T>
			struct RandomAccess<copyfrom_internal::Slice<T>>
			{
				static vint GetCount(const copyfrom_internal::Slice<T>& t)
				{
					return t.count;
				}

				static const T& GetValue(const copyfrom_internal::Slice<T>& t, vint index)
				{
					return t.items[index];
				}
			};
		}

		template<typename Ds, typename Ss>
		void CopyFrom(Ds& ds, const Ss& ss, bool append=false)
		{
			copyfrom_internal::CopyFromAlgorithm<Ds, Ss, randomaccess_internal::RandomAccessable<Ds>::CanResize, randomaccess_internal::RandomAccessable<Ss>::CanRead>::Perform(ds, ss, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* buffer, vint count, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={buffer, count};
			CopyFrom(ds, slice, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* begin, const S* end, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={begin, end-begin};
			CopyFrom(ds, slice, append);
		}
	}
}

#endif

/***********************************************************************
FUNCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Function

Classes:
	Func<function-type>									：函数对象

Functions:
	Curry :: (A->B) -> A -> B							：参数拆分
	Combine :: (A->B) -> (A->C) -> (B->C->D) -> (A->D)	：函数组合
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
#ifndef VCZH_FUNCTION
#define VCZH_FUNCTION
namespace vl
{
	template<typename T>
	class Func
	{
	};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
	template<typename R >
	class Func<R()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)();
		public:
			StaticInvoker(R(*_function)())
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)();
			struct Content
			{
				C*			sender;
				R(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke()
			{
				return (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType();
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R()>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()()const
		{
			return invoker->Invoke();
		}
		bool operator==(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void()>
***********************************************************************/
	template< >
	class Func<void()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)();
		public:
			StaticInvoker(void(*_function)())
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)();
			struct Content
			{
				C*			sender;
				void(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke()
			{
				  (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType();
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void()>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()()const
		{
			  invoker->Invoke();
		}
		bool operator==(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
	template<typename R,typename T0>
	class Func<R(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0);
		public:
			StaticInvoker(R(*_function)(T0))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0)const
		{
			return invoker->Invoke(p0);
		}
		bool operator==(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0)>
***********************************************************************/
	template< typename T0>
	class Func<void(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0);
		public:
			StaticInvoker(void(*_function)(T0))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0)const
		{
			  invoker->Invoke(p0);
		}
		bool operator==(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
	template<typename R,typename T0,typename T1>
	class Func<R(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1);
		public:
			StaticInvoker(R(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1)const
		{
			return invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1)>
***********************************************************************/
	template< typename T0,typename T1>
	class Func<void(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1);
		public:
			StaticInvoker(void(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1)const
		{
			  invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2>
	class Func<R(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2)const
		{
			return invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2)>
***********************************************************************/
	template< typename T0,typename T1,typename T2>
	class Func<void(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2)const
		{
			  invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3>
	class Func<R(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			return invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3>
	class Func<void(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			  invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<R(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<void(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<R(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<void(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<R(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<void(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
	namespace function_lambda
	{
		template<typename T>
		struct LambdaRetriveType
		{
			typedef vint Type;
			typedef vint FunctionType;
			typedef vint ResultType;
		};
 
		template<typename T>
		struct FunctionObjectRetriveType
		{
			typedef typename LambdaRetriveType<decltype(&T::operator())>::Type Type;
			typedef typename LambdaRetriveType<decltype(&T::operator())>::FunctionType FunctionType;
			typedef typename LambdaRetriveType<decltype(&T::operator())>::ResultType ResultType;
		};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()const>
		{
			typedef Func<R()> Type;
			typedef R(FunctionType)();
			typedef R ResultType;
		};
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()>
		{
			typedef Func<R()> Type;
			typedef R(FunctionType)();
			typedef R ResultType;
		};
 
		template<typename R >
		struct FunctionObjectRetriveType<R(*)()>
		{
			typedef Func<R()> Type;
			typedef R(FunctionType)();
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)const>
		{
			typedef Func<R(T0)> Type;
			typedef R(FunctionType)(T0);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R(FunctionType)(T0);
			typedef R ResultType;
		};
 
		template<typename R,typename T0>
		struct FunctionObjectRetriveType<R(*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R(FunctionType)(T0);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)const>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R(FunctionType)(T0,T1);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R(FunctionType)(T0,T1);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1>
		struct FunctionObjectRetriveType<R(*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R(FunctionType)(T0,T1);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)const>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R(FunctionType)(T0,T1,T2);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R(FunctionType)(T0,T1,T2);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R(FunctionType)(T0,T1,T2);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)const>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R(FunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ResultType;
		};
 
 
		template<typename T>
		typename LambdaRetriveType<decltype(&T::operator())>::Type Lambda(T functionObject)
		{
			return functionObject;
		}
		template<typename T>
		typename FunctionObjectRetriveType<T>::Type ConvertToFunction(T functionObject)
		{
			return functionObject;
		}
#define LAMBDA vl::function_lambda::Lambda
#define FUNCTION vl::function_lambda::ConvertToFunction
#define FUNCTION_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::Type
#define FUNCTION_RESULT_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::ResultType
	}
	namespace function_binding
	{
		template<typename T>
		struct Binding
		{
		};
		 
		template<typename T>
		struct CR{typedef const T& Type;};
		template<typename T>
		struct CR<T&>{typedef T& Type;};
		template<typename T>
		struct CR<const T>{typedef const T& Type;};
		template<typename T>
		struct CR<const T&>{typedef const T& Type;};
		 
		template<typename T>
		struct RCR{typedef T Type;};
		template<typename T>
		struct RCR<T&>{typedef T& Type;};
		template<typename T>
		struct RCR<const T>{typedef T Type;};
		template<typename T>
		struct RCR<const T&>{typedef T Type;};
		
 
/***********************************************************************
vl::function_binding::Binding<R(T0)>
***********************************************************************/
		template<typename R,typename T0>
		struct Binding<R(T0)>
		{
			typedef R FunctionType(T0);
			typedef R CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()()const
				{
					return target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0)>
***********************************************************************/
		template< typename T0>
		struct Binding<void(T0)>
		{
			typedef void FunctionType(T0);
			typedef void CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()()const
				{
					  target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1)>
***********************************************************************/
		template<typename R,typename T0,typename T1>
		struct Binding<R(T0,T1)>
		{
			typedef R FunctionType(T0,T1);
			typedef R CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1)const
				{
					return target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1)>
***********************************************************************/
		template< typename T0,typename T1>
		struct Binding<void(T0,T1)>
		{
			typedef void FunctionType(T0,T1);
			typedef void CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1)const
				{
					  target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2>
		struct Binding<R(T0,T1,T2)>
		{
			typedef R FunctionType(T0,T1,T2);
			typedef R CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2)const
				{
					return target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2)>
***********************************************************************/
		template< typename T0,typename T1,typename T2>
		struct Binding<void(T0,T1,T2)>
		{
			typedef void FunctionType(T0,T1,T2);
			typedef void CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2)const
				{
					  target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct Binding<R(T0,T1,T2,T3)>
		{
			typedef R FunctionType(T0,T1,T2,T3);
			typedef R CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3)const
				{
					return target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3>
		struct Binding<void(T0,T1,T2,T3)>
		{
			typedef void FunctionType(T0,T1,T2,T3);
			typedef void CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3)const
				{
					  target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<R(T0,T1,T2,T3,T4)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4);
			typedef R CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					return target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<void(T0,T1,T2,T3,T4)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4);
			typedef void CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					  target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<R(T0,T1,T2,T3,T4,T5)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5);
			typedef R CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					return target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<void(T0,T1,T2,T3,T4,T5)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5);
			typedef void CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					  target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(T* function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(const Func<T>& function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	namespace function_combining
	{
		template<typename A, typename B, typename C>
		class Combining
		{
		};
 
/***********************************************************************
vl::function_combining::Combining<R1(), R2(), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R >
		class Combining<R1(), R2(), R(R1,R2)> : public Object
		{
		protected:
			Func<R1()>			function1;
			Func<R2()>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType();
			typedef R2 SecondFunctionType();
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType();
			Combining(const Func<R1()>& _function1, const Func<R2()>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()()const
			{
				return converter(function1(), function2());
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0), R2(T0), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0>
		class Combining<R1(T0), R2(T0), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0)>			function1;
			Func<R2(T0)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0);
			typedef R2 SecondFunctionType(T0);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0);
			Combining(const Func<R1(T0)>& _function1, const Func<R2(T0)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0)const
			{
				return converter(function1(p0), function2(p0));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1>
		class Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1)>			function1;
			Func<R2(T0,T1)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1);
			typedef R2 SecondFunctionType(T0,T1);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1);
			Combining(const Func<R1(T0,T1)>& _function1, const Func<R2(T0,T1)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1)const
			{
				return converter(function1(p0,p1), function2(p0,p1));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2>
		class Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2)>			function1;
			Func<R2(T0,T1,T2)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2);
			typedef R2 SecondFunctionType(T0,T1,T2);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2);
			Combining(const Func<R1(T0,T1,T2)>& _function1, const Func<R2(T0,T1,T2)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2)const
			{
				return converter(function1(p0,p1,p2), function2(p0,p1,p2));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3>
		class Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3)>			function1;
			Func<R2(T0,T1,T2,T3)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3);
			typedef R2 SecondFunctionType(T0,T1,T2,T3);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3);
			Combining(const Func<R1(T0,T1,T2,T3)>& _function1, const Func<R2(T0,T1,T2,T3)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
			{
				return converter(function1(p0,p1,p2,p3), function2(p0,p1,p2,p3));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		class Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4)>			function1;
			Func<R2(T0,T1,T2,T3,T4)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4);
			Combining(const Func<R1(T0,T1,T2,T3,T4)>& _function1, const Func<R2(T0,T1,T2,T3,T4)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
			{
				return converter(function1(p0,p1,p2,p3,p4), function2(p0,p1,p2,p3,p4));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		class Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5), function2(p0,p1,p2,p3,p4,p5));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6), function2(p0,p1,p2,p3,p4,p5,p6));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7), function2(p0,p1,p2,p3,p4,p5,p6,p7));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9));
			}
		};
	}
	template<typename F1, typename F2, typename C>
	Func<typename function_combining::Combining<F1, F2, C>::FinalFunctionType>
	Combine(Func<C> converter, Func<F1> function1, Func<F2> function2)
	{
		return function_combining::Combining<F1, F2, C>(function1, function2, converter);
	}
	template<typename T>
	Func<Func<T>(Func<T>,Func<T>)> Combiner(const Func<typename Func<T>::ResultType(typename Func<T>::ResultType,typename Func<T>::ResultType)>& converter)
	{
		typedef typename Func<T>::ResultType R;
		return Curry<Func<T>(Func<R(R,R)>,Func<T>,Func<T>)>(Combine)(converter);
	}
}
#endif

/***********************************************************************
COLLECTIONS\OPERATIONENUMERABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONENUMERABLE
#define VCZH_COLLECTIONS_OPERATIONENUMERABLE


namespace vl
{
	namespace collections
	{

/***********************************************************************
空迭代器
***********************************************************************/

		template<typename T>
		class EmptyEnumerable : public Object, public IEnumerable<T>
		{
		private:
			class Enumerator : public Object, public virtual IEnumerator<T>
			{
				IEnumerator<T>* Clone()const override
				{
					return new Enumerator;
				}

				const T& Current()const override
				{
					return *(T*)0;
				}

				vint Index()const override
				{
					return -1;
				}

				bool Next()override
				{
					return false;
				}

				void Reset()override
				{
				}

				bool Evaluated()const override
				{
					return true;
				}
			};
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator;
			}
		};

/***********************************************************************
递增数组迭代器
***********************************************************************/

		template<typename T>
		class RangeEnumerator : public Object, public virtual IEnumerator<T>
		{
		protected:
			T			start;
			T			count;
			T			current;
		public:
			RangeEnumerator(T _start, T _count, T _current)
				:start(_start)
				,count(_count)
				,current(_current)
			{
			}

			RangeEnumerator(T _start, T _count)
				:start(_start)
				,count(_count)
				,current(_start-1)
			{
			}

			IEnumerator<T>* Clone()const override
			{
				return new RangeEnumerator(start, count, current);
			}

			const T& Current()const override
			{
				return current;
			}

			T Index()const override
			{
				return current-start;
			}

			bool Next()override
			{
				if(start-1<=current && current<start+count-1)
				{
					current++;
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()override
			{
				current=start-1;
			}

			bool Evaluated()const override
			{
				return true;
			}
		};

/***********************************************************************
自包含迭代器
***********************************************************************/

		template<typename T, typename TContainer>
		class ContainerEnumerator : public Object, public virtual IEnumerator<T>
		{
		private:
			Ptr<TContainer>					container;
			vint							index;

		public:
			ContainerEnumerator(Ptr<TContainer> _container, vint _index=-1)
			{
				container=_container;
				index=_index;
			}

			IEnumerator<T>* Clone()const override
			{
				return new ContainerEnumerator(container, index);
			}

			const T& Current()const override
			{
				return container->Get(index);
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				index++;
				return index>=0 && index<container->Count();
			}

			void Reset()override
			{
				index=-1;
			}

			bool Evaluated()const override
			{
				return true;
			}
		};

/***********************************************************************
迭代器比较
***********************************************************************/

		template<typename T, typename U>
		vint CompareEnumerable(const IEnumerable<T>& a, const IEnumerable<U>& b)
		{
			Ptr<IEnumerator<T>> ator=a.CreateEnumerator();
			Ptr<IEnumerator<U>> btor=b.CreateEnumerator();
			while()
			{
				bool a=ator->Next();
				bool b=btor->Next();
				if(a&&!b) return 1;
				if(!a&&b) return -1;
				if(!a&&!b) break;

				const T& ac=ator->Current();
				const U& bc=btor->Current();
				if(ac<bc)
				{
					return -1;
				}
				else if(ac>bc)
				{
					return 1;
				}
				ator->Next();
				btor->Next();
			}
			return 0;
		}

		template<typename T>
		struct SortedListOperations
		{
			static bool Contains(const SortedList<T>& items, const T& item)
			{
				return items.Contains(item);
			}
		};

		template<typename T>
		struct SortedListOperations<Ptr<T>>
		{
			static bool Contains(const SortedList<Ptr<T>>& items, const Ptr<T>& item)
			{
				return items.Contains(item.Obj());
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSELECT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSELECT
#define VCZH_COLLECTIONS_OPERATIONSELECT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Select
***********************************************************************/

		template<typename T, typename K>
		class SelectEnumerator : public virtual IEnumerator<K>
		{
		protected:
			IEnumerator<T>*		enumerator;
			Func<K(T)>			selector;
			K					current;
		public:
			SelectEnumerator(IEnumerator<T>* _enumerator, const Func<K(T)>& _selector, K _current=K())
				:enumerator(_enumerator)
				,selector(_selector)
				,current(_current)
			{
			}

			~SelectEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<K>* Clone()const override
			{
				return new SelectEnumerator(enumerator->Clone(), selector, current);
			}

			const K& Current()const override
			{
				return current;
			}

			vint Index()const override
			{
				return enumerator->Index();
			}

			bool Next()override
			{
				if(enumerator->Next())
				{
					current=selector(enumerator->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()override
			{
				enumerator->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONWHERE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONWHERE
#define VCZH_COLLECTIONS_OPERATIONWHERE


namespace vl
{
	namespace collections
	{
/***********************************************************************
Where
***********************************************************************/

		template<typename T>
		class WhereEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			Func<bool(T)>			selector;
			vint					index;

		public:
			WhereEnumerator(IEnumerator<T>* _enumerator, const Func<bool(T)>& _selector, vint _index=-1)
				:enumerator(_enumerator)
				,selector(_selector)
				,index(_index)
			{
			}

			~WhereEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new WhereEnumerator(enumerator->Clone(), selector, index);
			}

			const T& Current()const override
			{
				return enumerator->Current();
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				while(enumerator->Next())
				{
					if(selector(enumerator->Current()))
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()override
			{
				enumerator->Reset();
				index=-1;
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCONCAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCONCAT
#define VCZH_COLLECTIONS_OPERATIONCONCAT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Concat
***********************************************************************/

		template<typename T>
		class ConcatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			vint							index;
			bool							turned;
		public:
			ConcatEnumerator(IEnumerator<T>* _enumerator1, IEnumerator<T>* _enumerator2, vint _index=-1, bool _turned=false)
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
				,index(_index)
				,turned(_turned)
			{
			}

			~ConcatEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<T>* Clone()const override
			{
				return new ConcatEnumerator(enumerator1->Clone(), enumerator2->Clone(), index, turned);
			}

			const T& Current()const override
			{
				if(turned)
				{
					return enumerator2->Current();
				}
				else
				{
					return enumerator1->Current();
				}
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				index++;
				if(turned)
				{
					return enumerator2->Next();
				}
				else
				{
					if(enumerator1->Next())
					{
						return true;
					}
					else
					{
						turned=true;
						return enumerator2->Next();
					}
				}
			}

			void Reset()override
			{
				enumerator1->Reset();
				enumerator2->Reset();
				index=-1;
				turned=false;
			}

			bool Evaluated()const override
			{
				return enumerator1->Evaluated() && enumerator2->Evaluated();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSEQUENCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSEQUENCE
#define VCZH_COLLECTIONS_OPERATIONSEQUENCE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Take
***********************************************************************/

		template<typename T>
		class TakeEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
		public:
			TakeEnumerator(IEnumerator<T>* _enumerator, vint _count)
				:enumerator(_enumerator)
				,count(_count)
			{
			}

			~TakeEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new TakeEnumerator(enumerator->Clone(), count);
			}

			const T& Current()const override
			{
				return enumerator->Current();
			}

			vint Index()const override
			{
				return enumerator->Index();
			}

			bool Next()override
			{
				if(enumerator->Index()>=count-1) return false;
				return enumerator->Next();
			}

			void Reset()override
			{
				enumerator->Reset();
			}

			bool Evaluated()const override
			{
				return enumerator->Evaluated();
			}
		};

/***********************************************************************
Skip
***********************************************************************/

		template<typename T>
		class SkipEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
			bool					skipped;
		public:
			SkipEnumerator(IEnumerator<T>* _enumerator, vint _count, bool _skipped=false)
				:enumerator(_enumerator)
				,count(_count)
				,skipped(_skipped)
			{
			}

			~SkipEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new SkipEnumerator(enumerator->Clone(), count, skipped);
			}

			const T& Current()const override
			{
				return enumerator->Current();
			}

			vint Index()const override
			{
				return enumerator->Index()-count;
			}

			bool Next()override
			{
				if(!skipped)
				{
					skipped=true;
					for(vint i=0;i<count;i++)
					{
						if(!enumerator->Next())
						{
							return false;
						}
					}
				}
				return enumerator->Next();
			}

			void Reset()override
			{
				enumerator->Reset();
				skipped=false;
			}

			bool Evaluated()const override
			{
				return enumerator->Evaluated();
			}
		};

/***********************************************************************
Repeat
***********************************************************************/

		template<typename T>
		class RepeatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
			vint					index;
			vint					repeatedCount;
		public:
			RepeatEnumerator(IEnumerator<T>* _enumerator, vint _count, vint _index=-1, vint _repeatedCount=0)
				:enumerator(_enumerator)
				,count(_count)
				,index(_index)
				,repeatedCount(_repeatedCount)
			{
			}

			~RepeatEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new RepeatEnumerator(enumerator->Clone(), count, index, repeatedCount);
			}

			const T& Current()const override
			{
				return enumerator->Current();
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				while(repeatedCount<count)
				{
					if(enumerator->Next())
					{
						index++;
						return true;
					}
					repeatedCount++;
					enumerator->Reset();
				}
				return false;
			}

			void Reset()override
			{
				enumerator->Reset();
				index=-1;
				repeatedCount=0;
			}

			bool Evaluated()const override
			{
				return enumerator->Evaluated();
			}
		};

/***********************************************************************
Distinct
***********************************************************************/

		template<typename T>
		class DistinctEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*		enumerator;
			SortedList<T>		distinct;
			T					lastValue;

		public:
			DistinctEnumerator(IEnumerator<T>* _enumerator)
				:enumerator(_enumerator)
			{
			}

			DistinctEnumerator(const DistinctEnumerator& _enumerator)
				:lastValue(_enumerator.lastValue)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(distinct, _enumerator.distinct);
			}

			~DistinctEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new DistinctEnumerator(*this);
			}

			const T& Current()const override
			{
				return lastValue;
			}

			vint Index()const override
			{
				return distinct.Count()-1;
			}

			bool Next()override
			{
				while(enumerator->Next())
				{
					const T& current=enumerator->Current();
					if(!SortedListOperations<T>::Contains(distinct, current))
					{
						lastValue=current;
						distinct.Add(current);
						return true;
					}
				}
				return false;
			}

			void Reset()override
			{
				enumerator->Reset();
				distinct.Clear();
			}
		};

/***********************************************************************
Reverse
***********************************************************************/

		template<typename T>
		class ReverseEnumerator : public virtual IEnumerator<T>
		{
		protected:
			List<T>						cache;
			vint						index;
		public:
			ReverseEnumerator(const IEnumerable<T>& enumerable)
				:index(-1)
			{
				CopyFrom(cache, enumerable);
			}

			ReverseEnumerator(const ReverseEnumerator& _enumerator)
				:index(_enumerator.index)
			{
				CopyFrom(cache, _enumerator.cache);
			}

			~ReverseEnumerator()
			{
			}

			IEnumerator<T>* Clone()const override
			{
				return new ReverseEnumerator(*this);
			}

			const T& Current()const override
			{
				return cache.Get(cache.Count()-1-index);
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				index++;
				return index<cache.Count();
			}

			void Reset()override
			{
				index=-1;
			}

			bool Evaluated()const override
			{
				return true;
			}
		};

/***********************************************************************
FromIterator
***********************************************************************/

		template<typename T, typename I>
		class FromIteratorEnumerable : public Object, public IEnumerable<T>
		{
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
			private:
				I				begin;
				I				end;
				I				current;

			public:
				Enumerator(I _begin, I _end, I _current)
					:begin(_begin)
					,end(_end)
					,current(_current)
				{
				}

				IEnumerator<T>* Clone()const override
				{
					return new Enumerator(begin, end, current);
				}

				const T& Current()const override
				{
					return *current;
				}

				vint Index()const override
				{
					return current-begin;
				}

				bool Next()override
				{
					current++;
					return begin<=current && current<end;
				}

				void Reset()override
				{
					current=begin-1;
				}

				bool Evaluated()const override
				{
					return true;
				}
			};
		private:
			I					begin;
			I					end;
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(begin, end, begin-1);
			}

			FromIteratorEnumerable(I _begin, I _end)
				:begin(_begin)
				,end(_end)
			{
			}
		};

		template<typename T>
		class FromIterator
		{
		public:
			template<typename I>
			static FromIteratorEnumerable<T, I> Wrap(I begin, I end)
			{
				return FromIteratorEnumerable<T, I>(begin, end);
			}
		};

		template<typename T>
		FromIteratorEnumerable<T, T*> FromPointer(T* begin, T* end)
		{
			return FromIteratorEnumerable<T, T*>(begin, end);
		}

		template<typename T, int size>
		FromIteratorEnumerable<T, T*> FromArray(T (&items)[size])
		{
			return FromIteratorEnumerable<T, T*>(&items[0], &items[size]);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSET.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSET
#define VCZH_COLLECTIONS_OPERATIONSET


namespace vl
{
	namespace collections
	{

/***********************************************************************
Intersect/Except
***********************************************************************/

		template<typename T, bool Intersect>
		class IntersectExceptEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*				enumerator;
			SortedList<T>				reference;
			vint						index;

		public:
			IntersectExceptEnumerator(IEnumerator<T>* _enumerator, const IEnumerable<T>& _reference)
				:enumerator(_enumerator)
				,index(-1)
			{
				CopyFrom(reference, _reference);
			}

			IntersectExceptEnumerator(const IntersectExceptEnumerator& _enumerator)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(reference, _enumerator.reference);
				index=_enumerator.index;
			}

			~IntersectExceptEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const override
			{
				return new IntersectExceptEnumerator(*this);
			}

			const T& Current()const override
			{
				return enumerator->Current();
			}

			vint Index()const override
			{
				return index;
			}

			bool Next()override
			{
				while(enumerator->Next())
				{
					if(SortedListOperations<T>::Contains(reference, enumerator->Current())==Intersect)
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()override
			{
				enumerator->Reset();
				index=-1;
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONPAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONPAIR
#define VCZH_COLLECTIONS_OPERATIONPAIR


namespace vl
{
	namespace collections
	{

/***********************************************************************
Pairwise
***********************************************************************/

		template<typename S, typename T>
		class PairwiseEnumerator : public virtual IEnumerator<Pair<S, T>>
		{
		protected:
			IEnumerator<S>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			Pair<S, T>						current;
		public:
			PairwiseEnumerator(IEnumerator<S>* _enumerator1, IEnumerator<T>* _enumerator2, Pair<S, T> _current=Pair<S, T>())
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
				,current(_current)
			{
			}

			~PairwiseEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<Pair<S, T>>* Clone()const override
			{
				return new PairwiseEnumerator(enumerator1->Clone(), enumerator2->Clone(), current);
			}

			const Pair<S, T>& Current()const override
			{
				return current;
			}

			vint Index()const override
			{
				return enumerator1->Index();
			}

			bool Next()override
			{
				if(enumerator1->Next() && enumerator2->Next())
				{
					current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()override
			{
				enumerator1->Reset();
				enumerator2->Reset();
			}

			bool Evaluated()const override
			{
				return enumerator1->Evaluated() && enumerator2->Evaluated();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSTRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSTRING
#define VCZH_COLLECTIONS_OPERATIONSTRING


namespace vl
{
	namespace collections
	{
		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const ObjectString<S>& ss, bool append=false)
		{
			const S* buffer=ss.Buffer();
			vint count=ss.Length();
			CopyFrom(ds, buffer, count, append);
		}

		template<typename D, typename Ss>
		void CopyFrom(ObjectString<D>& ds, const Ss& ss, bool append=false)
		{
			Array<D> da(ds.Buffer(), ds.Length());
			CopyFrom(da, ss, append);
			if(da.Count()==0)
			{
				ds=ObjectString<D>();
			}
			else
			{
				ds=ObjectString<D>(&da[0], da.Count());
			}
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

Functions:
	CopyFrom(TargetContainer, SourceContainer)
	[T]		.Select(T->K) => [K]
	[T]		.SelectMany(T->[K]) => [K]
	[T]		.Where(T->bool) => [T]
	[Ptr<T>].Cast<K>() => [Ptr<K>]
	[Ptr<T>].FindType<K>() => [Ptr<K>]
	[T]		.OrderBy(T->T->int) => [T]

	[T]		.Aggregate(T->T->T) => T
	[T]		.Aggregate(T->T->T, T) => T
	[T]		.All(T->bool) => bool
	[T]		.Any(T->bool) => bool
	[T]		.Max() => T
	[T]		.Min() => T
	[T]		.First() => T
	[T]		.FirstOrDefault(T) => T
	[T]		.Last() => T
	[T]		.LastOrDefault(T) => T
	[T]		.Count() => vint
	[T]		.IsEmpty() => bool

	[T]		.Concat([T]) => [T]
	[T]		.Repeat(vint) => [T]
	[T]		.Take(vint) => [T]
	[T]		.Skip(vint) => [T]
	[T]		.Distinct() => [T]
	[T]		.Reverse() => [T]

	[T]		.Pairwise([K]) => [(T,K)]
	[T]		.Intersect([T]) => [T]
	[T]		.Union([T]) => [T]
	[T]		.Except([T]) => [T]

	[T]		.Evaluate() => [T]
	[T]		.GroupBy(T->K) => [(K, [T])]

	From(begin, end) => [T]
	From(array) => [T]
	Range(start, count) => [vint]

	FOREACH(X, a, XList)
	FOREACH_INDEXER(X, a, index, XList)
***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATION
#define VCZH_COLLECTIONS_OPERATION


namespace vl
{
	namespace collections
	{

/***********************************************************************
OrderBy Quick Sort
***********************************************************************/

		template<typename T, typename F>
		void SortLambda(T* items, vint length, F orderer)
		{
			if(length==0) return;
			vint pivot=0;
			vint left=0;
			vint right=0;
			bool flag=false;

			while(left+right+1!=length)
			{
				vint& mine=(flag?left:right);
				vint& theirs=(flag?right:left);
				vint candidate=(flag?left:length-right-1);
				vint factor=(flag?-1:1);

				if(orderer(items[pivot], items[candidate])*factor<=0)
				{
					mine++;
				}
				else
				{
					theirs++;
					T temp=items[pivot];
					items[pivot]=items[candidate];
					items[candidate]=temp;
					pivot=candidate;
					flag=!flag;
				}
			}

			SortLambda(items, left, orderer);
			SortLambda(items+left+1, right, orderer);
		}

		template<typename T>
		void Sort(T* items, vint length, const Func<vint(T, T)>& orderer)
		{
			SortLambda<T, Func<vint(T, T)>>(items, length, orderer);
		}

/***********************************************************************
LazyList
***********************************************************************/

		template<typename T>
		class LazyList : public Object, public IEnumerable<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumeratorPrototype;

			IEnumerator<T>* xs()const
			{
				return enumeratorPrototype->Clone();
			}
		public:
			LazyList(Ptr<IEnumerator<T>> enumerator)
				:enumeratorPrototype(enumerator)
			{
			}

			LazyList(const IEnumerable<T>& enumerable)
				:enumeratorPrototype(enumerable.CreateEnumerator())
			{
			}

			LazyList(const LazyList<T>& lazyList)
				:enumeratorPrototype(lazyList.enumeratorPrototype)
			{
			}

			template<typename TContainer>
			LazyList(Ptr<TContainer> container)
				:enumeratorPrototype(new ContainerEnumerator<T, TContainer>(container))
			{
			}
			
			LazyList()
				:enumeratorPrototype(EmptyEnumerable<T>().CreateEnumerator())
			{
			}

			LazyList<T>& operator=(const LazyList<T>& lazyList)
			{
				enumeratorPrototype=lazyList.enumeratorPrototype;
				return *this;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return enumeratorPrototype->Clone();
			}

			//-------------------------------------------------------

			template<typename F>
			LazyList<FUNCTION_RESULT_TYPE(F)> Select(F f)const
			{
				return new SelectEnumerator<T, FUNCTION_RESULT_TYPE(F)>(xs(), f);
			}

			template<typename F>
			auto SelectMany(F f)const -> LazyList<decltype(From(f(T())).First())>
			{
				typedef decltype(From(f(T())).First()) U;
				return Select(f).Aggregate(LazyList<U>(), [](const LazyList<U>& a, const IEnumerable<U>& b){return a.Concat(b);});
			}
			
			template<typename F>
			LazyList<T> Where(F f)const
			{
				return new WhereEnumerator<T>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> Cast()const
			{
				Func<Ptr<U>(T)> f=[](T t)->Ptr<U>{return t.Cast<U>();};
				return new SelectEnumerator<T, Ptr<U>>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> FindType()const
			{
				return Cast<U>().Where([](T t){return t;});
			}

			template<typename F>
			LazyList<T> OrderBy(F f)const
			{
				Ptr<List<T>> sorted=new List<T>;
				CopyFrom(*sorted.Obj(), *this);
				if(sorted->Count()>0)
				{
					SortLambda<T, F>(&sorted->operator[](0), sorted->Count(), f);
				}
				return new ContainerEnumerator<T, List<T>>(sorted);
			}

			//-------------------------------------------------------

			template<typename F>
			T Aggregate(F f)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Aggregate(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				T result=enumerator->Current();
				while(enumerator->Next())
				{
					result=f(result, enumerator->Current());
				}
				return result;
			}

			template<typename I, typename F>
			I Aggregate(I init, F f)const
			{
				FOREACH(T, t, *this)
				{
					init=f(init, t);
				}
				return init;
			}

			template<typename F>
			bool All(F f)const
			{
				return Select(f).Aggregate(true, [](bool a, bool b){return a&&b;});
			}

			template<typename F>
			bool Any(F f)const
			{
				return Select(f).Aggregate(false, [](bool a, bool b){return a||b;});
			}

			T Max()const
			{
				return Aggregate([](T a, T b){return a>b?a:b;});
			}

			T Min()const
			{
				return Aggregate([](T a, T b){return a<b?a:b;});
			}

			T First()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::First(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				return enumerator->Current();
			}

			T First(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					return defaultValue;
				}
				return enumerator->Current();
			}

			T Last()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Last(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				else
				{
					T value=enumerator->Current();
					while(enumerator->Next())
					{
						value=enumerator->Current();
					}
					return value;
				}
			}

			T Last(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					defaultValue=enumerator->Current();
				}
				return defaultValue;
			}

			vint Count()const
			{
				vint result=0;
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					result++;
				}
				return result;
			}

			bool IsEmpty()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				return enumerator->Next();
			}

			//-------------------------------------------------------

			LazyList<T> Concat(const IEnumerable<T>& remains)const
			{
				return new ConcatEnumerator<T>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Take(vint count)const
			{
				return new TakeEnumerator<T>(xs(), count);
			}

			LazyList<T> Skip(vint count)const
			{
				return new SkipEnumerator<T>(xs(), count);
			}

			LazyList<T> Repeat(vint count)const
			{
				return new RepeatEnumerator<T>(xs(), count);
			}

			LazyList<T> Distinct()const
			{
				return new DistinctEnumerator<T>(xs());
			}

			LazyList<T> Reverse()const
			{
				return new ReverseEnumerator<T>(*this);
			}

			//-------------------------------------------------------

			template<typename U>
			LazyList<Pair<T, U>> Pairwise(const IEnumerable<U>& remains)const
			{
				return new PairwiseEnumerator<T, U>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Intersect(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, true>(xs(), remains);
			}

			LazyList<T> Except(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, false>(xs(), remains);
			}

			LazyList<T> Union(const IEnumerable<T>& remains)const
			{
				return Concat(remains).Distinct();
			}

			//-------------------------------------------------------

			LazyList<T> Evaluate()const
			{
				if(enumeratorPrototype->Evaluated())
				{
					return *this;
				}
				else
				{
					Ptr<List<T>> xs=new List<T>;
					CopyFrom(*xs.Obj(), *this);
					return xs;
				}
			}

			template<typename F>
			LazyList<Pair<FUNCTION_RESULT_TYPE(F), LazyList<T>>> GroupBy(F f)const
			{
				typedef FUNCTION_RESULT_TYPE(F) K;
				return Select(f)
					.Distinct()
					.Select([=](K k)
					{
						return Pair<K, LazyList<T>>(
							k,
							Where([=](T t){return k==f(t);})
							);
					});
			}
		};

		template<typename T>
		LazyList<T> Range(T start, T count)
		{
			return new RangeEnumerator<T>(start, count);
		}

		template<typename T>
		LazyList<T> From(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

		template<typename T>
		LazyList<T> From(const T* begin, const T* end)
		{
			return FromPointer(begin, end);
		}

		template<typename T, int size>
		LazyList<T> From(T (&items)[size])
		{
			return FromArray(items);
		}

		template<typename T, int size>
		LazyList<T> From(const T (&items)[size])
		{
			return FromArray(items);
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

XML Representation for Code Generation:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace reflection
	{

/***********************************************************************
Attribute
***********************************************************************/

		namespace description
		{
			class ITypeDescriptor;
			class ITypeInfo;
			class IEventHandler;
			class IEventInfo;
			class IPropertyInfo;
			class IParameterInfo;
			class IMethodInfo;
			class IMethodGroupInfo;
			class IValueFunctionProxy;
		}

		class DescriptableObject
		{
			template<typename T, typename Enabled>
			friend struct ReferenceCounterOperator;
			template<typename T>
			friend class Description;
			friend class DescriptableValue;

			typedef collections::Dictionary<WString, Ptr<Object>>		InternalPropertyMap;
			typedef void(*DestructorProc)(DescriptableObject* obj);
		protected:
			volatile vint							referenceCounter;
			DestructorProc							sharedPtrDestructorProc;

			size_t									objectSize;
			description::ITypeDescriptor**			typeDescriptor;
			Ptr<InternalPropertyMap>				internalProperties;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();

			description::ITypeDescriptor*			GetTypeDescriptor();
			Ptr<Object>								GetInternalProperty(const WString& name);
			void									SetInternalProperty(const WString& name, Ptr<Object> value);
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static description::ITypeDescriptor*		associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					if(!typeDescriptor || !*typeDescriptor || associatedTypeDescriptor)
					{
						typeDescriptor=&associatedTypeDescriptor;
					}
				}
			}

			static description::ITypeDescriptor* GetAssociatedTypeDescriptor()
			{
				return associatedTypeDescriptor;
			}

			static void SetAssociatedTypeDescroptor(description::ITypeDescriptor* typeDescroptor)
			{
				associatedTypeDescriptor=typeDescroptor;
			}
		};

		template<typename T>
		description::ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

		class IDescriptable : public virtual Interface, public Description<IDescriptable>
		{
		public:
			~IDescriptable(){}
		};

/***********************************************************************
ReferenceCounterOperator
***********************************************************************/
	}

	template<typename T>
	struct ReferenceCounterOperator<T, typename RequiresConvertable<T, reflection::DescriptableObject>::YesNoType>
	{
		static __forceinline volatile vint* CreateCounter(T* reference)
		{
			reflection::DescriptableObject* obj=reference;
			return &obj->referenceCounter;
		}

		static __forceinline void DeleteReference(volatile vint* counter, void* reference)
		{
			reflection::DescriptableObject* obj=(T*)reference;
			if(obj->sharedPtrDestructorProc)
			{
				obj->sharedPtrDestructorProc(obj);
			}
			else
			{
				delete obj;
			}
		}
	};

	namespace reflection
	{

/***********************************************************************
Value
***********************************************************************/

		namespace description
		{
			class Value : public Object
			{
			public:
				enum ValueType
				{
					Null,
					RawPtr,
					SharedPtr,
					Text,
				};
			protected:
				ValueType						valueType;
				DescriptableObject*				rawPtr;
				Ptr<DescriptableObject>			sharedPtr;
				WString							text;
				ITypeDescriptor*				typeDescriptor;

				Value(DescriptableObject* value);
				Value(Ptr<DescriptableObject> value);
				Value(const WString& value, ITypeDescriptor* associatedTypeDescriptor);

				vint							Compare(const Value& a, const Value& b)const;
			public:
				Value();
				Value(const Value& value);
				Value&							operator=(const Value& value);
				bool							operator==(const Value& value)const { return Compare(*this, value)==0; }
				bool							operator!=(const Value& value)const { return Compare(*this, value)!=0; }
				bool							operator<(const Value& value)const { return Compare(*this, value)<0; }
				bool							operator<=(const Value& value)const { return Compare(*this, value)<=0; }
				bool							operator>(const Value& value)const { return Compare(*this, value)>0; }
				bool							operator>=(const Value& value)const { return Compare(*this, value)>=0; }

				ValueType						GetValueType()const;
				DescriptableObject*				GetRawPtr()const;
				Ptr<DescriptableObject>			GetSharedPtr()const;
				const WString&					GetText()const;
				ITypeDescriptor*				GetTypeDescriptor()const;
				WString							GetTypeFriendlyName()const;
				bool							IsNull()const;
				bool							CanConvertTo(ITypeDescriptor* targetType, ValueType targetValueType)const;
				bool							CanConvertTo(ITypeInfo* targetType)const;

				static Value					From(DescriptableObject* value);
				static Value					From(Ptr<DescriptableObject> value);
				static Value					From(const WString& value, ITypeDescriptor* type);

				static IMethodInfo*				SelectMethod(IMethodGroupInfo* methodGroup, collections::Array<Value>& arguments);
				static Value					Create(const WString& typeName);
				static Value					Create(const WString& typeName, collections::Array<Value>& arguments);
				static Value					InvokeStatic(const WString& typeName, const WString& name);
				static Value					InvokeStatic(const WString& typeName, const WString& name, collections::Array<Value>& arguments);
				Value							GetProperty(const WString& name)const;
				void							SetProperty(const WString& name, const Value& newValue);
				Value							Invoke(const WString& name)const;
				Value							Invoke(const WString& name, collections::Array<Value>& arguments)const;
				Ptr<IEventHandler>				AttachEvent(const WString& name, const Value& function)const;
				bool							DeleteRawPtr();

				template<typename T>
				void SetProperty(const WString& name, const T& newValue)
				{
					return SetProperty(name, BoxValue<T>(newValue));
				}

				class xs
				{
				protected:
					collections::Array<Value>	arguments;
				public:
					xs()
					{
					}

					template<typename T>
					xs& operator,(const T& value)
					{
						arguments.Resize(arguments.Count()+1);
						arguments[arguments.Count()-1]=BoxValue<T>(value);
						return *this;
					}

					xs& operator,(const Value& value)
					{
						arguments.Resize(arguments.Count()+1);
						arguments[arguments.Count()-1]=value;
						return *this;
					}

					operator collections::Array<Value>&()
					{
						return arguments;
					}
				};
			};

			class IValueSerializer : public virtual IDescriptable, public Description<IValueSerializer>
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual bool					Validate(const WString& text)=0;
				virtual bool					Parse(const WString& input, Value& output)=0;

				virtual bool					HasCandidate()=0;
				virtual vint					GetCandidateCount()=0;
				virtual WString					GetCandidate(vint index)=0;
				virtual bool					CanMergeCandidate()=0;
			};

			template<typename T>
			class ITypedValueSerializer : public IValueSerializer
			{
			public:
				virtual bool					Serialize(const T& input, Value& output)=0;
				virtual bool					Deserialize(const Value& input, T& output)=0;
			};

/***********************************************************************
ITypeDescriptor (type)
***********************************************************************/

			class ITypeInfo : public virtual IDescriptable, public Description<ITypeInfo>
			{
			public:
				enum Decorator
				{
					RawPtr,
					SharedPtr,
					TypeDescriptor,
					Generic,
				};

				virtual Decorator				GetDecorator()=0;
				virtual ITypeInfo*				GetElementType()=0;
				virtual ITypeDescriptor*		GetTypeDescriptor()=0;
				virtual vint					GetGenericArgumentCount()=0;
				virtual ITypeInfo*				GetGenericArgument(vint index)=0;
				virtual WString					GetTypeFriendlyName()=0;
			};

/***********************************************************************
ITypeDescriptor (basic)
***********************************************************************/

			class IMemberInfo : public virtual IDescriptable, public Description<IMemberInfo>
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual const WString&			GetName()=0;
			};

/***********************************************************************
ITypeDescriptor (event)
***********************************************************************/

			class IEventHandler : public virtual IDescriptable, public Description<IEventHandler>
			{
			public:
				virtual IEventInfo*				GetOwnerEvent()=0;
				virtual Value					GetOwnerObject()=0;
				virtual bool					IsAttached()=0;
				virtual bool					Detach()=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

			class IEventInfo : public virtual IMemberInfo, public Description<IEventInfo>
			{
			public:
				virtual ITypeInfo*				GetHandlerType()=0;
				virtual vint					GetObservingPropertyCount()=0;
				virtual IPropertyInfo*			GetObservingProperty(vint index)=0;
				virtual Ptr<IEventHandler>		Attach(const Value& thisObject, Ptr<IValueFunctionProxy> handler)=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

/***********************************************************************
ITypeDescriptor (property)
***********************************************************************/

			class IPropertyInfo : public virtual IMemberInfo, public Description<IPropertyInfo>
			{
			public:
				virtual bool					IsReadable()=0;
				virtual bool					IsWritable()=0;
				virtual ITypeInfo*				GetReturn()=0;
				virtual IMethodInfo*			GetGetter()=0;
				virtual IMethodInfo*			GetSetter()=0;
				virtual IEventInfo*				GetValueChangedEvent()=0;
				virtual Value					GetValue(const Value& thisObject)=0;
				virtual void					SetValue(Value& thisObject, const Value& newValue)=0;
			};

/***********************************************************************
ITypeDescriptor (method)
***********************************************************************/

			class IParameterInfo : public virtual IMemberInfo, public Description<IParameterInfo>
			{
			public:
				virtual ITypeInfo*				GetType()=0;
				virtual IMethodInfo*			GetOwnerMethod()=0;
			};

			class IMethodInfo : public virtual IMemberInfo, public Description<IMethodInfo>
			{
			public:
				virtual IMethodGroupInfo*		GetOwnerMethodGroup()=0;
				virtual IPropertyInfo*			GetOwnerProperty()=0;
				virtual vint					GetParameterCount()=0;
				virtual IParameterInfo*			GetParameter(vint index)=0;
				virtual ITypeInfo*				GetReturn()=0;
				virtual bool					IsStatic()=0;
				virtual void					CheckArguments(collections::Array<Value>& arguments)=0;
				virtual Value					Invoke(const Value& thisObject, collections::Array<Value>& arguments)=0;
			};

			class IMethodGroupInfo : public virtual IMemberInfo, public Description<IMethodGroupInfo>
			{
			public:
				virtual vint					GetMethodCount()=0;
				virtual IMethodInfo*			GetMethod(vint index)=0;
			};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

			class ITypeDescriptor : public virtual IDescriptable, public Description<ITypeDescriptor>
			{
			public:
				virtual const WString&			GetTypeName()=0;
				virtual IValueSerializer*		GetValueSerializer()=0;
				virtual vint					GetBaseTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetBaseTypeDescriptor(vint index)=0;
				virtual bool					CanConvertTo(ITypeDescriptor* targetType)=0;

				virtual vint					GetPropertyCount()=0;
				virtual IPropertyInfo*			GetProperty(vint index)=0;
				virtual bool					IsPropertyExists(const WString& name, bool inheritable)=0;
				virtual IPropertyInfo*			GetPropertyByName(const WString& name, bool inheritable)=0;

				virtual vint					GetEventCount()=0;
				virtual IEventInfo*				GetEvent(vint index)=0;
				virtual bool					IsEventExists(const WString& name, bool inheritable)=0;
				virtual IEventInfo*				GetEventByName(const WString& name, bool inheritable)=0;

				virtual vint					GetMethodGroupCount()=0;
				virtual IMethodGroupInfo*		GetMethodGroup(vint index)=0;
				virtual bool					IsMethodGroupExists(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetMethodGroupByName(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetConstructorGroup()=0;
			};

/***********************************************************************
ITypeManager
***********************************************************************/

			class ITypeManager;

			class ITypeLoader : public virtual Interface
			{
			public:
				virtual void					Load(ITypeManager* manager)=0;
				virtual void					Unload(ITypeManager* manager)=0;
			};

			class ITypeManager : public virtual Interface
			{
			public:
				virtual vint					GetTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(vint index)=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(const WString& name)=0;
				virtual bool					SetTypeDescriptor(const WString& name, Ptr<ITypeDescriptor> typeDescriptor)=0;

				virtual bool					AddTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					RemoveTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					Load()=0;
				virtual bool					Unload()=0;
				virtual bool					Reload()=0;
				virtual bool					IsLoaded()=0;
				virtual ITypeDescriptor*		GetRootType()=0;
			};

			extern ITypeManager*				GetGlobalTypeManager();
			extern bool							DestroyGlobalTypeManager();
			extern bool							ResetGlobalTypeManager();
			extern IValueSerializer*			GetValueSerializer(const WString& name);
			extern ITypeDescriptor*				GetTypeDescriptor(const WString& name);
			extern void							LogTypeManager(stream::TextWriter& writer);

/***********************************************************************
Collections
***********************************************************************/

			class IValueEnumerator : public virtual IDescriptable, public Description<IValueEnumerator>
			{
			public:
				virtual Value					GetCurrent()=0;
				virtual vint					GetIndex()=0;
				virtual bool					Next()=0;
			};

			class IValueEnumerable : public virtual IDescriptable, public Description<IValueEnumerable>
			{
			private:
				template<typename T>
				class TypedEnumerator : public Object, public collections::IEnumerator<T>
				{
				private:
					Ptr<IValueEnumerable>		enumerable;
					Ptr<IValueEnumerator>		enumerator;
					vint						index;
					T							value;

				public:
					TypedEnumerator(Ptr<IValueEnumerable> _enumerable, vint _index, const T& _value)
						:enumerable(_enumerable)
						,index(_index)
						,value(_value)
					{
						enumerator=enumerable->CreateEnumerator();
						vint current=-1;
						while(current++<index)
						{
							enumerator->Next();
						}
					}

					TypedEnumerator(Ptr<IValueEnumerable> _enumerable)
						:enumerable(_enumerable)
						,index(-1)
					{
						Reset();
					}

					collections::IEnumerator<T>* Clone()const override
					{
						return new TypedEnumerable<T>(enumerable, index, value);
					}

					const T& Current()const override
					{
						return value;
					}

					vint Index()const override
					{
						return index;
					}

					bool Next() override
					{
						if(enumerator->Next())
						{
							index++;
							value=UnboxValue<T>(enumerator->GetCurrent());
							return true;
						}
						else
						{
							return false;
						}
					}

					void Reset() override
					{
						index=-1;
						enumerator=enumerable->CreateEnumerator();
					}
				};
			public:
				virtual Ptr<IValueEnumerator>	CreateEnumerator()=0;

				static Ptr<IValueEnumerable>	Create(collections::LazyList<Value> values);

				template<typename T>
				static collections::LazyList<T> GetLazyList(Ptr<IValueEnumerator> value)
				{
					return collections:::LazyList<T>(new TypedEnumerator<T>(value));
				}
			};

			class IValueReadonlyList : public virtual IValueEnumerable, public Description<IValueReadonlyList>
			{
			public:
				virtual vint					GetCount()=0;
				virtual Value					Get(vint index)=0;
				virtual bool					Contains(const Value& value)=0;
				virtual vint					IndexOf(const Value& value)=0;

				template<typename T>
				collections::LazyList<T> GetLazyList()
				{
					return collections::Range<vint>(0, GetCount())
						.Select([this](vint i)
						{
							return UnboxValue<T>(Get(i));
						});
				}
			};

			class IValueList : public virtual IValueReadonlyList, public Description<IValueList>
			{
			public:
				virtual void					Set(vint index, const Value& value)=0;
				virtual vint					Add(const Value& value)=0;
				virtual vint					Insert(vint index, const Value& value)=0;
				virtual bool					Remove(const Value& value)=0;
				virtual bool					RemoveAt(vint index)=0;
				virtual void					Clear()=0;

				static Ptr<IValueList>			Create();
				static Ptr<IValueList>			Create(Ptr<IValueReadonlyList> values);
				static Ptr<IValueList>			Create(collections::LazyList<Value> values);
			};

			class IValueReadonlyDictionary : public virtual IDescriptable, public Description<IValueReadonlyDictionary>
			{
			public:
				virtual IValueReadonlyList*		GetKeys()=0;
				virtual IValueReadonlyList*		GetValues()=0;
				virtual vint					GetCount()=0;
				virtual Value					Get(const Value& key)=0;

				template<typename K, typename V>
				collections::LazyList<collections::Pair<K, V>> GetLazyList()
				{
					return collections::Range<vint>(0, GetCount())
						.Select([this](vint i)
						{
							return collections::Pair<K, V>(UnboxValue<K>(GetKeys()->Get(i)), UnboxValue<V>(GetValues()->Get(i)));
						});
				}
			};

			class IValueDictionary : public virtual IValueReadonlyDictionary, public Description<IValueDictionary>
			{
			public:
				virtual void					Set(const Value& key, const Value& value)=0;
				virtual bool					Remove(const Value& key)=0;
				virtual void					Clear()=0;

				static Ptr<IValueDictionary>	Create();
				static Ptr<IValueDictionary>	Create(Ptr<IValueReadonlyDictionary> values);
				static Ptr<IValueDictionary>	Create(collections::LazyList<collections::Pair<Value, Value>> values);
			};

/***********************************************************************
Collection Wrappers
***********************************************************************/

			namespace trait_helper
			{
				template<typename T>
				struct RemovePtr
				{
					typedef T					Type;
				};
				
				template<typename T>
				struct RemovePtr<T*>
				{
					typedef T					Type;
				};
				
				template<typename T>
				struct RemovePtr<Ptr<T>>
				{
					typedef T					Type;
				};
			}

#pragma warning(push)
#pragma warning(disable:4250)
			template<typename T>
			class ValueEnumeratorWrapper : public Object, public virtual IValueEnumerator
			{
			protected:
				typedef typename trait_helper::RemovePtr<T>::Type		ContainerType;
				typedef typename ContainerType::ElementType				ElementType;

				T								wrapperPointer;
			public:
				ValueEnumeratorWrapper(const T& _wrapperPointer)
					:wrapperPointer(_wrapperPointer)
				{
				}

				Value GetCurrent()override
				{
					return BoxValue<ElementType>(wrapperPointer->Current());
				}

				vint GetIndex()override
				{
					return wrapperPointer->Index();
				}

				bool Next()override
				{
					return wrapperPointer->Next();
				}
			};

			template<typename T>
			class ValueEnumerableWrapper : public Object, public virtual IValueEnumerable
			{
			protected:
				typedef typename trait_helper::RemovePtr<T>::Type		ContainerType;
				typedef typename ContainerType::ElementType				ElementType;

				T								wrapperPointer;
			public:
				ValueEnumerableWrapper(const T& _wrapperPointer)
					:wrapperPointer(_wrapperPointer)
				{
				}

				Ptr<IValueEnumerator> CreateEnumerator()override
				{
					return new ValueEnumeratorWrapper<Ptr<collections::IEnumerator<ElementType>>>(wrapperPointer->CreateEnumerator());
				}
			};

			template<typename T>
			class ValueReadonlyListWrapper : public ValueEnumerableWrapper<T>, public virtual IValueReadonlyList
			{
			protected:
				typedef typename trait_helper::RemovePtr<T>::Type		ContainerType;
				typedef typename ContainerType::ElementType				ElementType;
				typedef typename KeyType<ElementType>::Type				ElementKeyType;

			public:
				ValueReadonlyListWrapper(const T& _wrapperPointer)
					:ValueEnumerableWrapper(_wrapperPointer)
				{
				}

				vint GetCount()override
				{
					return wrapperPointer->Count();
				}

				Value Get(vint index)override
				{
					return BoxValue<ElementType>(wrapperPointer->Get(index));
				}

				bool Contains(const Value& value)override
				{
					ElementKeyType item=UnboxValue<ElementKeyType>(value);
					return wrapperPointer->Contains(item);
				}

				vint IndexOf(const Value& value)override
				{
					ElementKeyType item=UnboxValue<ElementKeyType>(value);
					return wrapperPointer->IndexOf(item);
				}
			};

			template<typename T>
			class ValueListWrapper : public ValueReadonlyListWrapper<T>, public virtual IValueList
			{
			protected:
				typedef typename trait_helper::RemovePtr<T>::Type		ContainerType;
				typedef typename ContainerType::ElementType				ElementType;
				typedef typename KeyType<ElementType>::Type				ElementKeyType;

			public:
				ValueListWrapper(const T& _wrapperPointer)
					:ValueReadonlyListWrapper(_wrapperPointer)
				{
				}

				void Set(vint index, const Value& value)override
				{
					ElementType item=UnboxValue<ElementType>(value);
					wrapperPointer->Set(index, item);
				}

				vint Add(const Value& value)override
				{
					ElementType item=UnboxValue<ElementType>(value);
					return wrapperPointer->Add(item);
				}

				vint Insert(vint index, const Value& value)override
				{
					ElementType item=UnboxValue<ElementType>(value);
					return wrapperPointer->Insert(index, item);
				}

				bool Remove(const Value& value)override
				{
					ElementKeyType item=UnboxValue<ElementKeyType>(value);
					return wrapperPointer->Remove(item);
				}

				bool RemoveAt(vint index)override
				{
					return wrapperPointer->RemoveAt(index);
				}

				void Clear()override
				{
					wrapperPointer->Clear();
				}
			};

			template<typename T>
			class ValueReadonlyDictionaryWrapper : public virtual Object, public virtual IValueReadonlyDictionary
			{
			protected:
				typedef typename trait_helper::RemovePtr<T>::Type		ContainerType;
				typedef typename ContainerType::KeyContainer			KeyContainer;
				typedef typename ContainerType::ValueContainer			ValueContainer;
				typedef typename KeyContainer::ElementType				KeyValueType;
				typedef typename KeyType<KeyValueType>::Type			KeyKeyType;
				typedef typename ValueContainer::ElementType			ValueType;

				T								wrapperPointer;
				Ptr<IValueReadonlyList>			keys;
				Ptr<IValueReadonlyList>			values;
			public:
				ValueReadonlyDictionaryWrapper(const T& _wrapperPointer)
					:wrapperPointer(_wrapperPointer)
				{
				}

				IValueReadonlyList* GetKeys()override
				{
					if(!keys)
					{
						keys=new ValueReadonlyListWrapper<const KeyContainer*>(&wrapperPointer->Keys());
					}
					return keys.Obj();
				}

				IValueReadonlyList* GetValues()override
				{
					if(!values)
					{
						values=new ValueReadonlyListWrapper<const ValueContainer*>(&wrapperPointer->Values());
					}
					return values.Obj();
				}

				vint GetCount()override
				{
					return wrapperPointer->Count();
				}

				Value Get(const Value& key)override
				{
					KeyKeyType item=UnboxValue<KeyKeyType>(key);
					ValueType result=wrapperPointer->Get(item);
					return BoxValue<ValueType>(result);
				}
			};
			
			template<typename T>
			class ValueDictionaryWrapper : public virtual ValueReadonlyDictionaryWrapper<T>, public virtual IValueDictionary
			{
			public:
				ValueDictionaryWrapper(const T& _wrapperPointer)
					:ValueReadonlyDictionaryWrapper(_wrapperPointer)
				{
				}

				void Set(const Value& key, const Value& value)override
				{
					KeyValueType item=UnboxValue<KeyValueType>(key);
					ValueType result=UnboxValue<ValueType>(value);
					wrapperPointer->Set(item, result);
				}

				bool Remove(const Value& key)override
				{
					KeyKeyType item=UnboxValue<KeyKeyType>(key);
					return wrapperPointer->Remove(item);
				}

				void Clear()override
				{
					wrapperPointer->Clear();
				}
			};
#pragma warning(pop)

/***********************************************************************
Interface Implementation Proxy
***********************************************************************/

			class IValueInterfaceProxy : public virtual IDescriptable, public Description<IValueInterfaceProxy>
			{
			public:
				virtual Value					Invoke(const WString& methodName, Ptr<IValueList> arguments)=0;
			};

			class IValueFunctionProxy : public virtual IDescriptable, public Description<IValueFunctionProxy>
			{
			public:
				virtual Value					Invoke(Ptr<IValueList> arguments)=0;
			};

			class ValueInterfaceRoot : public virtual IDescriptable
			{
			protected:
				Ptr<IValueInterfaceProxy>		proxy;
			public:
				ValueInterfaceRoot(Ptr<IValueInterfaceProxy> _proxy)
					:proxy(_proxy)
				{
				}

				Ptr<IValueInterfaceProxy> GetProxy()
				{
					return proxy;
				}
			};

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorException : public Exception
			{
			public:
				TypeDescriptorException(const WString& message)
					:Exception(message)
				{
				}
			};

			class TypeNotExistsException : public TypeDescriptorException
			{
			public:
				TypeNotExistsException(const WString& name)
					:TypeDescriptorException(L"Cannot find the type \""+name+L"\".")
				{
				}
			};

			class ConstructorNotExistsException : public TypeDescriptorException
			{
			public:
				ConstructorNotExistsException()
					:TypeDescriptorException(L"Cannot find any constructor.")
				{
				}
			};

			class MemberNotExistsException : public TypeDescriptorException
			{
			public:
				MemberNotExistsException(const WString& name)
					:TypeDescriptorException(L"Cannot find the member \""+name+L"\".")
				{
				}
			};

			class PropertyIsNotReadableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotReadableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot read value from a property \""+propertyInfo->GetName()+L"\" that is not readable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\".")
				{
				}
			};

			class PropertyIsNotWritableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotWritableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot write value to a property \""+propertyInfo->GetName()+L"\" that is not writable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\".")
				{
				}
			};

			class ArgumentNullException : public TypeDescriptorException
			{
			public:
				ArgumentNullException(const WString& name)
					:TypeDescriptorException(L"Argument \""+name+L"\" cannot be null.")
				{
				}
			};

			class ArgumentTypeMismtatchException : public TypeDescriptorException
			{
			public:
				ArgumentTypeMismtatchException(const WString& name, ITypeInfo* expected, const Value& actual)
					:TypeDescriptorException(L"Argument \""+name+L"\" cannot convert from \""+actual.GetTypeFriendlyName()+L"\" to \""+expected->GetTypeFriendlyName()+L"\".")
				{
				}

				ArgumentTypeMismtatchException(const WString& name, ITypeDescriptor* type, Value::ValueType valueType, const Value& actual)
					:TypeDescriptorException(L"Argument \""+name+L"\" cannot convert from \""+actual.GetTypeFriendlyName()+L"\" to \""+
						(valueType==Value::SharedPtr?L"Ptr<":L"")+type->GetTypeName()+(valueType==Value::SharedPtr?L">":valueType==Value::RawPtr?L"*":L"")
						+L"\".")
				{
				}
			};

			class ArgumentCountMismtatchException : public TypeDescriptorException
			{
			public:
				ArgumentCountMismtatchException()
					:TypeDescriptorException(L"Argument count does not match the definition.")
				{
				}
			};
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGTREE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Parsing Tree

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGTREE
#define VCZH_PARSING_PARSINGTREE


namespace vl
{
	namespace parsing
	{

/***********************************************************************
位置信息
***********************************************************************/

		struct ParsingTextPos
		{
			static const int	UnknownValue=-2;
			vint				index;
			vint				row;
			vint				column;

			ParsingTextPos()
				:index(UnknownValue)
				,row(UnknownValue)
				,column(UnknownValue)
			{
			}

			ParsingTextPos(vint _index)
				:index(_index)
				,row(UnknownValue)
				,column(UnknownValue)
			{
			}

			ParsingTextPos(vint _row, vint _column)
				:index(UnknownValue)
				,row(_row)
				,column(_column)
			{
			}

			ParsingTextPos(vint _index, vint _row, vint _column)
				:index(_index)
				,row(_row)
				,column(_column)
			{
			}

			static vint Compare(const ParsingTextPos& a, const ParsingTextPos& b)
			{
				if(a.index!=UnknownValue && b.index!=UnknownValue)
				{
					return a.index-b.index;
				}
				else if(a.row!=UnknownValue && a.column!=UnknownValue && b.row!=UnknownValue && b.column!=UnknownValue)
				{
					if(a.row==b.row)
					{
						return a.column-b.column;
					}
					else
					{
						return a.row-b.row;
					}
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const ParsingTextPos& pos)const{return Compare(*this, pos)==0;}
			bool operator!=(const ParsingTextPos& pos)const{return Compare(*this, pos)!=0;}
			bool operator<(const ParsingTextPos& pos)const{return Compare(*this, pos)<0;}
			bool operator<=(const ParsingTextPos& pos)const{return Compare(*this, pos)<=0;}
			bool operator>(const ParsingTextPos& pos)const{return Compare(*this, pos)>0;}
			bool operator>=(const ParsingTextPos& pos)const{return Compare(*this, pos)>=0;}
		};

		struct ParsingTextRange
		{
			ParsingTextPos	start;
			ParsingTextPos	end;

			ParsingTextRange()
			{
				end.index=-1;
				end.column=-1;
			}

			ParsingTextRange(const ParsingTextPos& _start, const ParsingTextPos& _end)
				:start(_start)
				,end(_end)
			{
			}

			ParsingTextRange(const regex::RegexToken* startToken, const regex::RegexToken* endToken)
			{
				start.index=startToken->start;
				start.row=startToken->rowStart;
				start.column=startToken->columnStart;
				end.index=endToken->start+endToken->length-1;
				end.row=endToken->rowEnd;
				end.column=endToken->columnEnd;
			}

			bool operator==(const ParsingTextRange& range)const{return start==range.start && end==range.end;}
			bool operator!=(const ParsingTextRange& range)const{return start!=range.start || end!=range.end;}
			bool Contains(const ParsingTextPos& pos)const{return start<=pos && pos<=end;}
			bool Contains(const ParsingTextRange& range)const{return start<=range.start && range.end<=end;}
		};

/***********************************************************************
通用语法树
***********************************************************************/

		class ParsingTreeNode;
		class ParsingTreeToken;
		class ParsingTreeObject;
		class ParsingTreeArray;

		class ParsingTreeNode : public Object, public reflection::Description<ParsingTreeNode>
		{
		public:
			class IVisitor : public Interface
			{
			public:
				virtual void					Visit(ParsingTreeToken* node)=0;
				virtual void					Visit(ParsingTreeObject* node)=0;
				virtual void					Visit(ParsingTreeArray* node)=0;
			};

			class TraversalVisitor : public Object, public IVisitor
			{
			public:
				enum TraverseDirection
				{
					ByTextPosition,
					ByStorePosition
				};
			protected:
				TraverseDirection				direction;
			public:
				TraversalVisitor(TraverseDirection _direction);

				virtual void					BeforeVisit(ParsingTreeToken* node);
				virtual void					AfterVisit(ParsingTreeToken* node);
				virtual void					BeforeVisit(ParsingTreeObject* node);
				virtual void					AfterVisit(ParsingTreeObject* node);
				virtual void					BeforeVisit(ParsingTreeArray* node);
				virtual void					AfterVisit(ParsingTreeArray* node);

				virtual void					Visit(ParsingTreeToken* node)override;
				virtual void					Visit(ParsingTreeObject* node)override;
				virtual void					Visit(ParsingTreeArray* node)override;
			};
		protected:
			typedef collections::List<Ptr<ParsingTreeNode>>				NodeList;

			ParsingTextRange					codeRange;
			ParsingTreeNode*					parent;
			NodeList							cachedOrderedSubNodes;

			virtual const NodeList&				GetSubNodesInternal()=0;
			bool								BeforeAddChild(Ptr<ParsingTreeNode> node);
			void								AfterAddChild(Ptr<ParsingTreeNode> node);
			bool								BeforeRemoveChild(Ptr<ParsingTreeNode> node);
			void								AfterRemoveChild(Ptr<ParsingTreeNode> node);
		public:
			ParsingTreeNode(const ParsingTextRange& _codeRange);
			~ParsingTreeNode();

			virtual void						Accept(IVisitor* visitor)=0;
			virtual Ptr<ParsingTreeNode>		Clone()=0;
			ParsingTextRange					GetCodeRange();
			void								SetCodeRange(const ParsingTextRange& range);

			void								InitializeQueryCache();
			void								ClearQueryCache();
			ParsingTreeNode*					GetParent();
			const NodeList&						GetSubNodes();

			ParsingTreeNode*					FindSubNode(const ParsingTextPos& position);
			ParsingTreeNode*					FindSubNode(const ParsingTextRange& range);
			ParsingTreeNode*					FindDeepestNode(const ParsingTextPos& position);
			ParsingTreeNode*					FindDeepestNode(const ParsingTextRange& range);
		};

		class ParsingTreeToken : public ParsingTreeNode, public reflection::Description<ParsingTreeToken>
		{
		protected:
			WString								value;
			vint								tokenIndex;

			const NodeList&						GetSubNodesInternal()override;
		public:
			ParsingTreeToken(const WString& _value, vint _tokenIndex=-1, const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeToken();

			void								Accept(IVisitor* visitor)override;
			Ptr<ParsingTreeNode>				Clone()override;
			vint								GetTokenIndex();
			void								SetTokenIndex(vint _tokenIndex);
			const WString&						GetValue();
			void								SetValue(const WString& _value);
		};

		class ParsingTreeObject : public ParsingTreeNode, public reflection::Description<ParsingTreeObject>
		{
		protected:
			typedef collections::Dictionary<WString, Ptr<ParsingTreeNode>>				NodeMap;
			typedef collections::SortedList<WString>									NameList;
			typedef collections::List<WString>											RuleList;

			WString								type;
			NodeMap								members;
			RuleList							rules;

			const NodeList&			GetSubNodesInternal()override;
		public:
			ParsingTreeObject(const WString& _type=L"", const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeObject();

			void								Accept(IVisitor* visitor)override;
			Ptr<ParsingTreeNode>				Clone()override;
			const WString&						GetType();
			void								SetType(const WString& _type);
			NodeMap&							GetMembers();
			Ptr<ParsingTreeNode>				GetMember(const WString& name);
			bool								SetMember(const WString& name, Ptr<ParsingTreeNode> node);
			bool								RemoveMember(const WString& name);
			const NameList&						GetMemberNames();
			RuleList&							GetCreatorRules();
		};

		class ParsingTreeArray : public ParsingTreeNode, public reflection::Description<ParsingTreeArray>
		{
		protected:
			typedef collections::List<Ptr<ParsingTreeNode>>								NodeArray;

			WString								elementType;
			NodeArray							items;

			const NodeList&						GetSubNodesInternal()override;
		public:
			ParsingTreeArray(const WString& _elementType=L"", const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeArray();

			void								Accept(IVisitor* visitor)override;
			Ptr<ParsingTreeNode>				Clone()override;
			const WString&						GetElementType();
			void								SetElementType(const WString& _elementType);
			NodeArray&							GetItems();
			Ptr<ParsingTreeNode>				GetItem(vint index);
			bool								SetItem(vint index, Ptr<ParsingTreeNode> node);
			bool								AddItem(Ptr<ParsingTreeNode> node);
			bool								InsertItem(vint index, Ptr<ParsingTreeNode> node);
			bool								RemoveItem(vint index);
			bool								RemoveItem(ParsingTreeNode* node);
			vint								IndexOfItem(ParsingTreeNode* node);
			bool								ContainsItem(ParsingTreeNode* node);
			vint								Count();
			bool								Clear();
		};

/***********************************************************************
辅助函数
***********************************************************************/

		extern void								Log(ParsingTreeNode* node, const WString& originalInput, stream::TextWriter& writer, const WString& prefix=L"");

/***********************************************************************
语法树基础设施
***********************************************************************/

		class ParsingTreeCustomBase : public Object
		{
		public:
			ParsingTextRange					codeRange;
			collections::List<WString>			creatorRules;
		};

		class ParsingToken : public ParsingTreeCustomBase
		{
		public:
			vint								tokenIndex;
			WString								value;

			ParsingToken():tokenIndex(-1){}
		};

		class ParsingError : public Object
		{
		public:
			ParsingTextRange					codeRange;
			const regex::RegexToken*			token;
			ParsingTreeCustomBase*				parsingTree;
			WString								errorMessage;

			ParsingError();
			ParsingError(const WString& _errorMessage);
			ParsingError(const regex::RegexToken* _token, const WString& _errorMessage);
			ParsingError(ParsingTreeCustomBase* _parsingTree, const WString& _errorMessage);
			~ParsingError();
		};

/***********************************************************************
语法树构造
***********************************************************************/

		class ParsingTreeConverter : public Object
		{
		public:
			typedef collections::List<regex::RegexToken>	TokenList;

			virtual Ptr<ParsingTreeCustomBase>				ConvertClass(Ptr<ParsingTreeObject> obj, const TokenList& tokens)=0;

			bool SetMember(ParsingToken& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeToken> token=node.Cast<ParsingTreeToken>();
				if(token)
				{
					member.tokenIndex=token->GetTokenIndex();
					member.value=token->GetValue();
					member.codeRange=token->GetCodeRange();
					return true;
				}
				return false;
			}

			template<typename T>
			bool SetMember(collections::List<T>& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeArray> arr=node.Cast<ParsingTreeArray>();
				if(arr)
				{
					member.Clear();
					vint count=arr->Count();
					for(vint i=0;i<count;i++)
					{
						T t;
						SetMember(t, arr->GetItem(i), tokens);
						member.Add(t);
					}
					return true;
				}
				return false;
			}

			template<typename T>
			bool SetMember(Ptr<T>& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeObject> obj=node.Cast<ParsingTreeObject>();
				if(obj)
				{
					Ptr<ParsingTreeCustomBase> tree=ConvertClass(obj, tokens);
					if(tree)
					{
						tree->codeRange=node->GetCodeRange();
						member=tree.Cast<T>();
						return member;
					}
				}
				return false;
			}
		};

/***********************************************************************
符号表
***********************************************************************/

		class ParsingScope;
		class ParsingScopeSymbol;
		class ParsingScopeFinder;

		class ParsingScope : public Object, public reflection::Description<ParsingScope>
		{
			typedef collections::SortedList<WString>							SymbolKeyList;
			typedef collections::List<Ptr<ParsingScopeSymbol>>					SymbolList;
			typedef collections::Group<WString, Ptr<ParsingScopeSymbol>>		SymbolGroup;

			friend class ParsingScopeSymbol;
			friend class ParsingScopeFinder;
		protected:
			static const SymbolList					emptySymbolList;

			ParsingScopeSymbol*						ownerSymbol;
			SymbolGroup								symbols;

		public:
			ParsingScope(ParsingScopeSymbol* _ownerSymbol);
			~ParsingScope();

			ParsingScopeSymbol*						GetOwnerSymbol();
			bool									AddSymbol(Ptr<ParsingScopeSymbol> value);
			bool									RemoveSymbol(Ptr<ParsingScopeSymbol> value);
			const SymbolKeyList&					GetSymbolNames();
			const SymbolList&						GetSymbols(const WString& name);
		};

		class ParsingScopeSymbol : public Object, public reflection::Description<ParsingScopeSymbol>
		{
			friend class ParsingScope;
		protected:
			ParsingScope*							parentScope;
			WString									name;
			collections::List<vint>					semanticIds;
			Ptr<ParsingTreeObject>					node;
			Ptr<ParsingScope>						scope;

			virtual WString							GetDisplayInternal(vint semanticId);
		public:
			ParsingScopeSymbol(const WString& _name=L"", vint _semanticId=-1);
			~ParsingScopeSymbol();

			ParsingScope*							GetParentScope();
			const WString&							GetName();
			const collections::List<vint>&			GetSemanticIds();
			bool									AddSemanticId(vint semanticId);
			Ptr<ParsingTreeObject>					GetNode();
			void									SetNode(Ptr<ParsingTreeObject> value);
			bool									CreateScope();
			bool									DestroyScope();
			ParsingScope*							GetScope();
			WString									GetDisplay(vint semanticId);
		};

		class ParsingScopeFinder : public Object, public reflection::Description<ParsingScopeFinder>
		{
			typedef collections::Dictionary<ParsingTreeObject*, ParsingScopeSymbol*>			NodeSymbolMap;
			typedef collections::LazyList<Ptr<ParsingScopeSymbol>>								LazySymbolList;
		public:
			class SymbolMapper : public Object, public reflection::Description<SymbolMapper>
			{
			public:
				virtual ParsingTreeNode*			ParentNode(ParsingTreeNode* node)=0;
				virtual ParsingTreeNode*			Node(ParsingTreeNode* node)=0;
				virtual ParsingScope*				ParentScope(ParsingScopeSymbol* symbol)=0;
				virtual ParsingScopeSymbol*			Symbol(ParsingScopeSymbol* symbol)=0;
			};

			class DirectSymbolMapper : public SymbolMapper, public reflection::Description<DirectSymbolMapper>
			{
			public:
				DirectSymbolMapper();
				~DirectSymbolMapper();

				ParsingTreeNode*					ParentNode(ParsingTreeNode* node)override;
				ParsingTreeNode*					Node(ParsingTreeNode* node)override;
				ParsingScope*						ParentScope(ParsingScopeSymbol* symbol)override;
				ParsingScopeSymbol*					Symbol(ParsingScopeSymbol* symbol)override;
			};

			class IndirectSymbolMapper  : public SymbolMapper, public reflection::Description<IndirectSymbolMapper>
			{
			protected:
				ParsingScopeSymbol*					originalSymbol;
				ParsingScopeSymbol*					replacedSymbol;
				ParsingTreeNode*					originalNode;
				ParsingTreeNode*					replacedNode;
			public:
				IndirectSymbolMapper(ParsingScopeSymbol* _originalSymbol, ParsingScopeSymbol* _replacedSymbol, ParsingTreeNode* _originalNode, ParsingTreeNode* _replacedNode);
				~IndirectSymbolMapper();

				ParsingTreeNode*					ParentNode(ParsingTreeNode* node)override;
				ParsingTreeNode*					Node(ParsingTreeNode* node)override;
				ParsingScope*						ParentScope(ParsingScopeSymbol* symbol)override;
				ParsingScopeSymbol*					Symbol(ParsingScopeSymbol* symbol)override;
			};
		protected:
			NodeSymbolMap							nodeSymbols;
			Ptr<SymbolMapper>						symbolMapper;
			ParsingScopeFinder*						previousFinder;

			void									InitializeQueryCacheInternal(ParsingScopeSymbol* symbol);
		public:
			ParsingScopeFinder(Ptr<SymbolMapper> _symbolMapper=new DirectSymbolMapper);
			~ParsingScopeFinder();

			ParsingTreeNode*						ParentNode(ParsingTreeNode* node);
			ParsingTreeNode*						ParentNode(Ptr<ParsingTreeNode> node);
			ParsingTreeNode*						Node(ParsingTreeNode* node);
			Ptr<ParsingTreeNode>					Node(Ptr<ParsingTreeNode> node);
			ParsingScope*							ParentScope(ParsingScopeSymbol* symbol);
			ParsingScope*							ParentScope(Ptr<ParsingScopeSymbol> symbol);
			ParsingScopeSymbol*						Symbol(ParsingScopeSymbol* symbol);
			Ptr<ParsingScopeSymbol>					Symbol(Ptr<ParsingScopeSymbol> symbol);
			LazySymbolList							Symbols(const ParsingScope::SymbolList& symbols);

			template<typename T>
			T* Obj(T* node)
			{
				return dynamic_cast<T*>(Node(node));
			}

			template<typename T>
			Ptr<T> Obj(Ptr<T> node)
			{
				return Node(node).Cast<T>();
			}
			
			void									InitializeQueryCache(ParsingScopeSymbol* symbol, ParsingScopeFinder* _previousFinder=0);
			ParsingScopeSymbol*						GetSymbolFromNode(ParsingTreeObject* node);
			ParsingScope*							GetScopeFromNode(ParsingTreeNode* node);
			LazySymbolList							GetSymbols(ParsingScope* scope, const WString& name);
			LazySymbolList							GetSymbols(ParsingScope* scope);
			LazySymbolList							GetSymbolsRecursively(ParsingScope* scope, const WString& name);
			LazySymbolList							GetSymbolsRecursively(ParsingScope* scope);
		};
	}
}

#endif

/***********************************************************************
PARSING\PARSINGTABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Table

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGTABLE
#define VCZH_PARSING_PARSINGTABLE


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
跳转表
***********************************************************************/

			class ParsingTable : public Object
			{
			public:
				static const vint							TokenBegin=0;
				static const vint							TokenFinish=1;
				static const vint							TryReduce=2;
				static const vint							UserTokenStart=3;

				class AttributeInfo : public Object
				{
				public:
					WString									name;
					collections::List<WString>				arguments;

					AttributeInfo(const WString& _name)
						:name(_name)
					{
					}

					AttributeInfo* Argument(const WString& argument)
					{
						arguments.Add(argument);
						return this;
					}
				};

				class AttributeInfoList : public Object
				{
				public:
					collections::List<Ptr<AttributeInfo>>	attributes;

					Ptr<AttributeInfo> FindFirst(const WString& name);
				};

				class TreeTypeInfo
				{
				public:
					WString									type;
					vint									attributeIndex;

					TreeTypeInfo()
						:attributeIndex(-1)
					{
					}

					TreeTypeInfo(const WString& _type, vint _attributeIndex)
						:type(_type)
						,attributeIndex(_attributeIndex)
					{
					}
				};

				class TreeFieldInfo
				{
				public:
					WString									type;
					WString									field;
					vint									attributeIndex;

					TreeFieldInfo()
						:attributeIndex(-1)
					{
					}

					TreeFieldInfo(const WString& _type, const WString& _field, vint _attributeIndex)
						:type(_type)
						,field(_field)
						,attributeIndex(_attributeIndex)
					{
					}
				};

				class TokenInfo
				{
				public:
					WString									name;
					WString									regex;
					vint									regexTokenIndex;
					vint									attributeIndex;

					TokenInfo()
						:regexTokenIndex(-1)
						,attributeIndex(-1)
					{
					}

					TokenInfo(const WString& _name, const WString& _regex, vint _attributeIndex)
						:name(_name)
						,regex(_regex)
						,regexTokenIndex(-1)
						,attributeIndex(_attributeIndex)
					{
					}
				};

				class StateInfo
				{
				public:
					WString									ruleName;
					WString									stateName;
					WString									stateExpression;

					WString									ruleAmbiguousType;		// filled in Initialize()

					StateInfo()
					{
					}

					StateInfo(const WString& _ruleName, const WString& _stateName, const WString& _stateExpression)
						:ruleName(_ruleName)
						,stateName(_stateName)
						,stateExpression(_stateExpression)
					{
					}
				};

				class RuleInfo
				{
				public:
					WString									name;
					WString									type;
					WString									ambiguousType;
					vint									rootStartState;
					vint									attributeIndex;

					RuleInfo()
						:rootStartState(-1)
						,attributeIndex(-1)
					{
					}

					RuleInfo(const WString& _name, const WString& _type, const WString& _ambiguousType, vint _rootStartState, vint _attributeIndex)
						:name(_name)
						,type(_type)
						,ambiguousType(_ambiguousType)
						,rootStartState(_rootStartState)
						,attributeIndex(_attributeIndex)
					{
					}
				};

				class Instruction
				{
				public:
					enum InstructionType
					{
						Create,
						Assign,
						Item,
						Using,
						Setter,
						Shift,
						Reduce,
						LeftRecursiveReduce,
					};

					InstructionType							instructionType;
					vint									stateParameter;
					WString									nameParameter;
					WString									value;
					WString									creatorRule;

					Instruction()
						:instructionType(Create)
						,stateParameter(0)
					{
					}

					Instruction(InstructionType _instructionType, vint _stateParameter, const WString& _nameParameter, const WString& _value, const WString& _creatorRule)
						:instructionType(_instructionType)
						,stateParameter(_stateParameter)
						,nameParameter(_nameParameter)
						,value(_value)
						,creatorRule(_creatorRule)
					{
					}
				};

				class LookAheadInfo
				{
				public:
					collections::List<vint>					tokens;
					vint									state;

					LookAheadInfo()
						:state(-1)
					{
					}

					enum PrefixResult
					{
						Prefix,
						Equal,
						NotPrefix,
					};

					static PrefixResult						TestPrefix(Ptr<LookAheadInfo> a, Ptr<LookAheadInfo> b);
					static void								Walk(Ptr<ParsingTable> table, Ptr<LookAheadInfo> previous, vint state, collections::List<Ptr<LookAheadInfo>>& newInfos);
				};

				class TransitionItem
				{
				public:
					vint									token;
					vint									targetState;
					collections::List<Ptr<LookAheadInfo>>	lookAheads;
					collections::List<vint>					stackPattern;
					collections::List<Instruction>			instructions;

					enum OrderResult
					{
						CorrectOrder,
						WrongOrder,
						SameOrder,
						UnknownOrder,
					};

					TransitionItem(){}

					TransitionItem(vint _token, vint _targetState)
						:token(_token)
						,targetState(_targetState)
					{
					}

					static OrderResult						CheckOrder(Ptr<TransitionItem> t1, Ptr<TransitionItem> t2, bool forceGivingOrder);
					static vint								Compare(Ptr<TransitionItem> t1, Ptr<TransitionItem> t2);
				};

				class TransitionBag
				{
				public:
					collections::List<Ptr<TransitionItem>>	transitionItems;
				};

			protected:
				bool																ambiguity;
				Ptr<regex::RegexLexer>												lexer;
				collections::Array<Ptr<TransitionBag>>								transitionBags;
				vint																tokenCount;
				vint																stateCount;
				collections::Array<Ptr<AttributeInfoList>>							attributeInfos;
				collections::Array<TreeTypeInfo>									treeTypeInfos;
				collections::Array<TreeFieldInfo>									treeFieldInfos;
				collections::Array<TokenInfo>										tokenInfos;
				collections::Array<TokenInfo>										discardTokenInfos;
				collections::Array<StateInfo>										stateInfos;
				collections::Array<RuleInfo>										ruleInfos;
				collections::Dictionary<WString, vint>								ruleMap;
				collections::Dictionary<WString, vint>								treeTypeInfoMap;
				collections::Dictionary<collections::Pair<WString, WString>, vint>	treeFieldInfoMap;

			public:
				ParsingTable(vint _attributeInfoCount, vint _treeTypeInfoCount, vint _treeFieldInfoCount, vint _tokenCount, vint _discardTokenCount, vint _stateCount, vint _ruleCount);
				~ParsingTable();

				bool										GetAmbiguity();
				void										SetAmbiguity(bool value);

				vint										GetAttributeInfoCount();
				Ptr<AttributeInfoList>						GetAttributeInfo(vint index);
				void										SetAttributeInfo(vint index, Ptr<AttributeInfoList> info);

				vint										GetTreeTypeInfoCount();
				const TreeTypeInfo&							GetTreeTypeInfo(vint index);
				const TreeTypeInfo&							GetTreeTypeInfo(const WString& type);
				void										SetTreeTypeInfo(vint index, const TreeTypeInfo& info);

				vint										GetTreeFieldInfoCount();
				const TreeFieldInfo&						GetTreeFieldInfo(vint index);
				const TreeFieldInfo&						GetTreeFieldInfo(const WString& type, const WString& field);
				void										SetTreeFieldInfo(vint index, const TreeFieldInfo& info);

				vint										GetTokenCount();
				const TokenInfo&							GetTokenInfo(vint token);
				void										SetTokenInfo(vint token, const TokenInfo& info);

				vint										GetDiscardTokenCount();
				const TokenInfo&							GetDiscardTokenInfo(vint token);
				void										SetDiscardTokenInfo(vint token, const TokenInfo& info);

				vint										GetStateCount();
				const StateInfo&							GetStateInfo(vint state);
				void										SetStateInfo(vint state, const StateInfo& info);

				vint										GetRuleCount();
				const RuleInfo&								GetRuleInfo(const WString& ruleName);
				const RuleInfo&								GetRuleInfo(vint rule);
				void										SetRuleInfo(vint rule, const RuleInfo& info);

				const regex::RegexLexer&					GetLexer();
				Ptr<TransitionBag>							GetTransitionBag(vint state, vint token);
				void										SetTransitionBag(vint state, vint token, Ptr<TransitionBag> bag);
				void										Initialize();
				bool										IsInputToken(vint regexTokenIndex);
				vint										GetTableTokenIndex(vint regexTokenIndex);
				vint										GetTableDiscardTokenIndex(vint regexTokenIndex);
			};

/***********************************************************************
辅助函数
***********************************************************************/

			extern void										Log(Ptr<ParsingTable> table, stream::TextWriter& writer);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGSTATE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::State

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGSTATE
#define VCZH_PARSING_PARSINGSTATE


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
语法分析器
***********************************************************************/
			
			class ParsingTokenWalker : public Object, protected collections::IEnumerable<vint>
			{
			protected:
				collections::List<regex::RegexToken>&	tokens;
				Ptr<ParsingTable>						table;
				vint									currentToken;

				vint									GetNextIndex(vint index)const;
				vint									GetTableTokenIndex(vint index)const;
				collections::IEnumerator<vint>*			CreateEnumerator()const override;
			protected:
				class LookAheadEnumerator : public Object, public collections::IEnumerator<vint>
				{
				protected:
					const ParsingTokenWalker*			walker;
					vint								firstToken;
					vint								currentToken;
					vint								currentValue;
					vint								index;

				public:
					LookAheadEnumerator(const ParsingTokenWalker* _walker, vint _currentToken);
					LookAheadEnumerator(const LookAheadEnumerator& _enumerator);

					IEnumerator<vint>*					Clone()const override;
					const vint&							Current()const override;
					vint								Index()const override;
					bool								Next()override;
					void								Reset()override;
				};
			public:
				ParsingTokenWalker(collections::List<regex::RegexToken>& _tokens, Ptr<ParsingTable> _table);
				~ParsingTokenWalker();

				const collections::IEnumerable<vint>&	GetLookahead()const;
				void									Reset();
				bool									Move();
				vint									GetTableTokenIndex()const;
				regex::RegexToken*						GetRegexToken()const;
				vint									GetTokenIndexInStream()const;
			};

			class ParsingState : public Object
			{
			public:
				struct ShiftReduceRange
				{
					regex::RegexToken*							shiftToken;
					regex::RegexToken*							reduceToken;

					ShiftReduceRange()
						:shiftToken(0)
						,reduceToken(0)
					{
					}
				};

				struct TransitionResult
				{
					enum TransitionType
					{
						ExecuteInstructions,
						AmbiguityBegin,
						AmbiguityBranch,
						AmbiguityEnd,
						SkipToken,
					};

					TransitionType								transitionType;
					vint										ambiguityAffectedStackNodeCount;
					WString										ambiguityNodeType;

					vint										tableTokenIndex;
					vint										tableStateSource;
					vint										tableStateTarget;
					vint										tokenIndexInStream;
					regex::RegexToken*							token;

					ParsingTable::TransitionItem*				transition;
					vint										instructionBegin;
					vint										instructionCount;
					Ptr<collections::List<ShiftReduceRange>>	shiftReduceRanges;

					TransitionResult(TransitionType _transitionType=ExecuteInstructions)
						:transitionType(_transitionType)
						,ambiguityAffectedStackNodeCount(0)
						,tableTokenIndex(-1)
						,tableStateSource(-1)
						,tableStateTarget(-1)
						,tokenIndexInStream(-1)
						,token(0)
						,transition(0)
						,instructionBegin(-1)
						,instructionCount(-1)
					{
					}

					operator bool()const
					{
						return transitionType!=ExecuteInstructions || transition!=0;
					}

					void AddShiftReduceRange(regex::RegexToken* shiftToken, regex::RegexToken* reduceToken)
					{
						ShiftReduceRange range;
						range.shiftToken=shiftToken;
						range.reduceToken=reduceToken;
						if(!shiftReduceRanges)
						{
							shiftReduceRanges=new collections::List<ShiftReduceRange>();
						}
						shiftReduceRanges->Add(range);
					}
				};

				struct Future
				{
					vint									currentState;
					vint									reduceStateCount;
					collections::List<vint>					shiftStates;
					vint									selectedToken;
					ParsingTable::TransitionItem*			selectedItem;
					Future*									previous;
					Future*									next;

					Future()
						:currentState(-1)
						,reduceStateCount(0)
						,selectedToken(-1)
						,selectedItem(0)
						,previous(0)
						,next(0)
					{
					}

					Future* Clone()
					{
						Future* future=new Future;
						future->currentState=currentState;
						future->reduceStateCount=reduceStateCount;
						CopyFrom(future->shiftStates, shiftStates);
						future->selectedToken=selectedToken;
						future->selectedItem=selectedItem;
						future->previous=previous;
						return future;
					}
				};

				struct StateGroup
				{
					collections::List<vint>						stateStack;
					vint										currentState;
					vint										tokenSequenceIndex;

					collections::List<regex::RegexToken*>		shiftTokenStack;
					regex::RegexToken*							shiftToken;
					regex::RegexToken*							reduceToken;

					StateGroup();
					StateGroup(const ParsingTable::RuleInfo& info);
					StateGroup(const StateGroup& group);
				};
			private:
				WString										input;
				Ptr<ParsingTable>							table;
				collections::List<regex::RegexToken>		tokens;
				Ptr<ParsingTokenWalker>						walker;
				
				WString										parsingRule;
				vint										parsingRuleStartState;
				Ptr<StateGroup>								stateGroup;
			public:
				ParsingState(const WString& _input, Ptr<ParsingTable> _table, vint codeIndex=-1);
				~ParsingState();

				const WString&								GetInput();
				Ptr<ParsingTable>							GetTable();
				const collections::List<regex::RegexToken>&	GetTokens();
				regex::RegexToken*							GetToken(vint index);

				vint										Reset(const WString& rule);
				WString										GetParsingRule();
				vint										GetParsingRuleStartState();
				vint										GetCurrentToken();
				vint										GetCurrentTableTokenIndex();
				const collections::List<vint>&				GetStateStack();
				vint										GetCurrentState();
				void										SkipCurrentToken();

				bool										TestTransitionItemInFuture(vint tableTokenIndex, Future* future, ParsingTable::TransitionItem* item, const collections::IEnumerable<vint>* lookAheadTokens);
				ParsingTable::TransitionItem*				MatchTokenInFuture(vint tableTokenIndex, Future* future, const collections::IEnumerable<vint>* lookAheadTokens);
				ParsingTable::TransitionItem*				MatchToken(vint tableTokenIndex, const collections::IEnumerable<vint>* lookAheadTokens);
				void										RunTransitionInFuture(ParsingTable::TransitionItem* transition, Future* previous, Future* now);
				ParsingState::TransitionResult				RunTransition(ParsingTable::TransitionItem* transition, regex::RegexToken* regexToken, vint instructionBegin, vint instructionCount, bool lastPart);
				ParsingState::TransitionResult				RunTransition(ParsingTable::TransitionItem* transition, regex::RegexToken* regexToken);

				bool										ReadTokenInFuture(vint tableTokenIndex, Future* previous, Future* now, const collections::IEnumerable<vint>* lookAheadTokens);
				TransitionResult							ReadToken(vint tableTokenIndex, regex::RegexToken* regexToken, const collections::IEnumerable<vint>* lookAheadTokens);
				TransitionResult							ReadToken();

				bool										TestExplore(vint tableTokenIndex, Future* previous);
				void										Explore(vint tableTokenIndex, Future* previous, collections::List<Future*>& possibilities);
				regex::RegexToken*							ExploreStep(collections::List<Future*>& previousFutures, vint start, vint count, collections::List<Future*>& possibilities);
				void										ExploreTryReduce(collections::List<Future*>& previousFutures, vint start, vint count, collections::List<Future*>& possibilities);
				Future*										ExploreCreateRootFuture();

				Ptr<StateGroup>								TakeSnapshot();
				void										RestoreSnapshot(Ptr<StateGroup> group);
			};

/***********************************************************************
语法树生成器
***********************************************************************/

			class ParsingTransitionProcessor : public Object
			{
			public:
				virtual void								Reset()=0;
				virtual bool								Run(const ParsingState::TransitionResult& result)=0;
				virtual bool								GetProcessingAmbiguityBranch()=0;
			};

			class ParsingTreeBuilder : public ParsingTransitionProcessor
			{
			protected:
				Ptr<ParsingTreeNode>						createdObject;
				Ptr<ParsingTreeObject>						operationTarget;
				collections::List<Ptr<ParsingTreeObject>>	nodeStack;

				bool										processingAmbiguityBranch;
				Ptr<ParsingTreeNode>						ambiguityBranchCreatedObject;
				Ptr<ParsingTreeNode>						ambiguityBranchOperationTarget;
				vint										ambiguityBranchSharedNodeCount;
				collections::List<Ptr<ParsingTreeObject>>	ambiguityBranchNodeStack;
				collections::List<Ptr<ParsingTreeObject>>	ambiguityNodes;
			public:
				ParsingTreeBuilder();
				~ParsingTreeBuilder();

				void										Reset()override;
				bool										Run(const ParsingState::TransitionResult& result)override;
				bool										GetProcessingAmbiguityBranch()override;
				Ptr<ParsingTreeObject>						GetNode()const;
			};

			class ParsingTransitionCollector : public ParsingTransitionProcessor
			{
				typedef collections::List<ParsingState::TransitionResult>		TransitionResultList;
			protected:
				vint										ambiguityBegin;
				TransitionResultList						transitions;

				collections::Dictionary<vint, vint>			ambiguityBeginToEnds;
				collections::Group<vint, vint>				ambiguityBeginToBranches;
				collections::Dictionary<vint, vint>			ambiguityBranchToBegins;
			public:
				ParsingTransitionCollector();
				~ParsingTransitionCollector();

				void										Reset()override;
				bool										Run(const ParsingState::TransitionResult& result)override;
				bool										GetProcessingAmbiguityBranch()override;

				const TransitionResultList&					GetTransitions()const;
				vint										GetAmbiguityEndFromBegin(vint transitionIndex)const;
				const collections::List<vint>&				GetAmbiguityBranchesFromBegin(vint transitionIndex)const;
				vint										GetAmbiguityBeginFromBranch(vint transitionIndex)const;
			};
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORPREDEFINED.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

XML Representation for Code Generation:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORPREDEFINED
#define VCZH_REFLECTION_GUITYPEDESCRIPTORPREDEFINED


namespace vl
{
	namespace reflection
	{
		namespace description
		{

/***********************************************************************
TypeInfo
***********************************************************************/

			template<typename T>
			struct TypeInfo
			{
			};

			template<typename T>
			ITypedValueSerializer<T>* GetValueSerializer()
			{
				return dynamic_cast<ITypedValueSerializer<T>*>(GetValueSerializer(TypeInfo<T>::TypeName));
			}

			template<typename T>
			ITypeDescriptor* GetTypeDescriptor()
			{
				return GetTypeDescriptor(TypeInfo<T>::TypeName);
			}

/***********************************************************************
GeneralValueSeriaizer
***********************************************************************/

			template<typename T>
			class GeneralValueSeriaizer : public Object, public ITypedValueSerializer<T>
			{
			protected:
				ITypeDescriptor*							ownedTypeDescriptor;

				virtual bool								Serialize(const T& input, WString& output)=0;
				virtual bool								Deserialize(const WString& input, T& output)=0;
			public:
				typedef T ValueType;

				GeneralValueSeriaizer(ITypeDescriptor* _ownedTypeDescriptor)
					:ownedTypeDescriptor(_ownedTypeDescriptor)
				{
				}

				ITypeDescriptor* GetOwnerTypeDescriptor()
				{
					return ownedTypeDescriptor;
				}

				bool Validate(const WString& text)
				{
					T output;
					return Deserialize(text, output);
				}

				bool Parse(const WString& input, Value& output)
				{
					if(Validate(input))
					{
						output=Value::From(input, ownedTypeDescriptor);
						return true;
					}
					return false;
				}

				bool HasCandidate()override
				{
					return false;
				}

				vint GetCandidateCount()override
				{
					return 0;
				}

				WString GetCandidate(vint index)override
				{
					return L"";
				}

				bool CanMergeCandidate()override
				{
					return false;
				}

				bool Serialize(const T& input, Value& output)
				{
					WString text;
					if(Serialize(input, text))
					{
						output=Value::From(text, ownedTypeDescriptor);
						return true;
					}
					return false;
				}

				bool Deserialize(const Value& input, T& output)
				{
					if(input.GetValueType()!=Value::Text)
					{
						return false;
					}
					return Deserialize(input.GetText(), output);
				}
			};

/***********************************************************************
TypedValueSerializer
***********************************************************************/

			template<typename T>
			struct TypedValueSerializerProvider
			{
			};

			template<typename T>
			class TypedValueSerializer : public GeneralValueSeriaizer<T>
			{
			protected:
				bool Serialize(const T& input, WString& output)override
				{
					return TypedValueSerializerProvider<T>::Serialize(input, output);
				}

				bool Deserialize(const WString& input, T& output)override
				{
					return TypedValueSerializerProvider<T>::Deserialize(input, output);
				}
			public:
				TypedValueSerializer(ITypeDescriptor* _ownedTypeDescriptor)
					:GeneralValueSeriaizer(_ownedTypeDescriptor)
				{
				}
			};

/***********************************************************************
EnumValueSeriaizer
***********************************************************************/

			template<typename T, bool CanMerge>
			struct EnumValueSerializerProvider
			{
			};

			template<typename T>
			struct EnumValueSerializerProvider<T, true>
			{
				static bool Serialize(collections::Dictionary<WString, T>& candidates, const T& input, WString& output)
				{
					WString result;
					for(vint i=0;i<candidates.Count();i++)
					{
						if(candidates.Values().Get(i)&input)
						{
							if(result!=L"") result+=L"|";
							result+=candidates.Keys()[i];
						}
					}
					output=result;
					return true;
				}

				static bool Deserialize(collections::Dictionary<WString, T>& candidates, const WString& input, T& output)
				{
					T result=(T)0;
					const wchar_t* reading=input.Buffer();
					while(*reading)
					{
						const wchar_t* sep=wcschr(reading, L'|');
						if(!sep) sep=reading+wcslen(reading);
						WString item(reading, sep-reading);
						reading=*sep?sep+1:sep;

						vint index=candidates.Keys().IndexOf(item);
						if(index==-1) return false;
						result=(T)(result|candidates.Values().Get(index));
					}
					output=result;
					return true;
				}
			};

			template<typename T>
			struct EnumValueSerializerProvider<T, false>
			{
				static bool Serialize(collections::Dictionary<WString, T>& candidates, const T& input, WString& output)
				{
					for(vint i=0;i<candidates.Count();i++)
					{
						if(candidates.Values().Get(i)==input)
						{
							output=candidates.Keys()[i];
							return true;
						}
					}
					return false;
				}

				static bool Deserialize(collections::Dictionary<WString, T>& candidates, const WString& input, T& output)
				{
					vint index=candidates.Keys().IndexOf(input);
					if(index==-1) return false;
					output=candidates.Values().Get(index);
					return true;
				}
			};

			template<typename T, bool CanMerge>
			class EnumValueSeriaizer : public GeneralValueSeriaizer<T>
			{
			protected:
				collections::Dictionary<WString, T>			candidates;

				bool Serialize(const T& input, WString& output)override
				{
					return EnumValueSerializerProvider<T, CanMerge>::Serialize(candidates, input, output);
				}

				bool Deserialize(const WString& input, T& output)override
				{
					return EnumValueSerializerProvider<T, CanMerge>::Deserialize(candidates, input, output);
				}
			public:
				EnumValueSeriaizer(ITypeDescriptor* _ownedTypeDescriptor)
					:GeneralValueSeriaizer(_ownedTypeDescriptor)
				{
				}

				bool HasCandidate()override
				{
					return true;
				}

				vint GetCandidateCount()override
				{
					return candidates.Count();
				}

				WString GetCandidate(vint index)override
				{
					return candidates.Keys()[index];
				}

				bool CanMergeCandidate()override
				{
					return CanMerge;
				}
			};

/***********************************************************************
SerializableTypeDescriptor
***********************************************************************/

			class SerializableTypeDescriptorBase : public Object, public ITypeDescriptor
			{
			protected:
				Ptr<IValueSerializer>						serializer;
				WString										typeName;
			public:
				SerializableTypeDescriptorBase(const WString& _typeName, Ptr<IValueSerializer> _serializer);
				~SerializableTypeDescriptorBase();

				const WString&								GetTypeName()override;
				IValueSerializer*							GetValueSerializer()override;
				vint										GetBaseTypeDescriptorCount()override;
				ITypeDescriptor*							GetBaseTypeDescriptor(vint index)override;
				bool										CanConvertTo(ITypeDescriptor* targetType)override;
				vint										GetPropertyCount()override;
				IPropertyInfo*								GetProperty(vint index)override;
				bool										IsPropertyExists(const WString& name, bool inheritable)override;
				IPropertyInfo*								GetPropertyByName(const WString& name, bool inheritable)override;
				vint										GetEventCount()override;
				IEventInfo*									GetEvent(vint index)override;
				bool										IsEventExists(const WString& name, bool inheritable)override;
				IEventInfo*									GetEventByName(const WString& name, bool inheritable)override;
				vint										GetMethodGroupCount()override;
				IMethodGroupInfo*							GetMethodGroup(vint index)override;
				bool										IsMethodGroupExists(const WString& name, bool inheritable)override;
				IMethodGroupInfo*							GetMethodGroupByName(const WString& name, bool inheritable)override;
				IMethodGroupInfo*							GetConstructorGroup()override;
			};

			template<typename TSerializer>
			class SerializableTypeDescriptor : public SerializableTypeDescriptorBase
			{
			public:
				SerializableTypeDescriptor()
					:SerializableTypeDescriptorBase(TypeInfo<typename TSerializer::ValueType>::TypeName, 0)
				{
					serializer=new TSerializer(this);
				}
			};

/***********************************************************************
Predefined Types
***********************************************************************/

			struct VoidValue{};
			
			template<>struct TypeInfo<void>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<VoidValue>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IDescriptable>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<Value>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<unsigned __int8>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<unsigned __int16>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<unsigned __int32>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<unsigned __int64>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<signed __int8>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<signed __int16>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<signed __int32>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<signed __int64>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<float>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<double>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<bool>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<wchar_t>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<WString>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<DateTime>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<Locale>{static const wchar_t* TypeName;};

			template<>struct TypeInfo<IValueEnumerator>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueEnumerable>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueReadonlyList>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueList>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueReadonlyDictionary>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueDictionary>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueInterfaceProxy>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IValueFunctionProxy>{static const wchar_t* TypeName;};

			template<>struct TypeInfo<IValueSerializer>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<ITypeInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<ITypeInfo::Decorator>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IMemberInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IEventHandler>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IEventInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IPropertyInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IParameterInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IMethodInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<IMethodGroupInfo>{static const wchar_t* TypeName;};
			template<>struct TypeInfo<ITypeDescriptor>{static const wchar_t* TypeName;};

			template<>
			struct TypedValueSerializerProvider<unsigned __int8>
			{
				static bool Serialize(const unsigned __int8& input, WString& output);
				static bool Deserialize(const WString& input, unsigned __int8& output);
			};

			template<>
			struct TypedValueSerializerProvider<unsigned __int16>
			{
				static bool Serialize(const unsigned __int16& input, WString& output);
				static bool Deserialize(const WString& input, unsigned __int16& output);
			};

			template<>
			struct TypedValueSerializerProvider<unsigned __int32>
			{
				static bool Serialize(const unsigned __int32& input, WString& output);
				static bool Deserialize(const WString& input, unsigned __int32& output);
			};

			template<>
			struct TypedValueSerializerProvider<unsigned __int64>
			{
				static bool Serialize(const unsigned __int64& input, WString& output);
				static bool Deserialize(const WString& input, unsigned __int64& output);
			};

			template<>
			struct TypedValueSerializerProvider<signed __int8>
			{
				static bool Serialize(const signed __int8& input, WString& output);
				static bool Deserialize(const WString& input, signed __int8& output);
			};

			template<>
			struct TypedValueSerializerProvider<signed __int16>
			{
				static bool Serialize(const signed __int16& input, WString& output);
				static bool Deserialize(const WString& input, signed __int16& output);
			};

			template<>
			struct TypedValueSerializerProvider<signed __int32>
			{
				static bool Serialize(const signed __int32& input, WString& output);
				static bool Deserialize(const WString& input, signed __int32& output);
			};

			template<>
			struct TypedValueSerializerProvider<signed __int64>
			{
				static bool Serialize(const signed __int64& input, WString& output);
				static bool Deserialize(const WString& input, signed __int64& output);
			};

			template<>
			struct TypedValueSerializerProvider<float>
			{
				static bool Serialize(const float& input, WString& output);
				static bool Deserialize(const WString& input, float& output);
			};

			template<>
			struct TypedValueSerializerProvider<double>
			{
				static bool Serialize(const double& input, WString& output);
				static bool Deserialize(const WString& input, double& output);
			};

			template<>
			struct TypedValueSerializerProvider<wchar_t>
			{
				static bool Serialize(const wchar_t& input, WString& output);
				static bool Deserialize(const WString& input, wchar_t& output);
			};

			template<>
			struct TypedValueSerializerProvider<WString>
			{
				static bool Serialize(const WString& input, WString& output);
				static bool Deserialize(const WString& input, WString& output);
			};

/***********************************************************************
LoadPredefinedTypes
***********************************************************************/

			extern bool										LoadPredefinedTypes();
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORBUILDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

Classes:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER


namespace vl
{
	namespace reflection
	{
		namespace description
		{

/***********************************************************************
TypeInfoImp;
***********************************************************************/

			class TypeInfoImpl : public Object, public ITypeInfo
			{
			protected:
				Decorator								decorator;
				ITypeDescriptor*						typeDescriptor;
				collections::List<Ptr<ITypeInfo>>		genericArguments;
				Ptr<ITypeInfo>							elementType;
			public:
				TypeInfoImpl(Decorator _decorator);
				~TypeInfoImpl();

				Decorator								GetDecorator()override;
				ITypeInfo*								GetElementType()override;
				ITypeDescriptor*						GetTypeDescriptor()override;
				vint									GetGenericArgumentCount()override;
				ITypeInfo*								GetGenericArgument(vint index)override;
				WString									GetTypeFriendlyName()override;

				void									SetTypeDescriptor(ITypeDescriptor* value);
				void									AddGenericArgument(Ptr<ITypeInfo> value);
				void									SetElementType(Ptr<ITypeInfo> value);
			};

/***********************************************************************
ParameterInfoImpl
***********************************************************************/

			class ParameterInfoImpl : public Object, public IParameterInfo
			{
			protected:
				IMethodInfo*							ownerMethod;
				WString									name;
				Ptr<ITypeInfo>							type;
			public:
				ParameterInfoImpl(IMethodInfo* _ownerMethod, const WString& _name, Ptr<ITypeInfo> _type);
				~ParameterInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				const WString&							GetName()override;
				ITypeInfo*								GetType()override;
				IMethodInfo*							GetOwnerMethod()override;
			};

/***********************************************************************
MethodInfoImpl
***********************************************************************/

			class MethodInfoImpl : public Object, public IMethodInfo
			{
				friend class PropertyInfoImpl;
			protected:
				IMethodGroupInfo*						ownerMethodGroup;
				IPropertyInfo*							ownerProperty;
				collections::List<Ptr<IParameterInfo>>	parameters;
				Ptr<ITypeInfo>							returnInfo;
				bool									isStatic;

				virtual Value							InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)=0;
			public:
				MethodInfoImpl(IMethodGroupInfo* _ownerMethodGroup, Ptr<ITypeInfo> _return, bool _isStatic);
				~MethodInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				IPropertyInfo*							GetOwnerProperty()override;
				const WString&							GetName()override;
				IMethodGroupInfo*						GetOwnerMethodGroup()override;
				vint									GetParameterCount()override;
				IParameterInfo*							GetParameter(vint index)override;
				ITypeInfo*								GetReturn()override;
				bool									IsStatic()override;
				void									CheckArguments(collections::Array<Value>& arguments)override;
				Value									Invoke(const Value& thisObject, collections::Array<Value>& arguments)override;
				bool									AddParameter(Ptr<IParameterInfo> parameter);
				bool									SetOwnerMethodgroup(IMethodGroupInfo* _ownerMethodGroup);
			};

/***********************************************************************
MethodGroupInfoImpl
***********************************************************************/

			class MethodGroupInfoImpl : public Object, public IMethodGroupInfo
			{
			protected:
				ITypeDescriptor*						ownerTypeDescriptor;
				WString									name;
				collections::List<Ptr<IMethodInfo>>		methods;
			public:
				MethodGroupInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name);
				~MethodGroupInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				const WString&							GetName()override;
				vint									GetMethodCount()override;
				IMethodInfo*							GetMethod(vint index)override;
				bool									AddMethod(Ptr<IMethodInfo> _method);
			};

/***********************************************************************
EventInfoImpl
***********************************************************************/

			class EventInfoImpl : public Object, public IEventInfo
			{
				friend class PropertyInfoImpl;
			protected:
				typedef collections::List<Ptr<IEventHandler>>		EventHandlerList;
				static const wchar_t*								EventHandlerListInternalPropertyName;

				class EventHandlerImpl : public Object, public IEventHandler
				{
				protected:
					EventInfoImpl*						ownerEvent;
					DescriptableObject*					ownerObject;
					Ptr<IValueFunctionProxy>			handler;
					Ptr<DescriptableObject>				tag;
					bool								attached;
				public:
					EventHandlerImpl(EventInfoImpl* _ownerEvent, DescriptableObject* _ownerObject, Ptr<IValueFunctionProxy> _handler);
					~EventHandlerImpl();

					IEventInfo*							GetOwnerEvent()override;
					Value								GetOwnerObject()override;
					bool								IsAttached()override;
					bool								Detach()override;
					void								Invoke(const Value& thisObject, Value& arguments)override;

					Ptr<DescriptableObject>				GetTag();
					void								SetTag(Ptr<DescriptableObject> _tag);
				};

			protected:
				ITypeDescriptor*						ownerTypeDescriptor;
				collections::List<IPropertyInfo*>		observingProperties;
				WString									name;
				Ptr<ITypeInfo>							handlerType;

				virtual void							AttachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)=0;
				virtual void							DetachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)=0;
				virtual void							InvokeInternal(DescriptableObject* thisObject, Value& eventHandler)=0;
				virtual Ptr<ITypeInfo>					GetHandlerTypeInternal()=0;

				void									AddEventHandler(DescriptableObject* thisObject, Ptr<IEventHandler> eventHandler);
				void									RemoveEventHandler(DescriptableObject* thisObject, IEventHandler* eventHandler);
			public:
				EventInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name);
				~EventInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				const WString&							GetName()override;
				ITypeInfo*								GetHandlerType()override;
				vint									GetObservingPropertyCount()override;
				IPropertyInfo*							GetObservingProperty(vint index)override;
				Ptr<IEventHandler>						Attach(const Value& thisObject, Ptr<IValueFunctionProxy> handler)override;
				void									Invoke(const Value& thisObject, Value& arguments)override;
			};

/***********************************************************************
TypeDescriptorImpl
***********************************************************************/

			class PropertyInfoImpl : public Object, public IPropertyInfo
			{
			protected:
				ITypeDescriptor*						ownerTypeDescriptor;
				WString									name;
				MethodInfoImpl*							getter;
				MethodInfoImpl*							setter;
				EventInfoImpl*							valueChangedEvent;
			public:
				PropertyInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name, MethodInfoImpl* _getter, MethodInfoImpl* _setter, EventInfoImpl* _valueChangedEvent);
				~PropertyInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				const WString&							GetName()override;
				bool									IsReadable()override;
				bool									IsWritable()override;
				ITypeInfo*								GetReturn()override;
				IMethodInfo*							GetGetter()override;
				IMethodInfo*							GetSetter()override;
				IEventInfo*								GetValueChangedEvent()override;
				Value									GetValue(const Value& thisObject)override;
				void									SetValue(Value& thisObject, const Value& newValue)override;
			};

/***********************************************************************
FieldInfoImpl
***********************************************************************/

			class FieldInfoImpl : public Object, public IPropertyInfo
			{
			protected:
				ITypeDescriptor*						ownerTypeDescriptor;
				Ptr<ITypeInfo>							returnInfo;
				WString									name;

				virtual Value							GetValueInternal(const Value& thisObject)=0;
				virtual void							SetValueInternal(Value& thisObject, const Value& newValue)=0;
			public:
				FieldInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name, Ptr<ITypeInfo> _returnInfo);
				~FieldInfoImpl();

				ITypeDescriptor*						GetOwnerTypeDescriptor()override;
				const WString&							GetName()override;
				bool									IsReadable()override;
				bool									IsWritable()override;
				ITypeInfo*								GetReturn()override;
				IMethodInfo*							GetGetter()override;
				IMethodInfo*							GetSetter()override;
				IEventInfo*								GetValueChangedEvent()override;
				Value									GetValue(const Value& thisObject)override;
				void									SetValue(Value& thisObject, const Value& newValue)override;
			};

/***********************************************************************
TypeDescriptorImpl
***********************************************************************/

			class TypeDescriptorImpl : public Object, public ITypeDescriptor
			{
			private:
				bool														loaded;
				WString														typeName;
				Ptr<IValueSerializer>										valueSerializer;
				collections::List<ITypeDescriptor*>							baseTypeDescriptors;
				collections::Dictionary<WString, Ptr<IPropertyInfo>>		properties;
				collections::Dictionary<WString, Ptr<IEventInfo>>			events;
				collections::Dictionary<WString, Ptr<MethodGroupInfoImpl>>	methodGroups;
				Ptr<MethodGroupInfoImpl>									constructorGroup;

			protected:
				MethodGroupInfoImpl*		PrepareMethodGroup(const WString& name);
				MethodGroupInfoImpl*		PrepareConstructorGroup();
				IPropertyInfo*				AddProperty(Ptr<IPropertyInfo> value);
				IEventInfo*					AddEvent(Ptr<IEventInfo> value);
				IMethodInfo*				AddMethod(const WString& name, Ptr<MethodInfoImpl> value);
				IMethodInfo*				AddConstructor(Ptr<MethodInfoImpl> value);
				void						AddBaseType(ITypeDescriptor* value);

				virtual void				LoadInternal()=0;
				void						Load();
			public:
				TypeDescriptorImpl(const WString& _typeName);
				~TypeDescriptorImpl();

				const WString&				GetTypeName()override;
				IValueSerializer*			GetValueSerializer()override;
				vint						GetBaseTypeDescriptorCount()override;
				ITypeDescriptor*			GetBaseTypeDescriptor(vint index)override;
				bool						CanConvertTo(ITypeDescriptor* targetType)override;

				vint						GetPropertyCount()override;
				IPropertyInfo*				GetProperty(vint index)override;
				bool						IsPropertyExists(const WString& name, bool inheritable)override;
				IPropertyInfo*				GetPropertyByName(const WString& name, bool inheritable)override;

				vint						GetEventCount()override;
				IEventInfo*					GetEvent(vint index)override;
				bool						IsEventExists(const WString& name, bool inheritable)override;
				IEventInfo*					GetEventByName(const WString& name, bool inheritable)override;

				vint						GetMethodGroupCount()override;
				IMethodGroupInfo*			GetMethodGroup(vint index)override;
				bool						IsMethodGroupExists(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetMethodGroupByName(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetConstructorGroup()override;
			};

/***********************************************************************
TypeFlagTester
***********************************************************************/

			enum class TypeFlags
			{
				NonGenericType			=0,
				FunctionType			=1<<0,
				EnumerableType			=1<<1,
				ReadonlyListType		=1<<2,
				ListType				=1<<3,
				ReadonlyDictionaryType	=1<<4,
				DictionaryType			=1<<5,
			};

			template<typename T>
			struct ValueRetriver
			{
				T* pointer;
			};

			template<typename T>
			struct ValueRetriver<T&>
			{
				T* pointer;
			};

			template<typename TDerived, TypeFlags Flag>
			struct TypeFlagTester
			{
				static const TypeFlags									Result=TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::FunctionType>
			{
				template<typename T>
				static void* Inherit(Func<T>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::FunctionType:TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::EnumerableType>
			{
				template<typename T>
				static void* Inherit(const collections::LazyList<T>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::EnumerableType:TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::ReadonlyListType>
			{
				template<typename T>
				static void* Inherit(const collections::IEnumerable<T>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::ReadonlyListType:TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::ListType>
			{
				template<typename T>
				static void* Inherit(collections::IEnumerable<T>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::ListType:TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::ReadonlyDictionaryType>
			{
				template<typename K, typename V>
				static void* Inherit(const collections::Dictionary<K, V>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::ReadonlyDictionaryType:TypeFlags::NonGenericType;
			};

			template<typename TDerived>
			struct TypeFlagTester<TDerived, TypeFlags::DictionaryType>
			{
				template<typename K, typename V>
				static void* Inherit(collections::Dictionary<K, V>* source){}
				static char Inherit(void* source){}
				static char Inherit(const void* source){}

				static const TypeFlags									Result=sizeof(Inherit(((ValueRetriver<TDerived>*)0)->pointer))==sizeof(void*)?TypeFlags::DictionaryType:TypeFlags::NonGenericType;
			};

/***********************************************************************
TypeFlagSelector
***********************************************************************/

			template<typename T, TypeFlags Flag>
			struct TypeFlagSelectorCase
			{
				static const  TypeFlags									Result=TypeFlags::NonGenericType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::FunctionType)>
			{
				static const  TypeFlags									Result=TypeFlags::FunctionType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::EnumerableType|(vint)TypeFlags::ReadonlyListType)>
			{
				static const  TypeFlags									Result=TypeFlags::EnumerableType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::EnumerableType|(vint)TypeFlags::ListType|(vint)TypeFlags::ReadonlyListType)>
			{
				static const  TypeFlags									Result=TypeFlags::EnumerableType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::ListType|(vint)TypeFlags::ReadonlyListType)>
			{
				static const  TypeFlags									Result=TypeFlags::ListType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::ReadonlyListType)>
			{
				static const  TypeFlags									Result=TypeFlags::ReadonlyListType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::ListType|(vint)TypeFlags::ReadonlyListType|(vint)TypeFlags::DictionaryType|(vint)TypeFlags::ReadonlyDictionaryType)>
			{
				static const  TypeFlags									Result=TypeFlags::DictionaryType;
			};

			template<typename T>
			struct TypeFlagSelectorCase<T, (TypeFlags)((vint)TypeFlags::ReadonlyListType|(vint)TypeFlags::ReadonlyDictionaryType)>
			{
				static const  TypeFlags									Result=TypeFlags::ReadonlyDictionaryType;
			};

			template<typename T>
			struct TypeFlagSelector
			{
				static const TypeFlags									Result =
					TypeFlagSelectorCase<
					T, 
					(TypeFlags)
					( (vint)TypeFlagTester<T, TypeFlags::FunctionType>::Result
					| (vint)TypeFlagTester<T, TypeFlags::EnumerableType>::Result
					| (vint)TypeFlagTester<T, TypeFlags::ReadonlyListType>::Result
					| (vint)TypeFlagTester<T, TypeFlags::ListType>::Result
					| (vint)TypeFlagTester<T, TypeFlags::ReadonlyDictionaryType>::Result
					| (vint)TypeFlagTester<T, TypeFlags::DictionaryType>::Result
					)
					>::Result;
			};

/***********************************************************************
TypeInfoRetriver
***********************************************************************/

			template<typename T, TypeFlags Flag>
			struct DetailTypeInfoRetriver
			{
				static const ITypeInfo::Decorator						Decorator=ITypeInfo::TypeDescriptor;
				typedef void											Type;
				typedef void											TempValueType;
				typedef void											ResultReferenceType;
				typedef void											ResultNonReferenceType;
			};

			template<typename T>
			struct TypeInfoRetriver
			{
				static const TypeFlags															TypeFlag=TypeFlagSelector<T>::Result;
				static const ITypeInfo::Decorator												Decorator=DetailTypeInfoRetriver<T, TypeFlag>::Decorator;

				typedef typename DetailTypeInfoRetriver<T, TypeFlag>::Type						Type;
				typedef typename DetailTypeInfoRetriver<T, TypeFlag>::TempValueType				TempValueType;
				typedef typename DetailTypeInfoRetriver<T, TypeFlag>::ResultReferenceType		ResultReferenceType;
				typedef typename DetailTypeInfoRetriver<T, TypeFlag>::ResultNonReferenceType	ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					return DetailTypeInfoRetriver<T, TypeFlag>::CreateTypeInfo();
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>
			{
				static const ITypeInfo::Decorator						Decorator=ITypeInfo::TypeDescriptor;
				typedef T												Type;
				typedef T												TempValueType;
				typedef T&												ResultReferenceType;
				typedef T												ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					type->SetTypeDescriptor(GetTypeDescriptor<Type>());
					return type;
				}
			};

			template<>
			struct TypeInfoRetriver<void> : public TypeInfoRetriver<VoidValue>
			{
			};

			template<typename T>
			struct DetailTypeInfoRetriver<const T, TypeFlags::NonGenericType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef typename UpLevelRetriver::Type							Type;
				typedef T														TempValueType;
				typedef const T&												ResultReferenceType;
				typedef const T													ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					return TypeInfoRetriver<T>::CreateTypeInfo();
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<volatile T, TypeFlags::NonGenericType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef typename UpLevelRetriver::Type							Type;
				typedef T														TempValueType;
				typedef T&														ResultReferenceType;
				typedef T														ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					return TypeInfoRetriver<T>::CreateTypeInfo();
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T*, TypeFlags::NonGenericType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=ITypeInfo::RawPtr;
				typedef typename UpLevelRetriver::Type							Type;
				typedef T*														TempValueType;
				typedef T*&														ResultReferenceType;
				typedef T*														ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<ITypeInfo> elementType=TypeInfoRetriver<T>::CreateTypeInfo();
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::RawPtr);
					type->SetElementType(elementType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<Ptr<T>, TypeFlags::NonGenericType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=ITypeInfo::SharedPtr;
				typedef typename UpLevelRetriver::Type							Type;
				typedef Ptr<T>													TempValueType;
				typedef Ptr<T>&													ResultReferenceType;
				typedef Ptr<T>													ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<ITypeInfo> elementType=TypeInfoRetriver<T>::CreateTypeInfo();
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(elementType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T&, TypeFlags::NonGenericType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef typename UpLevelRetriver::Type							Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef T&														ResultReferenceType;
				typedef T														ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					return TypeInfoRetriver<T>::CreateTypeInfo();
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::EnumerableType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueEnumerable										Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					typedef typename DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>::Type		ContainerType;
					typedef typename ContainerType::ElementType										ElementType;

					Ptr<TypeInfoImpl> arrayType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					arrayType->SetTypeDescriptor(Description<IValueEnumerable>::GetAssociatedTypeDescriptor());

					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(arrayType);
					genericType->AddGenericArgument(TypeInfoRetriver<ElementType>::CreateTypeInfo());

					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::ReadonlyListType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueReadonlyList										Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					typedef typename DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>::Type		ContainerType;
					typedef typename ContainerType::ElementType										ElementType;

					Ptr<TypeInfoImpl> arrayType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					arrayType->SetTypeDescriptor(Description<IValueReadonlyList>::GetAssociatedTypeDescriptor());

					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(arrayType);
					genericType->AddGenericArgument(TypeInfoRetriver<ElementType>::CreateTypeInfo());

					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::ListType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					typedef typename DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>::Type		ContainerType;
					typedef typename ContainerType::ElementType										ElementType;

					Ptr<TypeInfoImpl> arrayType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					arrayType->SetTypeDescriptor(Description<IValueList>::GetAssociatedTypeDescriptor());

					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(arrayType);
					genericType->AddGenericArgument(TypeInfoRetriver<ElementType>::CreateTypeInfo());

					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::ReadonlyDictionaryType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueReadonlyList										Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					typedef typename DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>::Type		ContainerType;
					typedef typename ContainerType::KeyContainer									KeyContainer;
					typedef typename ContainerType::ValueContainer									ValueContainer;
					typedef typename KeyContainer::ElementType										KeyType;
					typedef typename ValueContainer::ElementType									ValueType;

					Ptr<TypeInfoImpl> arrayType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					arrayType->SetTypeDescriptor(Description<IValueReadonlyDictionary>::GetAssociatedTypeDescriptor());

					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(arrayType);
					genericType->AddGenericArgument(TypeInfoRetriver<KeyType>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<ValueType>::CreateTypeInfo());

					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};

			template<typename T>
			struct DetailTypeInfoRetriver<T, TypeFlags::DictionaryType>
			{
				typedef DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>	UpLevelRetriver;

				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueReadonlyList										Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;

				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					typedef typename DetailTypeInfoRetriver<T, TypeFlags::NonGenericType>::Type		ContainerType;
					typedef typename ContainerType::KeyContainer									KeyContainer;
					typedef typename ContainerType::ValueContainer									ValueContainer;
					typedef typename KeyContainer::ElementType										KeyType;
					typedef typename ValueContainer::ElementType									ValueType;

					Ptr<TypeInfoImpl> arrayType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					arrayType->SetTypeDescriptor(Description<IValueDictionary>::GetAssociatedTypeDescriptor());

					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(arrayType);
					genericType->AddGenericArgument(TypeInfoRetriver<KeyType>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<ValueType>::CreateTypeInfo());

					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};

/***********************************************************************
TypeInfoRetriver Helper Functions (BoxValue, UnboxValue)
***********************************************************************/

			template<typename T, ITypeInfo::Decorator Decorator>
			struct ValueAccessor
			{
			};

			template<typename T>
			struct ValueAccessor<T*, ITypeInfo::RawPtr>
			{
				static Value BoxValue(T* object, ITypeDescriptor* typeDescriptor)
				{
					return Value::From(object);
				}

				static T* UnboxValue(const Value& value, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					if(value.IsNull()) return 0;
					T* result=dynamic_cast<T*>(value.GetRawPtr());
					if(!result)
					{
						if(!typeDescriptor)
						{
							typeDescriptor=GetTypeDescriptor<T>();
						}
						throw ArgumentTypeMismtatchException(valueName, typeDescriptor, Value::RawPtr, value);
					}
					return result;
				}
			};

			template<typename T>
			struct ValueAccessor<Ptr<T>, ITypeInfo::SharedPtr>
			{
				static Value BoxValue(Ptr<T> object, ITypeDescriptor* typeDescriptor)
				{
					return Value::From(object);
				}

				static Ptr<T> UnboxValue(const Value& value, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					if(value.IsNull()) return 0;
					Ptr<T> result;
					if(value.GetValueType()==Value::SharedPtr)
					{
						result=value.GetSharedPtr().Cast<T>();
					}
					else if(value.GetValueType()==Value::RawPtr)
					{
						result=dynamic_cast<T*>(value.GetRawPtr());
					}
					if(!result)
					{
						if(!typeDescriptor)
						{
							typeDescriptor=GetTypeDescriptor<T>();
						}
						throw ArgumentTypeMismtatchException(valueName, typeDescriptor, Value::SharedPtr, value);
					}
					return result;
				}
			};

			template<typename T>
			struct ValueAccessor<T, ITypeInfo::TypeDescriptor>
			{
				static Value BoxValue(const T& object, ITypeDescriptor* typeDescriptor)
				{
					if(!typeDescriptor)
					{
						typeDescriptor=GetTypeDescriptor<typename TypeInfoRetriver<T>::Type>();
					}
					ITypedValueSerializer<T>* serializer=dynamic_cast<ITypedValueSerializer<T>*>(typeDescriptor->GetValueSerializer());
					Value result;
					serializer->Serialize(object, result);
					return result;
				}

				static T UnboxValue(const Value& value, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					ITypedValueSerializer<T>* serializer=dynamic_cast<ITypedValueSerializer<T>*>(value.GetTypeDescriptor()->GetValueSerializer());
					if(!serializer)
					{
						if(!typeDescriptor)
						{
							typeDescriptor=GetTypeDescriptor<typename TypeInfoRetriver<T>::Type>();
						}
						serializer=dynamic_cast<ITypedValueSerializer<T>*>(typeDescriptor->GetValueSerializer());
					}
					T result;
					if(!serializer->Deserialize(value, result))
					{
						if(!typeDescriptor)
						{
							typeDescriptor=GetTypeDescriptor<typename TypeInfoRetriver<T>::Type>();
						}
						throw ArgumentTypeMismtatchException(valueName, typeDescriptor, Value::Text, value);
					}
					return result;
				}
			};

			template<>
			struct ValueAccessor<Value, ITypeInfo::TypeDescriptor>
			{
				static Value BoxValue(const Value& object, ITypeDescriptor* typeDescriptor)
				{
					return object;
				}

				static Value UnboxValue(const Value& value, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					return value;
				}
			};

			template<typename T>
			Value BoxValue(const T& object, ITypeDescriptor* typeDescriptor=0)
			{
				return ValueAccessor<T, TypeInfoRetriver<T>::Decorator>::BoxValue(object, typeDescriptor);
			}

			template<typename T>
			T UnboxValue(const Value& value, ITypeDescriptor* typeDescriptor=0, const WString& valueName=L"value")
			{
				return ValueAccessor<T, TypeInfoRetriver<T>::Decorator>::UnboxValue(value, typeDescriptor, valueName);
			}

/***********************************************************************
TypeInfoRetriver Helper Functions (UnboxParameter)
***********************************************************************/

			template<typename T, TypeFlags Flag>
			struct ParameterAccessor
			{
			};

			template<typename T>
			struct ParameterAccessor<T, TypeFlags::NonGenericType>
			{
				static Value BoxParameter(const T& object, ITypeDescriptor* typeDescriptor)
				{
					return BoxValue<T>(object, typeDescriptor);
				}

				static void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					result=UnboxValue<T>(value, typeDescriptor, valueName);
				}
			};

			template<typename T>
			struct ParameterAccessor<collections::LazyList<T>, TypeFlags::EnumerableType>
			{
				static Value BoxParameter(collections::LazyList<T>& object, ITypeDescriptor* typeDescriptor)
				{
					Ptr<IValueEnumerable> result=IValueEnumerable::Create(
						collections::From(object)
							.Select([](const T& item)
							{
								return BoxValue<T>(item);
							})
						);
					return BoxValue<Ptr<IValueEnumerable>>(result, Description<IValueEnumerable>::GetAssociatedTypeDescriptor());
				}

				static void UnboxParameter(const Value& value, collections::LazyList<T>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef typename T::ElementType ElementType;
					Ptr<IValueEnumerable> listProxy=UnboxValue<Ptr<IValueEnumerable>>(value, typeDescriptor, valueName);
					result=IValueEnumerable::GetLazyList(listProxy);
				}
			};

			template<typename T>
			struct ParameterAccessor<T, TypeFlags::ReadonlyListType>
			{
				static Value BoxParameter(T& object, ITypeDescriptor* typeDescriptor)
				{
					Ptr<IValueReadonlyList> result=new ValueReadonlyListWrapper<T*>(&object);
					return BoxValue<Ptr<IValueReadonlyList>>(result, Description<IValueReadonlyList>::GetAssociatedTypeDescriptor());
				}

				static void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef typename T::ElementType ElementType;
					Ptr<IValueReadonlyList> listProxy=UnboxValue<Ptr<IValueReadonlyList>>(value, typeDescriptor, valueName);
					LazyList<ElementType> lazyList=listProxy->GetLazyList<ElementType>();
					collections::CopyFrom(result, lazyList);
				}
			};

			template<typename T>
			struct ParameterAccessor<T, TypeFlags::ListType>
			{
				static Value BoxParameter(T& object, ITypeDescriptor* typeDescriptor)
				{
					Ptr<IValueList> result=new ValueListWrapper<T*>(&object);
					return BoxValue<Ptr<IValueList>>(result, Description<IValueList>::GetAssociatedTypeDescriptor());
				}

				static void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef typename T::ElementType ElementType;
					Ptr<IValueList> listProxy=UnboxValue<Ptr<IValueList>>(value, typeDescriptor, valueName);
					collections::LazyList<ElementType> lazyList=listProxy->GetLazyList<ElementType>();
					collections::CopyFrom(result, lazyList);
				}
			};

			template<typename T>
			struct ParameterAccessor<T, TypeFlags::ReadonlyDictionaryType>
			{
				static Value BoxParameter(T& object, ITypeDescriptor* typeDescriptor)
				{
					Ptr<IValueReadonlyDictionary> result=new ValueReadonlyDictionaryWrapper<T*>(&object);
					return BoxValue<Ptr<IValueReadonlyDictionary>>(result, Description<IValueReadonlyList>::GetAssociatedTypeDescriptor());
				}

				static void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef typename T::KeyContainer					KeyContainer;
					typedef typename T::ValueContainer					ValueContainer;
					typedef typename KeyContainer::ElementType			KeyType;
					typedef typename ValueContainer::ElementType		ValueType;

					Ptr<IValueReadonlyDictionary> dictionaryProxy=UnboxValue<Ptr<IValueReadonlyDictionary>>(value, typeDescriptor, valueName);
					collections::LazyList<Pair<KeyType, ValueType>> lazyList=dictionaryProxy->GetLazyList<KeyType, ValueType>();
					collections::CopyFrom(result, lazyList);
				}
			};

			template<typename T>
			struct ParameterAccessor<T, TypeFlags::DictionaryType>
			{
				static Value BoxParameter(T& object, ITypeDescriptor* typeDescriptor)
				{
					Ptr<IValueDictionary> result=new ValueDictionaryWrapper<T*>(&object);
					return BoxValue<Ptr<IValueDictionary>>(result, Description<IValueList>::GetAssociatedTypeDescriptor());
				}

				static void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef typename T::KeyContainer					KeyContainer;
					typedef typename T::ValueContainer					ValueContainer;
					typedef typename KeyContainer::ElementType			KeyType;
					typedef typename ValueContainer::ElementType		ValueType;

					Ptr<IValueDictionary> dictionaryProxy=UnboxValue<Ptr<IValueDictionary>>(value, typeDescriptor, valueName);
					collections::LazyList<Pair<KeyType, ValueType>> lazyList=dictionaryProxy->GetLazyList<KeyType, ValueType>();
					collections::CopyFrom(result, lazyList);
				}
			};

			template<typename T>
			Value BoxParameter(typename TypeInfoRetriver<T>::ResultReferenceType object, ITypeDescriptor* typeDescriptor=0)
			{
				return ParameterAccessor<typename TypeInfoRetriver<T>::ResultNonReferenceType, TypeInfoRetriver<T>::TypeFlag>::BoxParameter(object, typeDescriptor);
			}

			template<typename T>
			void UnboxParameter(const Value& value, T& result, ITypeDescriptor* typeDescriptor=0, const WString& valueName=L"value")
			{
				ParameterAccessor<T, TypeInfoRetriver<T>::TypeFlag>::UnboxParameter(value, result, typeDescriptor, valueName);
			}

/***********************************************************************
CustomFieldInfoImpl
***********************************************************************/

			template<typename TClass, typename TField, TField TClass::* FieldRef>
			class CustomFieldInfoImpl : public FieldInfoImpl
			{
			protected:
				Value GetValueInternal(const Value& thisObject)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject);
					if(object)
					{
						return BoxParameter<TField>(object->*FieldRef, GetReturn()->GetTypeDescriptor());
					}
					return Value();
				}

				void SetValueInternal(Value& thisObject, const Value& newValue)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject);
					if(object)
					{
						UnboxParameter<TField>(newValue, object->*FieldRef, GetReturn()->GetTypeDescriptor(), L"newValue");
					}
				}
			public:
				CustomFieldInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name)
					:FieldInfoImpl(_ownerTypeDescriptor, _name, TypeInfoRetriver<TField>::CreateTypeInfo())
				{
				}
			};

/***********************************************************************
StructValueSeriaizer
***********************************************************************/

			template<typename T>
			class StructValueSeriaizer : public GeneralValueSeriaizer<T>
			{
			public:
				class FieldSerializerBase : public Object
				{
				public:
					virtual bool				SerializeField(const T& input, WString& output)=0;
					virtual bool				DeserializeField(WString& input, T& output)=0;
				};

				template<typename TField>
				class FieldSerializer : public FieldSerializerBase, public FieldInfoImpl
				{
				protected:
					TField T::*					field;

					Value GetValueInternal(const Value& thisObject)override
					{
						T structValue=UnboxValue<T>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
						TField fieldValue=structValue.*field;
						return BoxValue<TField>(fieldValue, GetReturn()->GetTypeDescriptor());
					}

					void SetValueInternal(Value& thisObject, const Value& newValue)override
					{
						T structValue=UnboxValue<T>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
						TField fieldValue=UnboxValue<TField>(newValue, GetReturn()->GetTypeDescriptor(), L"newValue");
						structValue.*field=fieldValue;
						thisObject=BoxValue<T>(structValue, GetOwnerTypeDescriptor());
					}
				public:
					FieldSerializer(ITypeDescriptor* _ownerTypeDescriptor, TField T::* _field, const WString& _name)
						:field(_field)
						,FieldInfoImpl(_ownerTypeDescriptor, _name, TypeInfoRetriver<TField>::CreateTypeInfo())
					{
					}

					bool SerializeField(const T& input, WString& output)override
					{
						ITypedValueSerializer<TField>* serializer=GetValueSerializer<TField>();
						if(!serializer) return false;
						Value result;
						if(!serializer->Serialize(input.*field, result)) return false;
						output=result.GetText();
						return true;
					}

					bool DeserializeField(WString& input, T& output)override
					{
						ITypedValueSerializer<TField>* serializer=GetValueSerializer<TField>();
						if(!serializer) return false;
						Value value=Value::From(input, serializer->GetOwnerTypeDescriptor());
						return serializer->Deserialize(value, output.*field);
					}
				};

			protected:
				collections::Dictionary<WString, Ptr<FieldSerializerBase>>		fieldSerializers;
				bool															loaded;

				virtual void													LoadInternal()=0;

				void Load()
				{
					if(!loaded)
					{
						loaded=true;
						LoadInternal();
					}
				}

				WString Escape(const WString& text)
				{
					const wchar_t* reading=text.Buffer();
					if(wcschr(reading, L' ')==0 && wcschr(reading, L'{')==0 && wcschr(reading, L'}')==0)
					{
						return text;
					}

					WString result;
					while(wchar_t c=*reading++)
					{
						switch(c)
						{
						case L'{':
							result+=L"{{";
						case L'}':
							result+=L"}}";
							break;
						default:
							result+=c;
						}
					}
					return L"{"+result+L"}";
				}

				bool Unescape(const wchar_t*& reading, WString& field)
				{
					if(*reading==L'{')
					{
						const wchar_t* start=reading+1;
						const wchar_t* end=start;
						bool stop=false;
						while(!stop)
						{
							switch(*end)
							{
							case L'\0':
								return false;
							case L'{':
								if(end[1]==L'{') return false;
								end+=2;
								field+=L'{';
								break;
							case L'}':
								if(end[1]==L'}')
								{
									end+=2;
									field+=L'}';
								}
								else
								{
									stop=true;
								}
								break;
							default:
								field+=*end;
								end++;
							}
						}
						reading=end+1;
					}
					else
					{
						const wchar_t* space=wcschr(reading, L' ');
						if(space)
						{
							field=WString(reading, space-reading);
							reading=space+1;
						}
						else
						{
							field=reading;
							reading+=field.Length();
						}
					}
					return true;
				}

				bool Serialize(const T& input, WString& output)override
				{
					Load();
					WString result, field;
					for(vint i=0;i<fieldSerializers.Count();i++)
					{
						if(result!=L"") result+=L" ";
						result+=fieldSerializers.Keys()[i]+L":";

						Ptr<FieldSerializerBase> fieldSerializer=fieldSerializers.Values().Get(i);
						if(!fieldSerializer->SerializeField(input, field)) return false;
						result+=Escape(field);
					}
					output=result;
					return true;
				}

				bool Deserialize(const WString& input, T& output)override
				{
					Load();
					const wchar_t* reading=input.Buffer();
					while(true)
					{
						while(*reading==L' ') reading++;
						if(*reading==0) break;
						const wchar_t* comma=wcschr(reading, L':');
						if(!comma) return false;

						vint index=fieldSerializers.Keys().IndexOf(WString(reading, comma-reading));
						if(index==-1) return false;
						reading=comma+1;

						WString field;
						if(!Unescape(reading, field)) return false;
						Ptr<FieldSerializerBase> fieldSerializer=fieldSerializers.Values().Get(index);
						if(!fieldSerializer->DeserializeField(field, output)) return false;
					}
					return true;
				}
			public:
				StructValueSeriaizer(ITypeDescriptor* _ownedTypeDescriptor)
					:GeneralValueSeriaizer(_ownedTypeDescriptor)
					,loaded(false)
				{
				}

				const collections::Dictionary<WString, Ptr<FieldSerializerBase>>& GetFieldSerializers()
				{
					Load();
					return fieldSerializers;
				}
			};

			template<typename TSerializer>
			class StructTypeDescriptor : public SerializableTypeDescriptor<TSerializer>
			{
			protected:
				Ptr<TSerializer>				typedSerializer;

			public:
				StructTypeDescriptor()
				{
					typedSerializer=serializer.Cast<TSerializer>();
				}

				vint GetPropertyCount()override
				{
					return typedSerializer->GetFieldSerializers().Count();
				}

				IPropertyInfo* GetProperty(vint index)override
				{
					return typedSerializer->GetFieldSerializers().Values().Get(index).Cast<IPropertyInfo>().Obj();
				}

				bool IsPropertyExists(const WString& name, bool inheritable)override
				{
					return typedSerializer->GetFieldSerializers().Keys().Contains(name);
				}

				IPropertyInfo* GetPropertyByName(const WString& name, bool inheritable)override
				{
					vint index=typedSerializer->GetFieldSerializers().Keys().IndexOf(name);
					if(index==-1) return 0;
					return GetProperty(index);
				}
			};
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORBUILDER_GEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
 
#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
 
 
namespace vl
{
	namespace reflection
	{
		namespace description
		{
			template<typename T>
			class CustomConstructorInfoImpl{};
			template<typename TClass, typename T>
			struct CustomMethodInfoImplSelector{};
 
/***********************************************************************
Constructor: R()
***********************************************************************/
			template<typename R >
			class CustomConstructorInfoImpl<R()> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{

					R result = new typename TypeInfoRetriver<R>::Type();
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{

				}
			};
  
/***********************************************************************
Constructor: R(T0)
***********************************************************************/
			template<typename R,typename T0>
			class CustomConstructorInfoImpl<R(T0)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1)
***********************************************************************/
			template<typename R,typename T0,typename T1>
			class CustomConstructorInfoImpl<R(T0,T1)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2>
			class CustomConstructorInfoImpl<R(T0,T1,T2)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4,T5)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4,p5);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4,T5,T6)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4,p5,p6);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4,p5,p6,p7);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
  
/***********************************************************************
Constructor: R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			class CustomConstructorInfoImpl<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					R result = new typename TypeInfoRetriver<R>::Type(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return BoxParameter<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
 
 
/***********************************************************************
Member Method: void()
***********************************************************************/
			template<typename TClass  >
			struct CustomMethodInfoImplSelector<TClass, void()>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)();
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");

					  (object->*method)();
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)())
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{

				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");

					  method(object);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{

				}
			};
			};
/***********************************************************************
Member Method: R()
***********************************************************************/
			template<typename TClass,typename R >
			struct CustomMethodInfoImplSelector<TClass, R()>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)();
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");

					R result =  (object->*method)();
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)())
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{

				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");

					R result =  method(object);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{

				}
			};
			};
  
/***********************************************************************
Member Method: void(T0)
***********************************************************************/
			template<typename TClass, typename T0>
			struct CustomMethodInfoImplSelector<TClass, void(T0)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					  (object->*method)(p0);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					  method(object, p0);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0)
***********************************************************************/
			template<typename TClass,typename R,typename T0>
			struct CustomMethodInfoImplSelector<TClass, R(T0)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					R result =  (object->*method)(p0);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					R result =  method(object, p0);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1)
***********************************************************************/
			template<typename TClass, typename T0,typename T1>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					  (object->*method)(p0,p1);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					  method(object, p0, p1);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					R result =  (object->*method)(p0,p1);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					R result =  method(object, p0, p1);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					  (object->*method)(p0,p1,p2);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					  method(object, p0, p1, p2);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					R result =  (object->*method)(p0,p1,p2);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					R result =  method(object, p0, p1, p2);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					  (object->*method)(p0,p1,p2,p3);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					  method(object, p0, p1, p2, p3);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					R result =  (object->*method)(p0,p1,p2,p3);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					R result =  method(object, p0, p1, p2, p3);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					  (object->*method)(p0,p1,p2,p3,p4);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					  method(object, p0, p1, p2, p3, p4);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					R result =  method(object, p0, p1, p2, p3, p4);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4,T5)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					  (object->*method)(p0,p1,p2,p3,p4,p5);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4, T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					  method(object, p0, p1, p2, p3, p4, p5);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4, T5))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4,T5)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4,p5);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4, T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					R result =  method(object, p0, p1, p2, p3, p4, p5);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4, T5))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4,T5,T6)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					  (object->*method)(p0,p1,p2,p3,p4,p5,p6);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					  method(object, p0, p1, p2, p3, p4, p5, p6);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4,T5,T6)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4,p5,p6);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					R result =  method(object, p0, p1, p2, p3, p4, p5, p6);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4,T5,T6,T7)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					  method(object, p0, p1, p2, p3, p4, p5, p6, p7);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4,T5,T6,T7)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					R result =  method(object, p0, p1, p2, p3, p4, p5, p6, p7);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					  method(object, p0, p1, p2, p3, p4, p5, p6, p7, p8);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					R result =  method(object, p0, p1, p2, p3, p4, p5, p6, p7, p8);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Member Method: void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename TClass, typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct CustomMethodInfoImplSelector<TClass, void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					  method(object, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
					return Value();
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], void(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Member Method: R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename TClass,typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct CustomMethodInfoImplSelector<TClass, R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(__thiscall TClass::* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					R result =  (object->*method)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(__thiscall TClass::* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
 
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(*method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					R result =  method(object, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], R(*_method)(TClass*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), false)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
			};
 
 
/***********************************************************************
Static Method: void()
***********************************************************************/
			template< >
			struct CustomMethodInfoImplSelector<void, void()>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)();
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{

					  method();
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)())
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{

				}
			};
			};
/***********************************************************************
Static Method: R()
***********************************************************************/
			template<typename R >
			struct CustomMethodInfoImplSelector<void, R()>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)();
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{

					R result =  method();
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)())
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{

				}
			};
			};
  
/***********************************************************************
Static Method: void(T0)
***********************************************************************/
			template< typename T0>
			struct CustomMethodInfoImplSelector<void, void(T0)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					  method(p0);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0)
***********************************************************************/
			template<typename R,typename T0>
			struct CustomMethodInfoImplSelector<void, R(T0)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 
					R result =  method(p0);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1)
***********************************************************************/
			template< typename T0,typename T1>
			struct CustomMethodInfoImplSelector<void, void(T0,T1)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					  method(p0,p1);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1)
***********************************************************************/
			template<typename R,typename T0,typename T1>
			struct CustomMethodInfoImplSelector<void, R(T0,T1)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 
					R result =  method(p0,p1);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2)
***********************************************************************/
			template< typename T0,typename T1,typename T2>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					  method(p0,p1,p2);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 
					R result =  method(p0,p1,p2);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					  method(p0,p1,p2,p3);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 
					R result =  method(p0,p1,p2,p3);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					  method(p0,p1,p2,p3,p4);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 
					R result =  method(p0,p1,p2,p3,p4);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4,T5)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4,T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					  method(p0,p1,p2,p3,p4,p5);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4,T5))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4,T5)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4,T5);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 
					R result =  method(p0,p1,p2,p3,p4,p5);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4,T5))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4,T5,T6)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4,T5,T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					  method(p0,p1,p2,p3,p4,p5,p6);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4,T5,T6))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4,T5,T6)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4,T5,T6);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 
					R result =  method(p0,p1,p2,p3,p4,p5,p6);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4,T5,T6))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4,T5,T6,T7)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4,T5,T6,T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					  method(p0,p1,p2,p3,p4,p5,p6,p7);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4,T5,T6,T7))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4,T5,T6,T7)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4,T5,T6,T7);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 
					R result =  method(p0,p1,p2,p3,p4,p5,p6,p7);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4,T5,T6,T7))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					  method(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 
					R result =  method(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 
				}
			};
			};
  
/***********************************************************************
Static Method: void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct CustomMethodInfoImplSelector<void, void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				void(* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					  method(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], void(* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
					:MethodInfoImpl(0, TypeInfoRetriver<void>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
			};
/***********************************************************************
Static Method: R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct CustomMethodInfoImplSelector<void, R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				R(* method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
 
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments[0], p0, GetParameter(0)->GetType()->GetTypeDescriptor(), L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments[1], p1, GetParameter(1)->GetType()->GetTypeDescriptor(), L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments[2], p2, GetParameter(2)->GetType()->GetTypeDescriptor(), L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments[3], p3, GetParameter(3)->GetType()->GetTypeDescriptor(), L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments[4], p4, GetParameter(4)->GetType()->GetTypeDescriptor(), L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments[5], p5, GetParameter(5)->GetType()->GetTypeDescriptor(), L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments[6], p6, GetParameter(6)->GetType()->GetTypeDescriptor(), L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments[7], p7, GetParameter(7)->GetType()->GetTypeDescriptor(), L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments[8], p8, GetParameter(8)->GetType()->GetTypeDescriptor(), L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments[9], p9, GetParameter(9)->GetType()->GetTypeDescriptor(), L"p9");
 
					R result =  method(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return BoxParameter<R>(result, GetReturn()->GetTypeDescriptor());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], R(* _method)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
					:MethodInfoImpl(0, TypeInfoRetriver<R>::CreateTypeInfo(), true)
					,method(_method)
				{
					AddParameter(new ParameterInfoImpl(this, parameterNames[0], TypeInfoRetriver<T0>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[1], TypeInfoRetriver<T1>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[2], TypeInfoRetriver<T2>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[3], TypeInfoRetriver<T3>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[4], TypeInfoRetriver<T4>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[5], TypeInfoRetriver<T5>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[6], TypeInfoRetriver<T6>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[7], TypeInfoRetriver<T7>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[8], TypeInfoRetriver<T8>::CreateTypeInfo()));
 					AddParameter(new ParameterInfoImpl(this, parameterNames[9], TypeInfoRetriver<T9>::CreateTypeInfo()));
 
				}
			};
			};
 
 
/***********************************************************************
DetailTypeInfoRetriver: R()
***********************************************************************/
			template<typename R >
			struct DetailTypeInfoRetriver<Func<R()>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R()>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());

 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0)
***********************************************************************/
			template<typename R,typename T0>
			struct DetailTypeInfoRetriver<Func<R(T0)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1)
***********************************************************************/
			template<typename R,typename T0,typename T1>
			struct DetailTypeInfoRetriver<Func<R(T0,T1)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T5>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T5>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T6>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T5>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T6>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T7>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T5>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T6>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T7>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T8>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
  
/***********************************************************************
DetailTypeInfoRetriver: R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>, TypeFlags::FunctionType>
			{
				typedef DetailTypeInfoRetriver<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>, TypeFlags::NonGenericType>	UpLevelRetriver;
 
				static const ITypeInfo::Decorator								Decorator=UpLevelRetriver::Decorator;
				typedef IValueList												Type;
				typedef typename UpLevelRetriver::TempValueType					TempValueType;
				typedef typename UpLevelRetriver::ResultReferenceType			ResultReferenceType;
				typedef typename UpLevelRetriver::ResultNonReferenceType		ResultNonReferenceType;
 
				static Ptr<ITypeInfo> CreateTypeInfo()
				{
					Ptr<TypeInfoImpl> functionType=new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					functionType->SetTypeDescriptor(Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
 
					Ptr<TypeInfoImpl> genericType=new TypeInfoImpl(ITypeInfo::Generic);
					genericType->SetElementType(functionType);
					genericType->AddGenericArgument(TypeInfoRetriver<R>::CreateTypeInfo());
					genericType->AddGenericArgument(TypeInfoRetriver<T0>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T1>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T2>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T3>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T4>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T5>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T6>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T7>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T8>::CreateTypeInfo());
 					genericType->AddGenericArgument(TypeInfoRetriver<T9>::CreateTypeInfo());
 
 
					Ptr<TypeInfoImpl> type=new TypeInfoImpl(ITypeInfo::SharedPtr);
					type->SetElementType(genericType);
					return type;
				}
			};
 
 
			template<typename T>
			class ValueFunctionProxyWrapper
			{
			};
 
 
/***********************************************************************
Parameter Accessor: void()
***********************************************************************/
			template< >
			class ValueFunctionProxyWrapper<void()> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void()>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(arguments && arguments->GetCount()!=0) throw ArgumentCountMismtatchException();

					  function();
					return Value();
				}
			};
 
			template< >
			struct ParameterAccessor<Func<void()>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void()>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)();
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void()>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)();
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy]()
							{
								functionProxy->Invoke(0);
								 

								 
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R()
***********************************************************************/
			template<typename R >
			class ValueFunctionProxyWrapper<R()> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R()>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(arguments && arguments->GetCount()!=0) throw ArgumentCountMismtatchException();

					R result =  function();
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R >
			struct ParameterAccessor<Func<R()>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R()>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)();
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R()>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)();
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy]()
							{
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(0),proxyResult);return proxyResult;
								 

								 
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0)
***********************************************************************/
			template< typename T0>
			class ValueFunctionProxyWrapper<void(T0)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=1) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 
					  function(p0);
					return Value();
				}
			};
 
			template< typename T0>
			struct ParameterAccessor<Func<void(T0)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0)
***********************************************************************/
			template<typename R,typename T0>
			class ValueFunctionProxyWrapper<R(T0)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=1) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 
					R result =  function(p0);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0>
			struct ParameterAccessor<Func<R(T0)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1)
***********************************************************************/
			template< typename T0,typename T1>
			class ValueFunctionProxyWrapper<void(T0,T1)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=2) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 
					  function(p0,p1);
					return Value();
				}
			};
 
			template< typename T0,typename T1>
			struct ParameterAccessor<Func<void(T0,T1)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1)
***********************************************************************/
			template<typename R,typename T0,typename T1>
			class ValueFunctionProxyWrapper<R(T0,T1)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=2) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 
					R result =  function(p0,p1);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1>
			struct ParameterAccessor<Func<R(T0,T1)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2)
***********************************************************************/
			template< typename T0,typename T1,typename T2>
			class ValueFunctionProxyWrapper<void(T0,T1,T2)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=3) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 
					  function(p0,p1,p2);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2>
			struct ParameterAccessor<Func<void(T0,T1,T2)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2>
			class ValueFunctionProxyWrapper<R(T0,T1,T2)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=3) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 
					R result =  function(p0,p1,p2);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2>
			struct ParameterAccessor<Func<R(T0,T1,T2)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=4) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 
					  function(p0,p1,p2,p3);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=4) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 
					R result =  function(p0,p1,p2,p3);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=5) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 
					  function(p0,p1,p2,p3,p4);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=5) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 
					R result =  function(p0,p1,p2,p3,p4);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4,T5)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4,T5)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=6) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 
					  function(p0,p1,p2,p3,p4,p5);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4,T5)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4,T5)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4,T5)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4,T5)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4,T5)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4,T5)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=6) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 
					R result =  function(p0,p1,p2,p3,p4,p5);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4,T5)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4,T5)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4,T5)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4,T5,T6)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4,T5,T6)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=7) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 
					  function(p0,p1,p2,p3,p4,p5,p6);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4,T5,T6)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4,T5,T6)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4,T5,T6)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4,T5,T6)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4,T5,T6)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=7) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 
					R result =  function(p0,p1,p2,p3,p4,p5,p6);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4,T5,T6)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4,T5,T6)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=8) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 
					  function(p0,p1,p2,p3,p4,p5,p6,p7);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4,T5,T6,T7)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=8) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 
					R result =  function(p0,p1,p2,p3,p4,p5,p6,p7);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=9) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments->Get(8), p8, 0, L"p8");
 
					  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 								arguments->Add(description::BoxParameter<T8>(p8));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4,T5,T6,T7,T8)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=9) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments->Get(8), p8, 0, L"p8");
 
					R result =  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 								arguments->Add(description::BoxParameter<T8>(p8));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
  
/***********************************************************************
Parameter Accessor: void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			class ValueFunctionProxyWrapper<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=10) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments->Get(8), p8, 0, L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments->Get(9), p9, 0, L"p9");
 
					  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return Value();
				}
			};
 
			template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct ParameterAccessor<Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef void(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 								arguments->Add(description::BoxParameter<T8>(p8));
 								arguments->Add(description::BoxParameter<T9>(p9));
 
								functionProxy->Invoke(arguments);
							};
						}
					}
				}
			};
/***********************************************************************
Parameter Accessor: R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)
***********************************************************************/
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			class ValueFunctionProxyWrapper<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object, public virtual IValueFunctionProxy
			{
				typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>					FunctionType;
			protected:
				FunctionType			function;
			public:
				ValueFunctionProxyWrapper(const FunctionType& _function)
					:function(_function)
				{
				}
 
				FunctionType GetFunction()
				{
					return function;
				}
 
				Value Invoke(Ptr<IValueList> arguments)override
				{
					if(!arguments || arguments->GetCount()!=10) throw ArgumentCountMismtatchException();
					typename TypeInfoRetriver<T0>::TempValueType p0;
					UnboxParameter<typename TypeInfoRetriver<T0>::TempValueType>(arguments->Get(0), p0, 0, L"p0");
 					typename TypeInfoRetriver<T1>::TempValueType p1;
					UnboxParameter<typename TypeInfoRetriver<T1>::TempValueType>(arguments->Get(1), p1, 0, L"p1");
 					typename TypeInfoRetriver<T2>::TempValueType p2;
					UnboxParameter<typename TypeInfoRetriver<T2>::TempValueType>(arguments->Get(2), p2, 0, L"p2");
 					typename TypeInfoRetriver<T3>::TempValueType p3;
					UnboxParameter<typename TypeInfoRetriver<T3>::TempValueType>(arguments->Get(3), p3, 0, L"p3");
 					typename TypeInfoRetriver<T4>::TempValueType p4;
					UnboxParameter<typename TypeInfoRetriver<T4>::TempValueType>(arguments->Get(4), p4, 0, L"p4");
 					typename TypeInfoRetriver<T5>::TempValueType p5;
					UnboxParameter<typename TypeInfoRetriver<T5>::TempValueType>(arguments->Get(5), p5, 0, L"p5");
 					typename TypeInfoRetriver<T6>::TempValueType p6;
					UnboxParameter<typename TypeInfoRetriver<T6>::TempValueType>(arguments->Get(6), p6, 0, L"p6");
 					typename TypeInfoRetriver<T7>::TempValueType p7;
					UnboxParameter<typename TypeInfoRetriver<T7>::TempValueType>(arguments->Get(7), p7, 0, L"p7");
 					typename TypeInfoRetriver<T8>::TempValueType p8;
					UnboxParameter<typename TypeInfoRetriver<T8>::TempValueType>(arguments->Get(8), p8, 0, L"p8");
 					typename TypeInfoRetriver<T9>::TempValueType p9;
					UnboxParameter<typename TypeInfoRetriver<T9>::TempValueType>(arguments->Get(9), p9, 0, L"p9");
 
					R result =  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
					return BoxParameter<R>(result);
				}
			};
 
			template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
			struct ParameterAccessor<Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>, TypeFlags::FunctionType>
			{
				static Value BoxParameter(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& object, ITypeDescriptor* typeDescriptor)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
					Ptr<IValueFunctionProxy> result=new ValueFunctionProxyWrapper<RawFunctionType>(object);
					return BoxValue<Ptr<IValueFunctionProxy>>(result, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor());
				}
 
				static void UnboxParameter(const Value& value, Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& result, ITypeDescriptor* typeDescriptor, const WString& valueName)
				{
					typedef R(RawFunctionType)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
					typedef ValueFunctionProxyWrapper<RawFunctionType> ProxyType;
					Ptr<IValueFunctionProxy> functionProxy=UnboxValue<Ptr<IValueFunctionProxy>>(value, typeDescriptor, valueName);
					if(functionProxy)
					{
						if(Ptr<ProxyType> proxy=functionProxy.Cast<ProxyType>())
						{
							result=proxy->GetFunction();
						}
						else
						{
							result=[functionProxy](T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
							{
								 
								Ptr<IValueList> arguments=IValueList::Create();
								arguments->Add(description::BoxParameter<T0>(p0));
 								arguments->Add(description::BoxParameter<T1>(p1));
 								arguments->Add(description::BoxParameter<T2>(p2));
 								arguments->Add(description::BoxParameter<T3>(p3));
 								arguments->Add(description::BoxParameter<T4>(p4));
 								arguments->Add(description::BoxParameter<T5>(p5));
 								arguments->Add(description::BoxParameter<T6>(p6));
 								arguments->Add(description::BoxParameter<T7>(p7));
 								arguments->Add(description::BoxParameter<T8>(p8));
 								arguments->Add(description::BoxParameter<T9>(p9));
 
								TypeInfoRetriver<R>::TempValueType proxyResult;description::UnboxParameter<R>(functionProxy->Invoke(arguments),proxyResult);return proxyResult;
							};
						}
					}
				}
			};
 
 
/***********************************************************************
Parameter Accessor: const function
***********************************************************************/
			template<typename T>
			struct ParameterAccessor<const T, TypeFlags::ListType> : public ParameterAccessor<T, TypeFlags::ListType>
			{
			};
		}
	}
}
 
#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORMACROS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

Classes:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORMACROS
#define VCZH_REFLECTION_GUITYPEDESCRIPTORMACROS


/***********************************************************************
Macros
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			template<typename T>
			struct CustomTypeDescriptorSelector{};

/***********************************************************************
Type
***********************************************************************/

#define BEGIN_TYPE_INFO_NAMESPACE namespace vl{namespace reflection{namespace description{
#define END_TYPE_INFO_NAMESPACE }}}
#define DECL_TYPE_INFO(TYPENAME) template<>struct TypeInfo<TYPENAME>{static const wchar_t* TypeName;};
#define IMPL_TYPE_INFO(TYPENAME) const wchar_t* TypeInfo<TYPENAME>::TypeName = L#TYPENAME;
#define ADD_TYPE_INFO(TYPENAME)\
			{\
				Ptr<ITypeDescriptor> type=new CustomTypeDescriptorSelector<TYPENAME>::CustomTypeDescriptorImpl();\
				manager->SetTypeDescriptor(TypeInfo<TYPENAME>::TypeName, type);\
			}

#define INVOKE_INTERFACE_PROXY(METHODNAME, ...)\
	proxy->Invoke(L#METHODNAME, IValueList::Create(collections::From((collections::Array<Value>&)(Value::xs(), __VA_ARGS__))))

#define INVOKE_INTERFACE_PROXY_NOPARAM(METHODNAME)\
	proxy->Invoke(L#METHODNAME, IValueList::Create())

#define INVOKEGET_INTERFACE_PROXY(METHODNAME, ...)\
	UnboxValue<decltype(METHODNAME(__VA_ARGS__))>(proxy->Invoke(L#METHODNAME, IValueList::Create(collections::From((collections::Array<Value>&)(Value::xs(), __VA_ARGS__)))))

#define INVOKEGET_INTERFACE_PROXY_NOPARAMS(METHODNAME)\
	UnboxValue<decltype(METHODNAME())>(proxy->Invoke(L#METHODNAME, IValueList::Create()))

/***********************************************************************
Enum
***********************************************************************/

#define BEGIN_ENUM_ITEM_FLAG(TYPENAME, FLAG)\
			template<>\
			struct CustomTypeDescriptorSelector<TYPENAME>\
			{\
			public:\
				class CustomEnumValueSerializer : public EnumValueSeriaizer<TYPENAME, FLAG>\
				{\
					typedef TYPENAME EnumType;\
				public:\
					CustomEnumValueSerializer(ITypeDescriptor* _ownerTypeDescriptor)\
						:EnumValueSeriaizer(_ownerTypeDescriptor)\
					{

#define BEGIN_ENUM_ITEM(TYPENAME) BEGIN_ENUM_ITEM_FLAG(TYPENAME, false)
#define BEGIN_ENUM_ITEM_MERGABLE(TYPENAME) BEGIN_ENUM_ITEM_FLAG(TYPENAME, true)

#define END_ENUM_ITEM(TYPENAME)\
					}\
				};\
				typedef SerializableTypeDescriptor<CustomEnumValueSerializer> CustomTypeDescriptorImpl;\
			};

#define ENUM_ITEM_NAMESPACE(TYPENAME) typedef TYPENAME EnumItemNamespace;
#define ENUM_ITEM(ITEMNAME) candidates.Add(L#ITEMNAME, ITEMNAME);
#define ENUM_NAMESPACE_ITEM(ITEMNAME) candidates.Add(L#ITEMNAME, EnumItemNamespace::ITEMNAME);
#define ENUM_CLASS_ITEM(ITEMNAME) candidates.Add(L#ITEMNAME, EnumType::ITEMNAME);

/***********************************************************************
Struct
***********************************************************************/

#define BEGIN_STRUCT_MEMBER(TYPENAME)\
			template<>\
			struct CustomTypeDescriptorSelector<TYPENAME>\
			{\
			public:\
				class CustomStructValueSerializer : public StructValueSeriaizer<TYPENAME>\
				{\
					typedef TYPENAME StructType;\
				public:\
					CustomStructValueSerializer(ITypeDescriptor* _ownerTypeDescriptor)\
						:StructValueSeriaizer(_ownerTypeDescriptor)\
					{\
					}\
				protected:\
					void LoadInternal()override\
					{

#define END_STRUCT_MEMBER(TYPENAME)\
					}\
				};\
				typedef StructTypeDescriptor<CustomStructValueSerializer> CustomTypeDescriptorImpl;\
			};

#define STRUCT_MEMBER(FIELDNAME)\
	fieldSerializers.Add(L#FIELDNAME, new FieldSerializer<decltype(((StructType*)0)->FIELDNAME)>(GetOwnerTypeDescriptor(), &StructType::FIELDNAME, L#FIELDNAME));

/***********************************************************************
Class
***********************************************************************/

#define BEGIN_CLASS_MEMBER(TYPENAME)\
			template<>\
			struct CustomTypeDescriptorSelector<TYPENAME>\
			{\
			public:\
				class CustomTypeDescriptorImpl : public TypeDescriptorImpl\
				{\
					typedef TYPENAME ClassType;\
				public:\
					CustomTypeDescriptorImpl()\
						:TypeDescriptorImpl(TypeInfo<TYPENAME>::TypeName)\
					{\
						Description<TYPENAME>::SetAssociatedTypeDescroptor(this);\
					}\
					~CustomTypeDescriptorImpl()\
					{\
						Description<TYPENAME>::SetAssociatedTypeDescroptor(0);\
					}\
				protected:\
					void LoadInternal()override\
					{

#define END_CLASS_MEMBER(TYPENAME)\
					}\
				};\
			};

#define CLASS_MEMBER_BASE(TYPENAME)\
			AddBaseType(description::GetTypeDescriptor<TYPENAME>());

/***********************************************************************
Field
***********************************************************************/

#define CLASS_MEMBER_FIELD(FIELDNAME)\
			AddProperty(\
				new CustomFieldInfoImpl<\
					ClassType,\
					decltype(((ClassType*)0)->FIELDNAME), (decltype(((ClassType*)0)->FIELDNAME) ClassType::*)&ClassType::FIELDNAME>\
					(this, L#FIELDNAME)\
				);

/***********************************************************************
Constructor
***********************************************************************/

#define NO_PARAMETER {L""}

#define CLASS_MEMBER_CONSTRUCTOR(FUNCTIONTYPE, PARAMETERNAMES)\
			{\
				const wchar_t* parameterNames[]=PARAMETERNAMES;\
				AddConstructor(new CustomConstructorInfoImpl<FUNCTIONTYPE>(parameterNames));\
			}

#define CLASS_MEMBER_EXTERNALCTOR(FUNCTIONTYPE, PARAMETERNAMES, SOURCE)\
			{\
				const wchar_t* parameterNames[]=PARAMETERNAMES;\
				AddConstructor(\
					new CustomMethodInfoImplSelector<\
						void,\
						FUNCTIONTYPE\
						>\
						::CustomMethodInfoImpl(parameterNames, SOURCE)\
					);\
			}

/***********************************************************************
Method
***********************************************************************/

#define CLASS_MEMBER_EXTERNALMETHOD(FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE, SOURCE)\
			{\
				const wchar_t* parameterNames[]=PARAMETERNAMES;\
				AddMethod(\
					L#FUNCTIONNAME,\
					new CustomMethodInfoImplSelector<\
						ClassType,\
						vl::function_lambda::LambdaRetriveType<FUNCTIONTYPE>::FunctionType\
						>\
						::ExternalMethodInfoImpl(parameterNames, SOURCE)\
					);\
			}

#define CLASS_MEMBER_METHOD_OVERLOAD_RENAME(EXPECTEDNAME, FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE)\
			{\
				const wchar_t* parameterNames[]=PARAMETERNAMES;\
				AddMethod(\
					L#EXPECTEDNAME,\
					new CustomMethodInfoImplSelector<\
						ClassType,\
						vl::function_lambda::LambdaRetriveType<FUNCTIONTYPE>::FunctionType\
						>\
						::CustomMethodInfoImpl(parameterNames, (FUNCTIONTYPE)&ClassType::FUNCTIONNAME)\
					);\
			}

#define CLASS_MEMBER_METHOD_OVERLOAD(FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE)\
			CLASS_MEMBER_METHOD_OVERLOAD_RENAME(FUNCTIONNAME, FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE)

#define CLASS_MEMBER_METHOD_RENAME(EXPECTEDNAME, FUNCTIONNAME, PARAMETERNAMES)\
			CLASS_MEMBER_METHOD_OVERLOAD_RENAME(EXPECTEDNAME, FUNCTIONNAME, PARAMETERNAMES, decltype(&ClassType::FUNCTIONNAME))

#define CLASS_MEMBER_METHOD(FUNCTIONNAME, PARAMETERNAMES)\
			CLASS_MEMBER_METHOD_OVERLOAD(FUNCTIONNAME, PARAMETERNAMES, decltype(&ClassType::FUNCTIONNAME))

/***********************************************************************
Static Method
***********************************************************************/

#define CLASS_MEMBER_STATIC_EXTERNALMETHOD(FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE, SOURCE)\
			{\
				const wchar_t* parameterNames[]=PARAMETERNAMES;\
				AddMethod(\
					L#FUNCTIONNAME,\
					new CustomMethodInfoImplSelector<\
						void,\
						vl::function_lambda::FunctionObjectRetriveType<FUNCTIONTYPE>::FunctionType\
						>\
						::CustomMethodInfoImpl(parameterNames, SOURCE)\
					);\
			}

#define CLASS_MEMBER_STATIC_METHOD_OVERLOAD(FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE)\
			CLASS_MEMBER_STATIC_EXTERNALMETHOD(FUNCTIONNAME, PARAMETERNAMES, FUNCTIONTYPE, (FUNCTIONTYPE)&ClassType::FUNCTIONNAME)

#define CLASS_MEMBER_STATIC_METHOD(FUNCTIONNAME, PARAMETERNAMES)\
			CLASS_MEMBER_STATIC_METHOD_OVERLOAD(FUNCTIONNAME, PARAMETERNAMES, decltype(&ClassType::FUNCTIONNAME))

/***********************************************************************
Property
***********************************************************************/

#define CLASS_MEMBER_PROPERTY_READONLY(PROPERTYNAME, GETTER)\
			AddProperty(\
				new PropertyInfoImpl(\
					this,\
					L#PROPERTYNAME,\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#GETTER, true)->GetMethod(0)),\
					0,\
					0\
					)\
				);

#define CLASS_MEMBER_PROPERTY(PROPERTYNAME, GETTER, SETTER)\
			AddProperty(\
				new PropertyInfoImpl(\
					this,\
					L#PROPERTYNAME,\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#GETTER, true)->GetMethod(0)),\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#SETTER, true)->GetMethod(0)),\
					0\
					)\
				);

#define CLASS_MEMBER_PROPERTY_EVENT(PROPERTYNAME, GETTER, SETTER, EVENT)\
			AddProperty(\
				new PropertyInfoImpl(\
					this,\
					L#PROPERTYNAME,\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#GETTER, true)->GetMethod(0)),\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#SETTER, true)->GetMethod(0)),\
					dynamic_cast<EventInfoImpl*>(GetEventByName(L#EVENT, true))\
					)\
				);

#define CLASS_MEMBER_PROPERTY_EVENT_READONLY(PROPERTYNAME, GETTER, EVENT)\
			AddProperty(\
				new PropertyInfoImpl(\
					this,\
					L#PROPERTYNAME,\
					dynamic_cast<MethodInfoImpl*>(GetMethodGroupByName(L#GETTER, true)->GetMethod(0)),\
					0,\
					dynamic_cast<EventInfoImpl*>(GetEventByName(L#EVENT, true))\
					)\
				);

#define CLASS_MEMBER_PROPERTY_READONLY_FAST(PROPERTYNAME)\
			CLASS_MEMBER_METHOD(Get##PROPERTYNAME, NO_PARAMETER)\
			CLASS_MEMBER_PROPERTY_READONLY(PROPERTYNAME, Get##PROPERTYNAME)\

#define CLASS_MEMBER_PROPERTY_FAST(PROPERTYNAME)\
			CLASS_MEMBER_METHOD(Get##PROPERTYNAME, NO_PARAMETER)\
			CLASS_MEMBER_METHOD(Set##PROPERTYNAME, {L"value"})\
			CLASS_MEMBER_PROPERTY(PROPERTYNAME, Get##PROPERTYNAME, Set##PROPERTYNAME)\

#define CLASS_MEMBER_PROPERTY_EVENT_FAST(PROPERTYNAME, EVENTNAME)\
			CLASS_MEMBER_METHOD(Get##PROPERTYNAME, NO_PARAMETER)\
			CLASS_MEMBER_METHOD(Set##PROPERTYNAME, {L"value"})\
			CLASS_MEMBER_PROPERTY_EVENT(PROPERTYNAME, Get##PROPERTYNAME, Set##PROPERTYNAME, EVENTNAME)\

#define CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(PROPERTYNAME, EVENTNAME)\
			CLASS_MEMBER_METHOD(Get##PROPERTYNAME, NO_PARAMETER)\
			CLASS_MEMBER_PROPERTY_EVENT_READONLY(PROPERTYNAME, Get##PROPERTYNAME, EVENTNAME)\

		}
	}
}

#endif

/***********************************************************************
PARSING\PARSING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Parser

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSING
#define VCZH_PARSING_PARSING


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
语法分析器通用策略
***********************************************************************/

			class ParsingGeneralParser : public Object
			{
			protected:
				Ptr<ParsingTable>							table;
				
			public:
				ParsingGeneralParser(Ptr<ParsingTable> _table);
				~ParsingGeneralParser();
				
				Ptr<ParsingTable>							GetTable();
				virtual void								BeginParse();
				virtual ParsingState::TransitionResult		ParseStep(ParsingState& state, collections::List<Ptr<ParsingError>>& errors)=0;
				bool										Parse(ParsingState& state, ParsingTransitionProcessor& processor, collections::List<Ptr<ParsingError>>& errors);
				Ptr<ParsingTreeNode>						Parse(ParsingState& state, collections::List<Ptr<ParsingError>>& errors);
				Ptr<ParsingTreeNode>						Parse(const WString& input, const WString& rule, collections::List<Ptr<ParsingError>>& errors);
			};

/***********************************************************************
语法分析器策略
***********************************************************************/

			class ParsingStrictParser : public ParsingGeneralParser
			{
			protected:

				virtual ParsingState::TransitionResult		OnErrorRecover(ParsingState& state, vint currentTokenIndex, const regex::RegexToken* currentToken, collections::List<Ptr<ParsingError>>& errors);
			public:
				ParsingStrictParser(Ptr<ParsingTable> _table=0);
				~ParsingStrictParser();
				
				ParsingState::TransitionResult				ParseStep(ParsingState& state, collections::List<Ptr<ParsingError>>& errors)override;
			};

			class ParsingAutoRecoverParser : public ParsingStrictParser
			{
			protected:
				collections::Array<ParsingState::Future>	recoverFutures;
				vint										recoveringFutureIndex;

				ParsingState::TransitionResult				OnErrorRecover(ParsingState& state, vint currentTokenIndex, const regex::RegexToken* currentToken, collections::List<Ptr<ParsingError>>& errors)override;
			public:
				ParsingAutoRecoverParser(Ptr<ParsingTable> _table=0);
				~ParsingAutoRecoverParser();
			};

			class ParsingAmbiguousParser : public ParsingGeneralParser
			{
				typedef collections::List<ParsingState::TransitionResult>		DecisionList;
			protected:

				DecisionList								decisions;
				vint										consumedDecisionCount;

				virtual void								OnErrorRecover(ParsingState& state, vint currentTokenIndex, const regex::RegexToken* currentToken, collections::List<ParsingState::Future*>& futures, vint& begin, vint& end, vint& insertedTokenCount, vint& skippedTokenCount, collections::List<Ptr<ParsingError>>& errors);
				vint										GetResolvableFutureLevels(collections::List<ParsingState::Future*>& futures, vint begin, vint end);
				vint										SearchPathForOneStep(ParsingState& state, collections::List<ParsingState::Future*>& futures, collections::List<regex::RegexToken*>& tokens, vint& begin, vint& end, collections::List<Ptr<ParsingError>>& errors);
				vint										GetConflictReduceCount(collections::List<ParsingState::Future*>& futures);
				void										GetConflictReduceIndices(collections::List<ParsingState::Future*>& futures, vint conflictReduceCount, collections::Array<vint>& conflictReduceIndices);
				vint										GetAffectedStackNodeCount(collections::List<ParsingState::Future*>& futures, collections::Array<vint>& conflictReduceIndices);
				void										BuildSingleDecisionPath(ParsingState& state, ParsingState::Future* future, collections::List<regex::RegexToken*>& tokens, vint availableTokenCount, vint lastAvailableInstructionCount);
				void										BuildAmbiguousDecisions(ParsingState& state, collections::List<ParsingState::Future*>& futures, collections::List<regex::RegexToken*>& tokens, vint begin, vint end, vint resolvableFutureLevels, collections::List<Ptr<ParsingError>>& errors);
				void										BuildDecisions(ParsingState& state, collections::List<ParsingState::Future*>& futures, collections::List<regex::RegexToken*>& tokens, vint begin, vint end, vint resolvableFutureLevels, collections::List<Ptr<ParsingError>>& errors);
			public:
				ParsingAmbiguousParser(Ptr<ParsingTable> _table=0);
				~ParsingAmbiguousParser();
				
				ParsingState::TransitionResult				ParseStep(ParsingState& state, collections::List<Ptr<ParsingError>>& errors)override;
				void										BeginParse()override;
			};

			class ParsingAutoRecoverAmbiguousParser : public ParsingAmbiguousParser
			{
			protected:

				void										OnErrorRecover(ParsingState& state, vint currentTokenIndex, const regex::RegexToken* currentToken, collections::List<ParsingState::Future*>& futures, vint& begin, vint& end, vint& insertedTokenCount, vint& skippedTokenCount, collections::List<Ptr<ParsingError>>& errors)override;
			public:
				ParsingAutoRecoverAmbiguousParser(Ptr<ParsingTable> _table=0);
				~ParsingAutoRecoverAmbiguousParser();
			};

/***********************************************************************
辅助函数
***********************************************************************/
			
			extern Ptr<ParsingGeneralParser>				CreateStrictParser(Ptr<ParsingTable> table);
			extern Ptr<ParsingGeneralParser>				CreateAutoRecoverParser(Ptr<ParsingTable> table);
			extern Ptr<ParsingGeneralParser>				CreateBootstrapStrictParser();
			extern Ptr<ParsingGeneralParser>				CreateBootstrapAutoRecoverParser();
		}
	}
}

/***********************************************************************
反射
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION


namespace vl
{
	namespace reflection
	{
		namespace description
		{
#define PARSINGREFLECTION_TYPELIST(F)\
			F(parsing::ParsingTextPos)\
			F(parsing::ParsingTextRange)\
			F(parsing::ParsingTreeNode)\
			F(parsing::ParsingTreeToken)\
			F(parsing::ParsingTreeObject)\
			F(parsing::ParsingTreeArray)\
			F(parsing::ParsingScope)\
			F(parsing::ParsingScopeSymbol)\
			F(parsing::ParsingScopeFinder)\

			PARSINGREFLECTION_TYPELIST(DECL_TYPE_INFO)
		}
	}
}

#endif

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			extern bool								LoadParsingTypes();
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGDEFINITIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Definitions

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGDEFINITIONS
#define VCZH_PARSING_PARSINGDEFINITIONS


namespace vl
{
	namespace parsing
	{
		namespace definitions
		{

/***********************************************************************
属性标记
***********************************************************************/

			class ParsingDefinitionAttribute : public ParsingTreeCustomBase
			{
			public:
				WString											name;
				collections::List<WString>						arguments;
			};

			class ParsingDefinitionBase : public ParsingTreeCustomBase
			{
				typedef collections::List<Ptr<ParsingDefinitionAttribute>>				AttributeList;
			public:
				AttributeList									attributes;
			};

/***********************************************************************
类型结构
***********************************************************************/

			class ParsingDefinitionPrimitiveType;
			class ParsingDefinitionTokenType;
			class ParsingDefinitionSubType;
			class ParsingDefinitionArrayType;

			class ParsingDefinitionType : public ParsingTreeCustomBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionPrimitiveType* node)=0;
					virtual void								Visit(ParsingDefinitionTokenType* node)=0;
					virtual void								Visit(ParsingDefinitionSubType* node)=0;
					virtual void								Visit(ParsingDefinitionArrayType* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			};

			class ParsingDefinitionPrimitiveType : public ParsingDefinitionType
			{
			public:
				WString											name;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionTokenType : public ParsingDefinitionType
			{
			public:

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSubType : public ParsingDefinitionType
			{
			public:
				Ptr<ParsingDefinitionType>						parentType;
				WString											subTypeName;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionArrayType : public ParsingDefinitionType
			{
			public:
				Ptr<ParsingDefinitionType>						elementType;

				void											Accept(IVisitor* visitor)override;
			};

/***********************************************************************
类型定义
***********************************************************************/

			class ParsingDefinitionClassMemberDefinition;
			class ParsingDefinitionClassDefinition;
			class ParsingDefinitionEnumMemberDefinition;
			class ParsingDefinitionEnumDefinition;

			class ParsingDefinitionTypeDefinition : public ParsingDefinitionBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionClassMemberDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionClassDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionEnumMemberDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionEnumDefinition* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			public:
				WString											name;
			};

			class ParsingDefinitionClassMemberDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				Ptr<ParsingDefinitionType>						type;
				WString											unescapingFunction;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionClassDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				typedef collections::List<Ptr<ParsingDefinitionClassMemberDefinition>>	MemberList;
				typedef collections::List<Ptr<ParsingDefinitionTypeDefinition>>			TypeList;

				Ptr<ParsingDefinitionType>						ambiguousType;
				Ptr<ParsingDefinitionType>						parentType;
				MemberList										members;
				TypeList										subTypes;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionEnumMemberDefinition : public ParsingDefinitionTypeDefinition
			{
			public:

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionEnumDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				typedef collections::List<Ptr<ParsingDefinitionEnumMemberDefinition>>	MemberList;

				MemberList										members;

				void											Accept(IVisitor* visitor)override;
			};

/***********************************************************************
文法规则
***********************************************************************/

			class ParsingDefinitionPrimitiveGrammar;
			class ParsingDefinitionTextGrammar;
			class ParsingDefinitionSequenceGrammar;
			class ParsingDefinitionAlternativeGrammar;
			class ParsingDefinitionLoopGrammar;
			class ParsingDefinitionOptionalGrammar;
			class ParsingDefinitionCreateGrammar;
			class ParsingDefinitionAssignGrammar;
			class ParsingDefinitionUseGrammar;
			class ParsingDefinitionSetterGrammar;

			class ParsingDefinitionGrammar : public ParsingTreeCustomBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionPrimitiveGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionTextGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionSequenceGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionAlternativeGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionLoopGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionOptionalGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionCreateGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionAssignGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionUseGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionSetterGrammar* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			};

			class ParsingDefinitionPrimitiveGrammar : public ParsingDefinitionGrammar
			{
			public:
				WString											name;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionTextGrammar : public ParsingDefinitionGrammar
			{
			public:
				WString											text;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSequenceGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					first;
				Ptr<ParsingDefinitionGrammar>					second;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionAlternativeGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					first;
				Ptr<ParsingDefinitionGrammar>					second;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionLoopGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionOptionalGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionCreateGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				Ptr<ParsingDefinitionType>						type;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionAssignGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				WString											memberName;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionUseGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSetterGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				WString											memberName;
				WString											value;

				void											Accept(IVisitor* visitor)override;
			};

/***********************************************************************
文法结构
***********************************************************************/

			class ParsingDefinitionTokenDefinition : public ParsingDefinitionBase
			{
			public:
				WString											name;
				WString											regex;
				bool											discard;
			};

			class ParsingDefinitionRuleDefinition : public ParsingDefinitionBase
			{
			public:
				WString															name;
				Ptr<ParsingDefinitionType>										type;
				collections::List<Ptr<ParsingDefinitionGrammar>>				grammars;
			};

			class ParsingDefinition : public ParsingTreeCustomBase
			{
			public:
				collections::List<Ptr<ParsingDefinitionTypeDefinition>>			types;
				collections::List<Ptr<ParsingDefinitionTokenDefinition>>		tokens;
				collections::List<Ptr<ParsingDefinitionRuleDefinition>>			rules;
			};

/***********************************************************************
构造器（属性标记）
***********************************************************************/

			class ParsingDefinitionAttributeWriter : public Object
			{
				friend ParsingDefinitionAttributeWriter			Attribute(const WString& name);
			protected:
				Ptr<ParsingDefinitionAttribute>					attribute;

				ParsingDefinitionAttributeWriter(const WString& name);
			public:
				ParsingDefinitionAttributeWriter(const ParsingDefinitionAttributeWriter& attributeWriter);

				ParsingDefinitionAttributeWriter&				Argument(const WString& argument);
				Ptr<ParsingDefinitionAttribute>					Attribute()const;
			};

			extern ParsingDefinitionAttributeWriter				Attribute(const WString& name);

/***********************************************************************
构造器（类型结构）
***********************************************************************/

			class ParsingDefinitionTypeWriter : public Object
			{
				friend ParsingDefinitionTypeWriter				Type(const WString& name);
				friend ParsingDefinitionTypeWriter				TokenType();
			protected:
				Ptr<ParsingDefinitionType>						type;

				ParsingDefinitionTypeWriter(Ptr<ParsingDefinitionType> internalType);
				ParsingDefinitionTypeWriter(const WString& name);
			public:
				ParsingDefinitionTypeWriter(const ParsingDefinitionTypeWriter& typeWriter);

				ParsingDefinitionTypeWriter						Sub(const WString& subTypeName)const;
				ParsingDefinitionTypeWriter						Array()const;
				Ptr<ParsingDefinitionType>						Type()const;
			};

			extern ParsingDefinitionTypeWriter					Type(const WString& name);
			extern ParsingDefinitionTypeWriter					TokenType();

/***********************************************************************
构造器（类型定义）
***********************************************************************/

			class ParsingDefinitionTypeDefinitionWriter : public Object
			{
			public:
				virtual Ptr<ParsingDefinitionTypeDefinition>	Definition()const=0;
			};

			class ParsingDefinitionClassDefinitionWriter : public ParsingDefinitionTypeDefinitionWriter
			{
			protected:
				Ptr<ParsingDefinitionBase>						currentDefinition;
				Ptr<ParsingDefinitionClassDefinition>			definition;

			public:
				ParsingDefinitionClassDefinitionWriter(const WString& name);
				ParsingDefinitionClassDefinitionWriter(const WString& name, const ParsingDefinitionTypeWriter& parentType);

				ParsingDefinitionClassDefinitionWriter&			AmbiguousType(const ParsingDefinitionTypeWriter& ambiguousType);
				ParsingDefinitionClassDefinitionWriter&			Member(const WString& name, const ParsingDefinitionTypeWriter& type, const WString& unescapingFunction=L"");
				ParsingDefinitionClassDefinitionWriter&			SubType(const ParsingDefinitionTypeDefinitionWriter& type);
				ParsingDefinitionClassDefinitionWriter&			Attribute(const ParsingDefinitionAttributeWriter& attribute);

				Ptr<ParsingDefinitionTypeDefinition>			Definition()const override;
			};
			
			extern ParsingDefinitionClassDefinitionWriter		Class(const WString& name);
			extern ParsingDefinitionClassDefinitionWriter		Class(const WString& name, const ParsingDefinitionTypeWriter& parentType);

			class ParsingDefinitionEnumDefinitionWriter : public ParsingDefinitionTypeDefinitionWriter
			{
			protected:
				Ptr<ParsingDefinitionBase>						currentDefinition;
				Ptr<ParsingDefinitionEnumDefinition>			definition;

			public:
				ParsingDefinitionEnumDefinitionWriter(const WString& name);

				ParsingDefinitionEnumDefinitionWriter&			Member(const WString& name);
				ParsingDefinitionEnumDefinitionWriter&			Attribute(const ParsingDefinitionAttributeWriter& attribute);

				Ptr<ParsingDefinitionTypeDefinition>			Definition()const override;
			};

			extern ParsingDefinitionEnumDefinitionWriter		Enum(const WString& name);

/***********************************************************************
构造器（文法规则）
***********************************************************************/

			class ParsingDefinitionGrammarWriter : public Object
			{
				friend ParsingDefinitionGrammarWriter			Rule(const WString& name);
				friend ParsingDefinitionGrammarWriter			Text(const WString& name);
				friend ParsingDefinitionGrammarWriter			Opt(const ParsingDefinitionGrammarWriter& writer);
			protected:
				Ptr<ParsingDefinitionGrammar>					grammar;

				ParsingDefinitionGrammarWriter(Ptr<ParsingDefinitionGrammar> internalGrammar);
			public:
				ParsingDefinitionGrammarWriter(const ParsingDefinitionGrammarWriter& grammarWriter);

				ParsingDefinitionGrammarWriter					operator+(const ParsingDefinitionGrammarWriter& next)const;
				ParsingDefinitionGrammarWriter					operator|(const ParsingDefinitionGrammarWriter& next)const;
				ParsingDefinitionGrammarWriter					operator*()const;
				ParsingDefinitionGrammarWriter					As(const ParsingDefinitionTypeWriter& type)const;
				ParsingDefinitionGrammarWriter					operator[](const WString& memberName)const;
				ParsingDefinitionGrammarWriter					operator!()const;
				ParsingDefinitionGrammarWriter					Set(const WString& memberName, const WString& value)const;

				Ptr<ParsingDefinitionGrammar>					Grammar()const;
			};

			extern ParsingDefinitionGrammarWriter				Rule(const WString& name);
			extern ParsingDefinitionGrammarWriter				Text(const WString& text);
			extern ParsingDefinitionGrammarWriter				Opt(const ParsingDefinitionGrammarWriter& writer);

/***********************************************************************
构造器（文法结构）
***********************************************************************/

			class ParsingDefinitionWriter;

			class ParsingDefinitionTokenDefinitionWriter : public Object
			{
			protected:
				Ptr<ParsingDefinitionTokenDefinition>			token;
				ParsingDefinitionWriter&						owner;
			public:
				ParsingDefinitionTokenDefinitionWriter(ParsingDefinitionWriter& _owner, Ptr<ParsingDefinitionTokenDefinition> _token);

				ParsingDefinitionTokenDefinitionWriter&			Attribute(const ParsingDefinitionAttributeWriter& attribute);
				ParsingDefinitionWriter&						EndToken();
			};

			class ParsingDefinitionRuleDefinitionWriter : public Object
			{
			protected:
				Ptr<ParsingDefinitionRuleDefinition>			rule;
				ParsingDefinitionWriter&						owner;
			public:
				ParsingDefinitionRuleDefinitionWriter(ParsingDefinitionWriter& _owner, Ptr<ParsingDefinitionRuleDefinition> _rule);

				ParsingDefinitionRuleDefinitionWriter&			Imply(const ParsingDefinitionGrammarWriter& grammar);
				ParsingDefinitionRuleDefinitionWriter&			Attribute(const ParsingDefinitionAttributeWriter& attribute);
				ParsingDefinitionWriter&						EndRule();
			};

			class ParsingDefinitionWriter : public Object
			{
			protected:
				Ptr<ParsingDefinition>							definition;

			public:
				ParsingDefinitionWriter();

				ParsingDefinitionWriter&						Type(const ParsingDefinitionTypeDefinitionWriter& type);
				ParsingDefinitionWriter&						Token(const WString& name, const WString& regex);
				ParsingDefinitionTokenDefinitionWriter			TokenAtt(const WString& name, const WString& regex);
				ParsingDefinitionWriter&						Discard(const WString& name, const WString& regex);
				ParsingDefinitionRuleDefinitionWriter			Rule(const WString& name, const ParsingDefinitionTypeWriter& type);

				Ptr<ParsingDefinition>							Definition()const;
			};

/***********************************************************************
辅助函数
***********************************************************************/

			extern WString										TypeToString(ParsingDefinitionType* type);
			extern WString										GrammarToString(ParsingDefinitionGrammar* grammar);
			extern WString										GrammarStateToString(ParsingDefinitionGrammar* grammar, ParsingDefinitionGrammar* stateNode, bool beforeNode);
			extern ParsingDefinitionGrammar*					FindAppropriateGrammarState(ParsingDefinitionGrammar* grammar, ParsingDefinitionGrammar* stateNode, bool beforeNode);
			extern void											Log(Ptr<ParsingDefinition> definition, stream::TextWriter& writer);
			extern WString										DeserializeString(const WString& value);
			extern WString										SerializeString(const WString& value);

/***********************************************************************
自举
***********************************************************************/
			
			extern Ptr<ParsingDefinition>						CreateParserDefinition();
			extern Ptr<ParsingDefinition>						DeserializeDefinition(Ptr<ParsingTreeNode> node);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGANALYZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Analyzing

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGANALYZER
#define VCZH_PARSING_PARSINGANALYZER


namespace vl
{
	namespace parsing
	{
		namespace analyzing
		{

/***********************************************************************
符号表关联对象
***********************************************************************/

			class ParsingSymbol;

			struct DefinitionTypeScopePair
			{
				definitions::ParsingDefinitionType*		type;
				ParsingSymbol*							scope;

				DefinitionTypeScopePair()
				{
				}

				DefinitionTypeScopePair(definitions::ParsingDefinitionType* _type, ParsingSymbol* _scope)
					:type(_type)
					,scope(_scope)
				{
				}

				vint Compare(const DefinitionTypeScopePair& pair)
				{
					if(type<pair.type) return -1;
					if(type>pair.type) return 1;
					if(scope<pair.scope) return -1;
					if(scope>pair.scope) return 1;
					return 0;
				}

				bool operator==(const DefinitionTypeScopePair& pair){return Compare(pair)==0;}
				bool operator!=(const DefinitionTypeScopePair& pair){return Compare(pair)!=0;}
				bool operator>(const DefinitionTypeScopePair& pair){return Compare(pair)>0;}
				bool operator>=(const DefinitionTypeScopePair& pair){return Compare(pair)>=0;}
				bool operator<(const DefinitionTypeScopePair& pair){return Compare(pair)<0;}
				bool operator<=(const DefinitionTypeScopePair& pair){return Compare(pair)<=0;}
			};

/***********************************************************************
符号表
***********************************************************************/

			class ParsingSymbol : public Object
			{
				friend class ParsingSymbolManager;

				typedef collections::Dictionary<WString, ParsingSymbol*>		ParsingSymbolMap;
				typedef collections::List<ParsingSymbol*>						ParsingSymbolList;
			public:
				enum SymbolType
				{
					Global,
					EnumType,
					ClassType,		// descriptor == base type
					ArrayType,		// descriptor == element type
					TokenType,
					EnumItem,		// descriptor == parent
					ClassField,		// descriptor == field type
					TokenDef,		// descriptor == token type
					RuleDef,		// descriptor == rule type
				};

			protected:
				ParsingSymbolManager*			manager;
				SymbolType						type;
				WString							name;
				ParsingSymbol*					descriptorSymbol;
				WString							descriptorString;
				ParsingSymbol*					parentSymbol;
				ParsingSymbol*					arrayTypeSymbol;
				ParsingSymbolList				subSymbolList;
				ParsingSymbolMap				subSymbolMap;

				bool							AddSubSymbol(ParsingSymbol* subSymbol);

				ParsingSymbol(ParsingSymbolManager* _manager, SymbolType _type, const WString& _name, ParsingSymbol* _descriptorSymbol, const WString& _descriptorString);
			public:
				~ParsingSymbol();

				ParsingSymbolManager*			GetManager();
				SymbolType						GetType();
				const WString&					GetName();
				vint							GetSubSymbolCount();
				ParsingSymbol*					GetSubSymbol(vint index);
				ParsingSymbol*					GetSubSymbolByName(const WString& name);
				ParsingSymbol*					GetDescriptorSymbol();
				WString							GetDescriptorString();
				ParsingSymbol*					GetParentSymbol();
				bool							IsType();
				ParsingSymbol*					SearchClassSubSymbol(const WString& name);
				ParsingSymbol*					SearchCommonBaseClass(ParsingSymbol* classType);
			};

			class ParsingSymbolManager : public Object
			{
				typedef definitions::ParsingDefinitionClassDefinition												ClassDefinition;
				typedef collections::List<Ptr<ParsingSymbol>>														ParsingSymbolList;
				typedef collections::Dictionary<DefinitionTypeScopePair, ParsingSymbol*>							DefinitionTypeSymbolMap;
				typedef collections::Dictionary<definitions::ParsingDefinitionGrammar*, ParsingSymbol*>				DefinitionGrammarSymbolMap;
				typedef collections::Dictionary<ParsingSymbol*, ClassDefinition*>									SymbolClassDefinitionMap;
				typedef collections::Dictionary<ClassDefinition*, ParsingSymbol*>									ClassDefinitionSymbolMap;
			protected:
				ParsingSymbol*					globalSymbol;
				ParsingSymbol*					tokenTypeSymbol;
				ParsingSymbolList				createdSymbols;
				DefinitionTypeSymbolMap			definitionTypeSymbolCache;
				DefinitionGrammarSymbolMap		definitionGrammarSymbolCache;
				DefinitionGrammarSymbolMap		definitionGrammarTypeCache;
				SymbolClassDefinitionMap		symbolClassDefinitionCache;
				ClassDefinitionSymbolMap		classDefinitionSymbolCache;

				bool							TryAddSubSymbol(Ptr<ParsingSymbol> subSymbol, ParsingSymbol* parentSymbol);
			public:
				ParsingSymbolManager();
				~ParsingSymbolManager();

				ParsingSymbol*					GetGlobal();
				ParsingSymbol*					GetTokenType();
				ParsingSymbol*					GetArrayType(ParsingSymbol* elementType);

				ParsingSymbol*					AddClass(definitions::ParsingDefinitionClassDefinition* classDef, ParsingSymbol* baseType, ParsingSymbol* parentType=0);
				ParsingSymbol*					AddField(const WString& name, ParsingSymbol* classType, ParsingSymbol* fieldType);
				ParsingSymbol*					AddEnum(const WString& name, ParsingSymbol* parentType=0);
				ParsingSymbol*					AddEnumItem(const WString& name, ParsingSymbol* enumType);
				ParsingSymbol*					AddTokenDefinition(const WString& name, const WString& regex);
				ParsingSymbol*					AddRuleDefinition(const WString& name, ParsingSymbol* ruleType);

				ClassDefinition*				CacheGetClassDefinition(ParsingSymbol* type);
				ParsingSymbol*					CacheGetClassType(ClassDefinition* type);
				ParsingSymbol*					CacheGetType(definitions::ParsingDefinitionType* type, ParsingSymbol* scope);
				bool							CacheSetType(definitions::ParsingDefinitionType* type, ParsingSymbol* scope, ParsingSymbol* symbol);
				ParsingSymbol*					CacheGetSymbol(definitions::ParsingDefinitionGrammar* grammar);
				bool							CacheSetSymbol(definitions::ParsingDefinitionGrammar* grammar, ParsingSymbol* symbol);
				ParsingSymbol*					CacheGetType(definitions::ParsingDefinitionGrammar* grammar);
				bool							CacheSetType(definitions::ParsingDefinitionGrammar* grammar, ParsingSymbol* type);
			};

/***********************************************************************
语义分析
***********************************************************************/

			extern WString						GetTypeFullName(ParsingSymbol* type);
			extern ParsingSymbol*				FindType(definitions::ParsingDefinitionType* type, ParsingSymbolManager* manager, ParsingSymbol* scope, collections::List<Ptr<ParsingError>>& errors);
			extern void							PrepareSymbols(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ValidateRuleStructure(Ptr<definitions::ParsingDefinition> definition, Ptr<definitions::ParsingDefinitionRuleDefinition> rule, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ResolveRuleSymbols(Ptr<definitions::ParsingDefinitionRuleDefinition> rule, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ResolveSymbols(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ValidateDefinition(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGAUTOMATON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Automaton

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGAUTOMATON
#define VCZH_PARSING_PARSINGAUTOMATON


namespace vl
{
	namespace parsing
	{
		namespace analyzing
		{

/***********************************************************************
状态机
***********************************************************************/

			class Action;
			class Transition;
			class State;

			class Action : public Object
			{
			public:
				enum ActionType
				{
					Create, // new source
					Assign, // source ::= <created symbol>
					Using,  // use <created symbol>
					Setter, // source ::= target
					Shift,
					Reduce,
					LeftRecursiveReduce,
				};

				ActionType											actionType;
				ParsingSymbol*										actionTarget;
				ParsingSymbol*										actionSource;
				definitions::ParsingDefinitionRuleDefinition*		creatorRule;

				// the following two fields record which rule symbol transition generate this shift/reduce action
				State*												shiftReduceSource;
				State*												shiftReduceTarget;

				Action();
				~Action();
			};

			class Transition : public Object
			{
			public:
				enum TransitionType
				{
					TokenBegin,		// token stream start
					TokenFinish,	// token stream end
					TryReduce,		// rule end
					Epsilon,		// an epsilon transition
					Symbol,			// a syntax symbol
				};

				enum StackOperationType
				{
					None,
					ShiftReduceCompacted,
					LeftRecursive,
				};

				State*												source;
				State*												target;
				collections::List<Ptr<Action>>						actions;
				
				TransitionType										transitionType;
				StackOperationType									stackOperationType;
				ParsingSymbol*										transitionSymbol;

				Transition();
				~Transition();

				static bool											IsEquivalent(Transition* t1, Transition* t2, bool careSourceAndTarget);
			};

			class State : public Object
			{
			public:
				enum StatePosition
				{
					BeforeNode,
					AfterNode,
				};

				collections::List<Transition*>						transitions;
				collections::List<Transition*>						inputs;
				bool												endState;

				ParsingSymbol*										ownerRuleSymbol;
				definitions::ParsingDefinitionRuleDefinition*		ownerRule;
				definitions::ParsingDefinitionGrammar*				grammarNode;
				definitions::ParsingDefinitionGrammar*				stateNode;
				StatePosition										statePosition;
				WString												stateName;
				WString												stateExpression;

				State();
				~State();
			};

			class RuleInfo : public Object
			{
			public:
				State*												rootRuleStartState;
				State*												rootRuleEndState;
				State*												startState;
				collections::List<State*>							endStates;
				int													stateNameCount;

				RuleInfo();
				~RuleInfo();
			};

			class Automaton : public Object
			{
				typedef collections::Dictionary<definitions::ParsingDefinitionRuleDefinition*, Ptr<RuleInfo>>		RuleInfoMap;
			public:
				ParsingSymbolManager*								symbolManager;
				collections::List<Ptr<Transition>>					transitions;
				collections::List<Ptr<State>>						states;
				RuleInfoMap											ruleInfos;

				Automaton(ParsingSymbolManager* _symbolManager);
				~Automaton();

				State*												RuleStartState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												RootRuleStartState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												RootRuleEndState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												StartState(definitions::ParsingDefinitionRuleDefinition* ownerRule, definitions::ParsingDefinitionGrammar* grammarNode, definitions::ParsingDefinitionGrammar* stateNode);
				State*												EndState(definitions::ParsingDefinitionRuleDefinition* ownerRule, definitions::ParsingDefinitionGrammar* grammarNode, definitions::ParsingDefinitionGrammar* stateNode);
				State*												CopyState(State* oldState);

				Transition*											CreateTransition(State* start, State* end);
				Transition*											TokenBegin(State* start, State* end);
				Transition*											TokenFinish(State* start, State* end);
				Transition*											TryReduce(State* start, State* end);
				Transition*											Epsilon(State* start, State* end);
				Transition*											Symbol(State* start, State* end, ParsingSymbol* transitionSymbol);
				Transition*											CopyTransition(State* start, State* end, Transition* oldTransition);

				void												DeleteTransition(Transition* transition);
				void												DeleteState(State* state);
			};

/***********************************************************************
辅助函数（搜索闭包）
***********************************************************************/

			struct ClosureItem
			{
				enum SearchResult
				{
					Continue,
					Hit,
					Blocked,
				};

				State*											state;			// target state of one path of a closure
				Ptr<collections::List<Transition*>>				transitions;	// path
				bool											cycle;			// true: invalid closure because there are cycles, and in the middle of the path there will be a transition that targets to the state field.

				ClosureItem()
					:state(0)
					,cycle(false)
				{
				}

				ClosureItem(State* _state, Ptr<collections::List<Transition*>> _transitions, bool _cycle)
					:state(_state)
					,transitions(_transitions)
					,cycle(_cycle)
				{
				}
			};

			extern void												SearchClosure(ClosureItem::SearchResult(*closurePredicate)(Transition*), State* startState, collections::List<ClosureItem>& closure);
			extern void												RemoveEpsilonTransitions(collections::Dictionary<State*, State*>& oldNewStateMap, collections::List<State*>& scanningStates, Ptr<Automaton> automaton);

/***********************************************************************
辅助函数（合并状态）
***********************************************************************/
			
			extern void												DeleteUnnecessaryStates(Ptr<Automaton> automaton, Ptr<RuleInfo> ruleInfo, collections::List<State*>& newStates);
			extern void												MergeStates(Ptr<Automaton> automaton, Ptr<RuleInfo> ruleInfo, collections::List<State*>& newStates);

/***********************************************************************
辅助函数（创建状态机）
***********************************************************************/
			
			extern Ptr<Automaton>									CreateEpsilonPDA(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager);
			extern Ptr<Automaton>									CreateNondeterministicPDAFromEpsilonPDA(Ptr<Automaton> epsilonPDA);
			extern Ptr<Automaton>									CreateJointPDAFromNondeterministicPDA(Ptr<Automaton> nondeterministicPDA);
			extern void												CompactJointPDA(Ptr<Automaton> jointPDA);
			extern void												MergeJointPDAStates(Ptr<Automaton> jointPDA);
			extern void												MarkLeftRecursiveInJointPDA(Ptr<Automaton> jointPDA, collections::List<Ptr<ParsingError>>& errors);

/***********************************************************************
辅助函数（输出跳转表）
***********************************************************************/

			extern WString											GetTypeNameForCreateInstruction(ParsingSymbol* type);
			extern Ptr<tabling::ParsingTable>						GenerateTableFromPDA(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, Ptr<Automaton> jointPDA, bool enableAmbiguity, collections::List<Ptr<ParsingError>>& errors);
			extern Ptr<tabling::ParsingTable>						GenerateTable(Ptr<definitions::ParsingDefinition> definition, bool enableAmbiguity, collections::List<Ptr<ParsingError>>& errors);
			extern void												Log(Ptr<Automaton> automaton, stream::TextWriter& writer);
		}
	}
}

#endif

/***********************************************************************
PARSING\JSON\PARSINGJSON_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingJson_Parser

本文件使用Vczh Parsing Generator工具自动生成
***********************************************************************/

#ifndef VCZH_PARSING_JSON_PARSINGJSON_PARSER
#define VCZH_PARSING_JSON_PARSINGJSON_PARSER


namespace vl
{
	namespace parsing
	{
		namespace json
		{
			struct JsonParserTokenIndex abstract
			{
				static const vl::vint TRUEVALUE = 0;
				static const vl::vint FALSEVALUE = 1;
				static const vl::vint NULLVALUE = 2;
				static const vl::vint OBJOPEN = 3;
				static const vl::vint OBJCLOSE = 4;
				static const vl::vint ARROPEN = 5;
				static const vl::vint ARRCLOSE = 6;
				static const vl::vint COMMA = 7;
				static const vl::vint COLON = 8;
				static const vl::vint NUMBER = 9;
				static const vl::vint STRING = 10;
				static const vl::vint SPACE = 11;
			};
			class JsonNode;
			class JsonLiteral;
			class JsonString;
			class JsonNumber;
			class JsonArray;
			class JsonObjectField;
			class JsonObject;

			class JsonNode abstract : public vl::parsing::ParsingTreeCustomBase
			{
			public:
				class IVisitor : public vl::Interface
				{
				public:
					virtual void Visit(JsonLiteral* node)=0;
					virtual void Visit(JsonString* node)=0;
					virtual void Visit(JsonNumber* node)=0;
					virtual void Visit(JsonArray* node)=0;
					virtual void Visit(JsonObjectField* node)=0;
					virtual void Visit(JsonObject* node)=0;
				};

				virtual void Accept(JsonNode::IVisitor* visitor)=0;

			};

			class JsonLiteral : public JsonNode
			{
			public:
				struct JsonValue abstract
				{
					enum Type
					{
						True,
						False,
						Null,
					};
				};

				JsonValue::Type value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonLiteral> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonString : public JsonNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonString> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonNumber : public JsonNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonNumber> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonArray : public JsonNode
			{
			public:
				vl::collections::List<vl::Ptr<JsonNode>> items;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonArray> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonObjectField : public JsonNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::Ptr<JsonNode> value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObjectField> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonObject : public JsonNode
			{
			public:
				vl::collections::List<vl::Ptr<JsonObjectField>> fields;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObject> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			extern vl::WString JsonGetParserTextBuffer();
			extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> JsonConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern vl::Ptr<vl::parsing::tabling::ParsingTable> JsonLoadTable();

			extern vl::Ptr<vl::parsing::ParsingTreeNode> JsonParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
			extern vl::Ptr<JsonNode> JsonParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);

		}
	}
}
#endif

/***********************************************************************
PARSING\JSON\PARSINGJSON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingJson_Parser

***********************************************************************/

#ifndef VCZH_PARSING_JSON_PARSINGJSON
#define VCZH_PARSING_JSON_PARSINGJSON


namespace vl
{
	namespace parsing
	{
		namespace json
		{
			extern void						JsonEscapeString(const WString& text, stream::TextWriter& writer);
			extern void						JsonUnescapeString(const WString& text, stream::TextWriter& writer);
			extern void						JsonPrint(Ptr<JsonNode> node, stream::TextWriter& writer);
			extern WString					JsonToString(Ptr<JsonNode> node);
		}
	}
}

#endif

/***********************************************************************
STREAM\MEMORYSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryStream

Interfaces:
	MemoryStream					：内存流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYSTREAM
#define VCZH_STREAM_MEMORYSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryStream : public Object, public virtual IStream
		{
		protected:
			vint					block;
			char*					buffer;
			vint					size;
			vint					position;
			vint					capacity;

			void					PrepareSpace(vint totalSpace);
		public:
			MemoryStream(vint _block=65536);
			~MemoryStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
			void*					GetInternalBuffer();
		};
	}
}

#endif

/***********************************************************************
REGEX\REGEXDATA.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Basic Data Structure

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXDATA
#define VCZH_REGEX_REGEXDATA


namespace vl
{
	namespace regex_internal
	{
		using namespace vl::collections;

/***********************************************************************
基础数据结构
***********************************************************************/

		class CharRange
		{
		public:
			typedef SortedList<CharRange>			List;

			wchar_t					begin;
			wchar_t					end;

			CharRange();
			CharRange(wchar_t _begin, wchar_t _end);

			bool					operator<(CharRange item)const;
			bool					operator<=(CharRange item)const;
			bool					operator>(CharRange item)const;
			bool					operator>=(CharRange item)const;
			bool					operator==(CharRange item)const;
			bool					operator!=(CharRange item)const;

			bool					operator<(wchar_t item)const;
			bool					operator<=(wchar_t item)const;
			bool					operator>(wchar_t item)const;
			bool					operator>=(wchar_t item)const;
			bool					operator==(wchar_t item)const;
			bool					operator!=(wchar_t item)const;
		};
	}

	template<>
	struct POD<regex_internal::CharRange>
	{
		static const bool Result=true;
	};
}

#endif

/***********************************************************************
REGEX\REGEXAUTOMATON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexAutomaton

Classes:
	State						：状态
	Transition					：转换
	Automaton					：状态机

Functions:
	EpsilonNfaToNfa				：去Epsilon
	NfaToDfa					：NFA转DFA
***********************************************************************/

#ifndef VCZH_REGEX_REGEXAUTOMATON
#define VCZH_REGEX_REGEXAUTOMATON


namespace vl
{
	namespace regex_internal
	{
		class State;
		class Transition;

		class Transition
		{
		public:
			enum Type
			{
				Chars,				//range为字符范围
				Epsilon,
				BeginString,
				EndString,
				Nop,				//无动作（不可消除epsilon，用来控制优先级）
				Capture,			//capture为捕获频道
				Match,				//capture为捕获频道，index为匹配的位置，-1代表匹配频道下面的所有项目
				Positive,			//正向匹配
				Negative,			//反向匹配
				NegativeFail,		//反向匹配失败
				End					//Capture, Position, Negative
			};

			State*					source;
			State*					target;
			CharRange				range;
			Type					type;
			vint						capture;
			vint						index;
		};

		class State
		{
		public:
			List<Transition*>		transitions;
			List<Transition*>		inputs;
			bool					finalState;
			void*					userData;
		};

		class Automaton
		{
		public:
			typedef Ptr<Automaton>		Ref;

			List<Ptr<State>>		states;
			List<Ptr<Transition>>	transitions;
			List<WString>			captureNames;
			State*					startState;

			Automaton();

			State*					NewState();
			Transition*				NewTransition(State* start, State* end);
			Transition*				NewChars(State* start, State* end, CharRange range);
			Transition*				NewEpsilon(State* start, State* end);
			Transition*				NewBeginString(State* start, State* end);
			Transition*				NewEndString(State* start, State* end);
			Transition*				NewNop(State* start, State* end);
			Transition*				NewCapture(State* start, State* end, vint capture);
			Transition*				NewMatch(State* start, State* end, vint capture, vint index=-1);
			Transition*				NewPositive(State* start, State* end);
			Transition*				NewNegative(State* start, State* end);
			Transition*				NewNegativeFail(State* start, State* end);
			Transition*				NewEnd(State* start, State* end);
		};

		extern bool					PureEpsilonChecker(Transition* transition);
		extern bool					RichEpsilonChecker(Transition* transition);
		extern bool					AreEqual(Transition* transA, Transition* transB);
		extern Automaton::Ref		EpsilonNfaToNfa(Automaton::Ref source, bool(*epsilonChecker)(Transition*), Dictionary<State*, State*>& nfaStateMap);
		extern Automaton::Ref		NfaToDfa(Automaton::Ref source, Group<State*, State*>& dfaStateMap);
	}
}

#endif

/***********************************************************************
REGEX\REGEXEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexExpression

Classes:
	Expression						：表达式基类					|
	CharSetExpression				：字符集表达式				| a, [a-b], [^a-b0_9], \.rnt\/()+*?{}[]<>^$!=SsDdLlWw, [\rnt-[]\/^$]
	LoopExpression					：循环表达式					| a{3}, a{3,}, a{1,3}, a+, a*, a?, LOOP?
	SequenceExpression				：顺序表达式					| ab
	AlternateExpression				：选择表达式					| a|b
	BeginExpression					：【非纯】字符串起始表达式	| ^
	EndExpression					：【非纯】字符串末尾表达式	| $
	CaptureExpression				：【非纯】捕获表达式			| (<name>expr), (?expr)
	MatchExpression					：【非纯】匹配表达式			| (<$name>), (<$name;i>), (<$i>)
	PositiveExpression				：【非纯】正向预查表达式		| (=expr)
	NegativeExpression				：【非纯】反向预查表达式		| (!expr)
	UsingExpression					：引用表达式					| (<#name1>expr)...(<&name1>)...

	RegexExpression					：正则表达式

Functions:
	ParseRegexExpression			：将字符串分析为RegexExpression对象，如果语法有问题则抛异常
***********************************************************************/

#ifndef VCZH_REGEX_REGEXEXPRESSION
#define VCZH_REGEX_REGEXEXPRESSION


namespace vl
{
	namespace regex_internal
	{
		class IRegexExpressionAlgorithm;

/***********************************************************************
正则表达式表达式树
***********************************************************************/

		class Expression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<Expression>								Ref;
			typedef Dictionary<WString, Expression::Ref>		Map;

			virtual void				Apply(IRegexExpressionAlgorithm& algorithm)=0;
			bool						IsEqual(Expression* expression);
			bool						HasNoExtension();
			bool						CanTreatAsPure();
			void						NormalizeCharSet(CharRange::List& subsets);
			void						CollectCharSet(CharRange::List& subsets);
			void						ApplyCharSet(CharRange::List& subsets);
			Automaton::Ref				GenerateEpsilonNfa();
		};

		class CharSetExpression : public Expression
		{
		public:
			CharRange::List				ranges;
			bool						reverse;

			bool						AddRangeWithConflict(CharRange range);
			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class LoopExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//被循环表达式
			vint							min;			//下限
			vint							max;			//上限，-1代表无限
			bool						preferLong;		//长匹配优先

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class SequenceExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class AlternateExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class BeginExpression: public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class EndExpression : public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class CaptureExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			Expression::Ref				expression;		//被捕获表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class MatchExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			vint							index;			//捕获序号，-1代表非空捕获的所有项

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class PositiveExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//正向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class NegativeExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//反向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class UsingExpression : public Expression
		{
		public:
			WString						name;			//引用名

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class RegexExpression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<RegexExpression>						Ref;

			Expression::Map				definitions;	//命名子表达式
			Expression::Ref				expression;		//主表达式

			Expression::Ref				Merge();
		};

/***********************************************************************
算法基类
***********************************************************************/

		class IRegexExpressionAlgorithm : public Interface
		{
		public:
			virtual void				Visit(CharSetExpression* expression)=0;
			virtual void				Visit(LoopExpression* expression)=0;
			virtual void				Visit(SequenceExpression* expression)=0;
			virtual void				Visit(AlternateExpression* expression)=0;
			virtual void				Visit(BeginExpression* expression)=0;
			virtual void				Visit(EndExpression* expression)=0;
			virtual void				Visit(CaptureExpression* expression)=0;
			virtual void				Visit(MatchExpression* expression)=0;
			virtual void				Visit(PositiveExpression* expression)=0;
			virtual void				Visit(NegativeExpression* expression)=0;
			virtual void				Visit(UsingExpression* expression)=0;
		};

		template<typename ReturnType, typename ParameterType=void*>
		class RegexExpressionAlgorithm : public Object, public IRegexExpressionAlgorithm
		{
		private:
			ReturnType					returnValue;
			ParameterType*				parameterValue;
		public:

			ReturnType Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			ReturnType Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			virtual ReturnType			Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(LoopExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(SequenceExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(AlternateExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(BeginExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(EndExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(CaptureExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(MatchExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(PositiveExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(NegativeExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(UsingExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}
		};

		template<typename ParameterType>
		class RegexExpressionAlgorithm<void, ParameterType> : public Object, public IRegexExpressionAlgorithm
		{
		private:
			ParameterType*				parameterValue;
		public:

			void Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
			}

			void Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
			}

			virtual void				Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(LoopExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(SequenceExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(AlternateExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(BeginExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(EndExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(CaptureExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(MatchExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(PositiveExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(NegativeExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(UsingExpression* expression)
			{
				Apply(expression, *parameterValue);
			}
		};

/***********************************************************************
辅助函数
***********************************************************************/

		extern Ptr<LoopExpression>		ParseLoop(const wchar_t*& input);
		extern Ptr<Expression>			ParseCharSet(const wchar_t*& input);
		extern Ptr<Expression>			ParseFunction(const wchar_t*& input);
		extern Ptr<Expression>			ParseUnit(const wchar_t*& input);
		extern Ptr<Expression>			ParseJoin(const wchar_t*& input);
		extern Ptr<Expression>			ParseAlt(const wchar_t*& input);
		extern Ptr<Expression>			ParseExpression(const wchar_t*& input);
		extern RegexExpression::Ref		ParseRegexExpression(const WString& code);

		extern WString					EscapeTextForRegex(const WString& literalString);
		extern WString					UnescapeTextForRegex(const WString& escapedText);
		extern WString					NormalizeEscapedTextForRegex(const WString& escapedText);
		extern bool						IsRegexEscapedListeralString(const WString& regex);
	}
}

#endif

/***********************************************************************
PARSING\XML\PARSINGXML_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingXml_Parser

本文件使用Vczh Parsing Generator工具自动生成
***********************************************************************/

#ifndef VCZH_PARSING_XML_PARSINGXML_PARSER
#define VCZH_PARSING_XML_PARSINGXML_PARSER


namespace vl
{
	namespace parsing
	{
		namespace xml
		{
			struct XmlParserTokenIndex abstract
			{
				static const vl::vint INSTRUCTION_OPEN = 0;
				static const vl::vint INSTRUCTION_CLOSE = 1;
				static const vl::vint COMPLEX_ELEMENT_OPEN = 2;
				static const vl::vint SINGLE_ELEMENT_CLOSE = 3;
				static const vl::vint ELEMENT_OPEN = 4;
				static const vl::vint ELEMENT_CLOSE = 5;
				static const vl::vint EQUAL = 6;
				static const vl::vint NAME = 7;
				static const vl::vint ATTVALUE = 8;
				static const vl::vint COMMENT = 9;
				static const vl::vint CDATA = 10;
				static const vl::vint TEXT = 11;
				static const vl::vint SPACE = 12;
			};
			class XmlNode;
			class XmlText;
			class XmlCData;
			class XmlAttribute;
			class XmlComment;
			class XmlElement;
			class XmlInstruction;
			class XmlDocument;

			class XmlNode abstract : public vl::parsing::ParsingTreeCustomBase
			{
			public:
				class IVisitor : public vl::Interface
				{
				public:
					virtual void Visit(XmlText* node)=0;
					virtual void Visit(XmlCData* node)=0;
					virtual void Visit(XmlAttribute* node)=0;
					virtual void Visit(XmlComment* node)=0;
					virtual void Visit(XmlElement* node)=0;
					virtual void Visit(XmlInstruction* node)=0;
					virtual void Visit(XmlDocument* node)=0;
				};

				virtual void Accept(XmlNode::IVisitor* visitor)=0;

			};

			class XmlText : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlText> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlCData : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlCData> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlAttribute : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::parsing::ParsingToken value;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlAttribute> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlComment : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlComment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlElement : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::parsing::ParsingToken closingName;
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;
				vl::collections::List<vl::Ptr<XmlNode>> subNodes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlElement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlInstruction : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlInstruction> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlDocument : public XmlNode
			{
			public:
				vl::collections::List<vl::Ptr<XmlNode>> prologs;
				vl::Ptr<XmlElement> rootElement;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlDocument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			extern vl::WString XmlGetParserTextBuffer();
			extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable();

			extern vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
			extern vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);

			extern vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
			extern vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);

		}
	}
}
#endif

/***********************************************************************
PARSING\XML\PARSINGXML.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingXml

***********************************************************************/

#ifndef VCZH_PARSING_XML_PARSINGXML
#define VCZH_PARSING_XML_PARSINGXML


namespace vl
{
	namespace parsing
	{
		namespace xml
		{
			extern WString							XmlEscapeValue(const WString& value);
			extern WString							XmlUnescapeValue(const WString& value);
			extern WString							XmlEscapeCData(const WString& value);
			extern WString							XmlUnescapeCData(const WString& value);
			extern WString							XmlEscapeComment(const WString& value);
			extern WString							XmlUnescapeComment(const WString& value);
			extern void								XmlPrint(Ptr<XmlNode> node, stream::TextWriter& writer);
			extern void								XmlPrintContent(Ptr<XmlElement> element, stream::TextWriter& writer);
			extern WString							XmlToString(Ptr<XmlNode> node);

			extern Ptr<XmlAttribute>							XmlGetAttribute(Ptr<XmlElement> element, const WString& name);
			extern Ptr<XmlElement>								XmlGetElement(Ptr<XmlElement> element, const WString& name);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(Ptr<XmlElement> element);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(Ptr<XmlElement> element, const WString& name);
			extern WString										XmlGetValue(Ptr<XmlElement> element);

			extern Ptr<XmlAttribute>							XmlGetAttribute(XmlElement* element, const WString& name);
			extern Ptr<XmlElement>								XmlGetElement(XmlElement* element, const WString& name);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(XmlElement* element);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(XmlElement* element, const WString& name);
			extern WString										XmlGetValue(XmlElement* element);

			class XmlElementWriter : public Object
			{
			protected:
				Ptr<XmlElement>					element;
				const XmlElementWriter*			previousWriter;

			public:
				XmlElementWriter(Ptr<XmlElement> _element, const XmlElementWriter* _previousWriter=0);
				~XmlElementWriter();

				const XmlElementWriter&			Attribute(const WString& name, const WString& value)const;
				XmlElementWriter				Element(const WString& name)const;
				const XmlElementWriter&			End()const;
				const XmlElementWriter&			Text(const WString& value)const;
				const XmlElementWriter&			CData(const WString& value)const;
				const XmlElementWriter&			Comment(const WString& value)const;
			};
		}
	}
}

#endif

/***********************************************************************
REGEX\REGEXPURE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	PureInterpretor					：正则表达式纯模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXPURE
#define VCZH_REGEX_REGEXPURE


namespace vl
{
	namespace regex_internal
	{
		class PureResult
		{
		public:
			vint				start;
			vint				length;
			vint				finalState;
		};

		class PureInterpretor : public Object
		{
		protected:
			vint				charMap[1<<(8*sizeof(wchar_t))];	// char -> char set index
			vint**				transition;							// (state * char set index) -> state*
			bool*				finalState;							// state -> bool
			vint*				relatedFinalState;					// sate -> (finalState or -1)
			vint				stateCount;
			vint				charSetCount;
			vint				startState;
		public:
			PureInterpretor(Automaton::Ref dfa, CharRange::List& subsets);
			~PureInterpretor();

			bool				MatchHead(const wchar_t* input, const wchar_t* start, PureResult& result);
			bool				Match(const wchar_t* input, const wchar_t* start, PureResult& result);

			vint				GetStartState();
			vint				Transit(wchar_t input, vint state);
			bool				IsFinalState(vint state);
			bool				IsDeadState(vint state);

			void				PrepareForRelatedFinalStateTable();
			vint				GetRelatedFinalState(vint state);
		};
	}
}

#endif

/***********************************************************************
REGEX\REGEXRICH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	RichInterpretor					：正则表达式完全模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXRICH
#define VCZH_REGEX_REGEXRICH


namespace vl
{
	namespace regex_internal
	{
		class CaptureRecord
		{
		public:
			vint								capture;
			vint								start;
			vint								length;

			bool							operator==(const CaptureRecord& record)const;
		};
	}

	template<>
	struct POD<regex_internal::CaptureRecord>
	{
		static const bool Result=true;
	};

	namespace regex_internal
	{
		class RichResult
		{
		public:
			vint							start;
			vint							length;
			List<CaptureRecord>			captures;
		};

		class RichInterpretor : public Object
		{
		public:
		protected:
			class UserData
			{
			public:
				bool						NeedKeepState;
			};

			Automaton::Ref					dfa;
			UserData*						datas;
		public:
			RichInterpretor(Automaton::Ref _dfa);
			~RichInterpretor();

			bool							MatchHead(const wchar_t* input, const wchar_t* start, RichResult& result);
			bool							Match(const wchar_t* input, const wchar_t* start, RichResult& result);
			const List<WString>&			CaptureNames();
		};
	};
}

#endif

/***********************************************************************
REGEX\REGEXWRITER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexWriter

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXWRITER
#define VCZH_REGEX_REGEXWRITER


namespace vl
{
	namespace regex
	{
		class RegexNode : public Object
		{
		public:
			vl::regex_internal::Expression::Ref		expression;

			RegexNode(vl::regex_internal::Expression::Ref _expression);

			RegexNode					Some()const;
			RegexNode					Any()const;
			RegexNode					Opt()const;
			RegexNode					Loop(vint min, vint max)const;
			RegexNode					AtLeast(vint min)const;
			RegexNode					operator+(const RegexNode& node)const;
			RegexNode					operator|(const RegexNode& node)const;
			RegexNode					operator+()const;
			RegexNode					operator-()const;
			RegexNode					operator!()const;
			RegexNode					operator%(const RegexNode& node)const;
		};

		extern RegexNode				rCapture(const WString& name, const RegexNode& node);
		extern RegexNode				rUsing(const WString& name);
		extern RegexNode				rMatch(const WString& name, vint index=-1);
		extern RegexNode				rMatch(vint index);
		extern RegexNode				rBegin();
		extern RegexNode				rEnd();
		extern RegexNode				rC(wchar_t a, wchar_t b=L'\0');
		extern RegexNode				r_d();
		extern RegexNode				r_l();
		extern RegexNode				r_w();
		extern RegexNode				rAnyChar();
	}
}

#endif

/***********************************************************************
STREAM\BROADCASTSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::BroadcastStream

Interfaces:
	BroadcastStream					：广播流
***********************************************************************/

#ifndef VCZH_STREAM_BROADCASTSTREAM
#define VCZH_STREAM_BROADCASTSTREAM


namespace vl
{
	namespace stream
	{
		class BroadcastStream : public Object, public virtual IStream
		{
			typedef collections::List<IStream*>		StreamList;
		protected:
			bool					closed;
			pos_t					position;
			StreamList				streams;
		public:
			BroadcastStream();
			~BroadcastStream();

			StreamList&				Targets();
			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CACHESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CacheStream

Interfaces:
	CacheStream						：缓冲流
***********************************************************************/

#ifndef VCZH_STREAM_CACHESTREAM
#define VCZH_STREAM_CACHESTREAM


namespace vl
{
	namespace stream
	{
		class CacheStream : public Object, public virtual IStream
		{
		protected:
			IStream*				target;
			vint					block;
			pos_t					start;
			pos_t					position;

			char*					buffer;
			vint					dirtyStart;
			vint					dirtyLength;
			vint					availableLength;
			pos_t					operatedSize;

			void					Flush();
			void					Load(pos_t _position);
			vint					InternalRead(void* _buffer, vint _size);
			vint					InternalWrite(void* _buffer, vint _size);
		public:
			CacheStream(IStream& _target, vint _block=65536);
			~CacheStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CHARFORMAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CharFormat

Classes:
	CharEncoder									：字符串编码器基类
	CharDecoder									：字符串解码器基类
	MbcsEncoder									：Mbcs编码器
	MbcsDecoder									：Mbcs解码器
	Utf16Encoder								：Utf16编码器
	Utf16Decoder								：Utf16解码器
	Utf16BEEncoder								：Utf16 Big Endian编码器
	Utf16BEDecoder								：Utf16 Big Endian解码器
	Utf8Encoder									：Utf8编码器
	Utf8Decoder									：Utf8解码器
	BomEncoder									：BOM相关编码器
	BomDecoder									：BOM相关解码器
***********************************************************************/

#ifndef VCZH_STREAM_CHARFORMAT
#define VCZH_STREAM_CHARFORMAT


namespace vl
{
	namespace stream
	{

		/*编码资料
		UCS-4和UTF-8的对应关系:
		U-00000000 - U-0000007F:  0xxxxxxx
		U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
		U-00000800 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
		U-00010000 - U-001FFFFF:  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-00200000 - U-03FFFFFF:  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-04000000 - U-7FFFFFFF:  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		BOM:
		FFFE	=Unicode			(vceUtf16)
		FEFF	=Unicode Big Endian	(vceUtf16_be)
		EFBBBF	=UTF-8				(vceUtf8)
		other	=MBCS(GBK)			(vceMbcs)
		*/

/***********************************************************************
字符串编码解码基类
***********************************************************************/

		class CharEncoder : public Object, public IEncoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint					WriteString(wchar_t* _buffer, vint chars)=0;
		public:
			CharEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Write(void* _buffer, vint _size);
		};

		class CharDecoder : public Object, public IDecoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint					ReadString(wchar_t* _buffer, vint chars)=0;
		public:
			CharDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Read(void* _buffer, vint _size);
		};

/***********************************************************************
Mbcs
***********************************************************************/

		class MbcsEncoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class MbcsDecoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16
***********************************************************************/

		class Utf16Encoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16Decoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16-be
***********************************************************************/

		class Utf16BEEncoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16BEDecoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-8
***********************************************************************/

		class Utf8Encoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf8Decoder : public CharDecoder
		{
		protected:
			wchar_t							cache;
			bool							cacheAvailable;

			vint							ReadString(wchar_t* _buffer, vint chars);
		public:
			Utf8Decoder();
		};

/***********************************************************************
Bom
***********************************************************************/

		class BomEncoder : public Object, public IEncoder
		{
		public:
			enum Encoding
			{
				Mbcs,
				Utf8,
				Utf16,
				Utf16BE
			};
		protected:
			Encoding						encoding;
			IEncoder*						encoder;
		public:
			BomEncoder(Encoding _encoding);
			~BomEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Write(void* _buffer, vint _size);
		};

		class BomDecoder : public Object, public IDecoder
		{
		private:
			class BomStream : public Object, public IStream
			{
			protected:
				IStream*					stream;
				char						bom[3];
				vint						bomLength;
				vint						bomPosition;
			public:
				BomStream(IStream* _stream, char* _bom, vint _bomLength);

				bool						CanRead()const;
				bool						CanWrite()const;
				bool						CanSeek()const;
				bool						CanPeek()const;
				bool						IsLimited()const;
				bool						IsAvailable()const;
				void						Close();
				pos_t						Position()const;
				pos_t						Size()const;
				void						Seek(pos_t _size);
				void						SeekFromBegin(pos_t _size);
				void						SeekFromEnd(pos_t _size);
				vint						Read(void* _buffer, vint _size);
				vint						Write(void* _buffer, vint _size);
				vint						Peek(void* _buffer, vint _size);
			};
		protected:
			IDecoder*						decoder;
			IStream*						stream;

		public:
			BomDecoder();
			~BomDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Read(void* _buffer, vint _size);
		};

/***********************************************************************
Encoding Test
***********************************************************************/

		extern void							TestEncoding(unsigned char* buffer, vint size, BomEncoder::Encoding& encoding, bool& containsBom);
	}
}

#endif

/***********************************************************************
STREAM\FILESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::FileStream

Interfaces:
	FileStream						：文件流
***********************************************************************/

#ifndef VCZH_STREAM_FILESTREAM
#define VCZH_STREAM_FILESTREAM

#include <stdio.h>

namespace vl
{
	namespace stream
	{
		class FileStream : public Object, public virtual IStream
		{
		public:
			enum AccessRight
			{
				ReadOnly,
				WriteOnly,
				ReadWrite
			};
		protected:
			AccessRight				accessRight;
			FILE*					file;
		public:
			FileStream(const WString& fileName, AccessRight _accessRight);
			~FileStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\MEMORYWRAPPERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryWrapperStream

Interfaces:
	MemoryWrapperStream				：内存代理流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYWRAPPERSTREAM
#define VCZH_STREAM_MEMORYWRAPPERSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryWrapperStream : public Object, public virtual IStream
		{
		protected:
			char*					buffer;
			vint						size;
			vint						position;
		public:
			MemoryWrapperStream(void* _buffer, vint _size);
			~MemoryWrapperStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\RECORDERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::RecorderStream

Interfaces:
	RecorderStream					：备份流
***********************************************************************/

#ifndef VCZH_STREAM_RECORDERSTREAM
#define VCZH_STREAM_RECORDERSTREAM


namespace vl
{
	namespace stream
	{
		class RecorderStream : public Object, public virtual IStream
		{
		protected:
			IStream*				in;
			IStream*				out;
		public:
			RecorderStream(IStream& _in, IStream& _out);
			~RecorderStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
THREADING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Threading

Classes:
	Thread										：线程
	CriticalSection
	Mutex
	Semaphore
	EventObject
***********************************************************************/

#ifndef VCZH_THREADING
#define VCZH_THREADING


namespace vl
{

/***********************************************************************
内核模式对象
***********************************************************************/

	namespace threading_internal
	{
		struct WaitableData;
		struct ThreadData;
		struct MutexData;
		struct SemaphoreData;
		struct EventData;

		struct CriticalSectionData;
		struct ReaderWriterLockData;
		struct ConditionVariableData;
	}

	class WaitableObject : public Object, public NotCopyable
	{
	private:
		threading_internal::WaitableData*			waitableData;
	protected:

		WaitableObject();
		void										SetData(threading_internal::WaitableData* data);
	public:

		bool										IsCreated();
		bool										Wait();
		bool										WaitForTime(vint ms);
		
		static bool									WaitAll(WaitableObject** objects, vint count);
		static bool									WaitAllForTime(WaitableObject** objects, vint count, vint ms);
		static vint									WaitAny(WaitableObject** objects, vint count, bool* abandoned);
		static vint									WaitAnyForTime(WaitableObject** objects, vint count, vint ms, bool* abandoned);
	};

	class Thread : public WaitableObject
	{
		friend void InternalThreadProc(Thread* thread);
	public:
		enum ThreadState
		{
			NotStarted,
			Running,
			Paused,
			Stopped
		};

		typedef void(*ThreadProcedure)(Thread*, void*);
	private:
		threading_internal::ThreadData*				internalData;
		volatile ThreadState						threadState;

	protected:

		virtual void								Run()=0;
	public:
		Thread();
		~Thread();

		static Thread*								CreateAndStart(ThreadProcedure procedure, void* argument=0, bool deleteAfterStopped=true);
		static Thread*								CreateAndStart(const Func<void()>& procedure, bool deleteAfterStopped=true);
		static void									Sleep(vint ms);
		static vint									GetCPUCount();
		static vint									GetCurrentThreadId();

		bool										Start();
		bool										Pause();
		bool										Resume();
		bool										Stop();
		ThreadState									GetState();
		void										SetCPU(vint index);
	};

	class Mutex : public WaitableObject
	{
	private:
		threading_internal::MutexData*				internalData;
	public:
		Mutex();
		~Mutex();

		bool										Create(bool owned=false, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
	};

	class Semaphore : public WaitableObject
	{
	private:
		threading_internal::SemaphoreData*			internalData;
	public:
		Semaphore();
		~Semaphore();

		bool										Create(vint initialCount, vint maxCount, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
		vint										Release(vint count);
	};

	class EventObject : public WaitableObject
	{
	private:
		threading_internal::EventData*				internalData;
	public:
		EventObject();
		~EventObject();

		bool										CreateAutoUnsignal(bool signaled, const WString& name=L"");
		bool										CreateManualUnsignal(bool signaled, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Signal();
		bool										Unsignal();
	};

/***********************************************************************
线程池
***********************************************************************/

	class ThreadPoolLite : public Object
	{
	private:
		ThreadPoolLite();
		~ThreadPoolLite();
	public:
		static bool									Queue(void(*proc)(void*), void* argument);
		static bool									Queue(const Func<void()>& proc);

		template<typename T>
		static void QueueLambda(const T& proc)
		{
			Queue(Func<void()>(proc));
		}
	};

/***********************************************************************
进程内对象
***********************************************************************/

	class CriticalSection : public Object, public NotCopyable
	{
	private:
		friend class ConditionVariable;
		threading_internal::CriticalSectionData*	internalData;
	public:
		CriticalSection();
		~CriticalSection();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			CriticalSection*						criticalSection;
		public:
			Scope(CriticalSection& _criticalSection);
			~Scope();
		};
	};

	class ReaderWriterLock : public Object, public NotCopyable
	{
	private:
		friend class ConditionVariable;
		threading_internal::ReaderWriterLockData*	internalData;
	public:
		ReaderWriterLock();
		~ReaderWriterLock();

		bool										TryEnterReader();
		void										EnterReader();
		void										LeaveReader();
		bool										TryEnterWriter();
		void										EnterWriter();
		void										LeaveWriter();
	public:
		class ReaderScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			ReaderScope(ReaderWriterLock& _lock);
			~ReaderScope();
		};
		
		class WriterScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			WriterScope(ReaderWriterLock& _lock);
			~WriterScope();
		};
	};

	class ConditionVariable : public Object, public NotCopyable
	{
	private:
		threading_internal::ConditionVariableData*	internalData;
	public:
		ConditionVariable();
		~ConditionVariable();

		bool										SleepWith(CriticalSection& cs);
		bool										SleepWithForTime(CriticalSection& cs, vint ms);
		bool										SleepWithReader(ReaderWriterLock& lock);
		bool										SleepWithReaderForTime(ReaderWriterLock& lock, vint ms);
		bool										SleepWithWriter(ReaderWriterLock& lock);
		bool										SleepWithWriterForTime(ReaderWriterLock& lock, vint ms);
		void										WakeOnePending();
		void										WakeAllPendings();
	};

/***********************************************************************
用户模式对象
***********************************************************************/

	typedef long LockedInt;

	class SpinLock : public Object, public NotCopyable
	{
	protected:
		volatile LockedInt							token;
	public:
		SpinLock();
		~SpinLock();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			SpinLock*								spinLock;
		public:
			Scope(SpinLock& _spinLock);
			~Scope();
		};
	};

#define SPIN_LOCK(LOCK) SCOPE_VARIABLE(SpinLock::Scope, scope, LOCK)
#define CS_LOCK(LOCK) SCOPE_VARIABLE(CriticalSection::Scope, scope, LOCK)
#define READER_LOCK(LOCK) SCOPE_VARIABLE(ReaderWriterLock::ReaderScope, scope, LOCK)
#define WRITER_LOCK(LOCK) SCOPE_VARIABLE(ReaderWriterLock::WriterScope, scope, LOCK)

/***********************************************************************
RepeatingTaskExecutor
***********************************************************************/

	template<typename T>
	class RepeatingTaskExecutor : public Object
	{
	private:
		SpinLock								inputLock;
		T										inputData;
		volatile bool							inputDataAvailable;
		SpinLock								executingEvent;
		volatile bool							executing;

		void ExecutingProcInternal()
		{
			while(true)
			{
				bool currentInputDataAvailable;
				T currentInputData;
				SPIN_LOCK(inputLock)
				{
					currentInputData=inputData;
					inputData=T();
					currentInputDataAvailable=inputDataAvailable;
					inputDataAvailable=false;
					if(!currentInputDataAvailable)
					{
						executing=false;
						goto FINISH_EXECUTING;
					}
				}
				Execute(currentInputData);
			}
		FINISH_EXECUTING:
			executingEvent.Leave();
		}

		static void ExecutingProc(void* argument)
		{
			((RepeatingTaskExecutor<T>*)argument)->ExecutingProcInternal();
		}
	
	protected:
		virtual void							Execute(const T& input)=0;

	public:
		RepeatingTaskExecutor()
			:inputDataAvailable(false)
			,executing(false)
		{
		}

		~RepeatingTaskExecutor()
		{
			EnsureTaskFinished();
		}

		void EnsureTaskFinished()
		{
			executingEvent.Enter();
			executingEvent.Leave();
		}

		void SubmitTask(const T& input)
		{
			SPIN_LOCK(inputLock)
			{
				inputData=input;
				inputDataAvailable=true;
			}
			if(!executing)
			{
				executing=true;
				executingEvent.Enter();
				ThreadPoolLite::Queue(&ExecutingProc, this);
			}
		}
	};
}

#endif
