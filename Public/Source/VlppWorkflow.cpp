/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/
#include "VlppWorkflow.h"

/***********************************************************************
Analyzer\WfAnalyzer.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfLexicalSymbol
***********************************************************************/

			WfLexicalSymbol::WfLexicalSymbol(WfLexicalScope* _ownerScope)
				:ownerScope(_ownerScope)
			{
			}

			WfLexicalSymbol::~WfLexicalSymbol()
			{
			}

			WString WfLexicalSymbol::GetFriendlyName()
			{
				return ownerScope->GetFriendlyName() + L"::" + name;
			}

/***********************************************************************
WfLexicalScope
***********************************************************************/

			WfLexicalScope::WfLexicalScope(WfLexicalScopeManager* _ownerManager)
				:ownerManager(_ownerManager)
			{
			}

			WfLexicalScope::WfLexicalScope(Ptr<WfLexicalScope> _parentScope)
				:ownerManager(0)
				, parentScope(_parentScope)
			{
			}

			WfLexicalScope::~WfLexicalScope()
			{
			}

			WfLexicalScopeManager* WfLexicalScope::FindManager()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerManager)
					{
						return scope->ownerManager;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			Ptr<WfModule> WfLexicalScope::FindModule()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerModule)
					{
						return scope->ownerModule;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			Ptr<WfDeclaration> WfLexicalScope::FindDeclaration()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerDeclaration)
					{
						return scope->ownerDeclaration;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			WString WfLexicalScope::GetFriendlyName()
			{
				if (ownerModule)
				{
					return L"<" + ownerModule->name.value + L">";
				}
				else if (ownerDeclaration)
				{
					return parentScope->GetFriendlyName() + L"::" + ownerDeclaration->name.value;
				}
				else if (!parentScope)
				{
					return L"";
				}
				else
				{
					return parentScope->GetFriendlyName() + L"::<>";
				}
			}

/***********************************************************************
WfLexicalScopeName
***********************************************************************/

			WfLexicalScopeName::WfLexicalScopeName(bool _createdByTypeDescriptor)
				:parent(0)
				, createdByTypeDescriptor(_createdByTypeDescriptor)
				, typeDescriptor(0)
			{
			}

			WfLexicalScopeName::~WfLexicalScopeName()
			{
			}

			Ptr<WfLexicalScopeName> WfLexicalScopeName::AccessChild(const WString& name, bool createdByTypeDescriptor)
			{
				vint index = children.Keys().IndexOf(name);
				if (index == -1)
				{
					Ptr<WfLexicalScopeName> newName = new WfLexicalScopeName(createdByTypeDescriptor);
					newName->name = name;
					newName->parent = this;
					children.Add(name, newName);
					return newName;
				}
				else
				{
					return children.Values()[index];
				}
			}

			void WfLexicalScopeName::RemoveNonTypeDescriptorNames()
			{
				for (vint i = children.Count() - 1; i >= 0; i--)
				{
					if (!children.Values()[i]->createdByTypeDescriptor)
					{
						children.Remove(children.Keys()[i]);
					}
				}
				
				declarations.Clear();
				FOREACH(Ptr<WfLexicalScopeName>, name, children.Values())
				{
					name->RemoveNonTypeDescriptorNames();
				}
			}

			WString WfLexicalScopeName::GetFriendlyName()
			{
				if (parent)
				{
					WString parentName = parent->GetFriendlyName();
					if (parentName == L"")
					{
						return name;
					}
					else
					{
						return parentName + L"::" + name;
					}
				}
				else
				{
					return L"";
				}
			}

/***********************************************************************
ResolveExpressionResult
***********************************************************************/

			ResolveExpressionResult::ResolveExpressionResult()
				:propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<WfLexicalScopeName> _scopeName)
				:scopeName(_scopeName)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:type(_type)
				, leftValueType(_leftValueType)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(Ptr<WfLexicalSymbol> _symbol, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:symbol(_symbol)
				, type(_type)
				, leftValueType(_leftValueType)
				, propertyInfo(0)
				, methodInfo(0)
				, eventInfo(0)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IPropertyInfo* _propertyInfo, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType)
				:propertyInfo(_propertyInfo)
				, methodInfo(0)
				, eventInfo(0)
				, type(_type)
				, leftValueType(_leftValueType)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IMethodInfo* _methodInfo, Ptr<reflection::description::ITypeInfo> _type)
				:propertyInfo(0)
				, methodInfo(_methodInfo)
				, eventInfo(0)
				, type(_type)
			{
			}

			ResolveExpressionResult::ResolveExpressionResult(reflection::description::IEventInfo* _eventInfo)
				:propertyInfo(0)
				, methodInfo(0)
				, eventInfo(_eventInfo)
			{
			}

			WString ResolveExpressionResult::GetFriendlyName()const
			{
				WString typeName;
				if (type)
				{
					typeName= + L" of type \"" + type->GetTypeFriendlyName() + L"\"";
				}
				if (scopeName)
				{
					return scopeName->GetFriendlyName();
				}
				else if (symbol)
				{
					return symbol->GetFriendlyName() + typeName;
				}
				else if (propertyInfo)
				{
					return L"property \"" + propertyInfo->GetName() + L"\" in \"" + propertyInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
				}
				else if (methodInfo)
				{
					if (methodInfo->GetName() == L"")
					{
						return L"constructor in " + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
					else
					{
						return L"method \"" + methodInfo->GetName() + L"\" in \"" + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
				}
				else if (eventInfo)
				{
					return L"event \"" + eventInfo->GetName() + L"\" in \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"";
				}
				else if (type)
				{
					return L"expression" + typeName;
				}
				else
				{
					return L"<unknown>";
				}
			}

/***********************************************************************
WfLexicalScopeManager
***********************************************************************/

			void WfLexicalScopeManager::BuildGlobalNameFromTypeDescriptors()
			{
				for (vint i = 0; i < GetGlobalTypeManager()->GetTypeDescriptorCount(); i++)
				{
					ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(i);
					WString name = typeDescriptor->GetTypeName();
					const wchar_t* reading = name.Buffer();
					Ptr<WfLexicalScopeName> currentName = globalName;

					while (true)
					{
						WString fragment;
						const wchar_t* delimiter = wcsstr(reading, L"::");
						if (delimiter)
						{
							fragment = WString(reading, delimiter - reading);
							reading = delimiter + 2;
						}
						else
						{
							fragment = reading;
							reading = 0;
						}

						currentName = currentName->AccessChild(fragment, true);
						if (!reading)
						{
							currentName->typeDescriptor = typeDescriptor;
							break;
						}
					}
				}
			}

			void WfLexicalScopeManager::BuildGlobalNameFromModules()
			{
				FOREACH(Ptr<WfModule>, module, modules)
				{
					FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
					{
						BuildName(globalName, declaration);
					}
				}
			}

			void WfLexicalScopeManager::BuildName(Ptr<WfLexicalScopeName> name, Ptr<WfDeclaration> declaration)
			{
				name = name->AccessChild(declaration->name.value, false);
				name->declarations.Add(declaration);
				if (auto ns = declaration.Cast<WfNamespaceDeclaration>())
				{
					namespaceNames.Add(ns, name);
					FOREACH(Ptr<WfDeclaration>, subDecl, ns->declarations)
					{
						BuildName(name, subDecl);
					}
				}
			}

			class ValidateScopeNameDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				enum Category
				{
					None,
					Type,
					Variable,
					Function,
					Namespace,
				};

				WfLexicalScopeManager*				manager;
				Ptr<WfLexicalScopeName>				name;
				Category							category;

				ValidateScopeNameDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _name)
					:manager(_manager)
					, name(_name)
					, category(_name->typeDescriptor ? Type : None)
				{
				}

				void AddError(WfDeclaration* node)
				{
					WString categoryName;
					switch (category)
					{
					case Type:
						categoryName = L"type";
						break;
					case Variable:
						categoryName = L"variable";
						break;
					case Function:
						categoryName = L"function";
						break;
					case Namespace:
						categoryName = L"namespace";
						break;
					default:
						CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::AddError(WfDeclaration*)#Internal error.");
					}
					manager->errors.Add(WfErrors::DuplicatedDeclaration(node, categoryName));
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					if (category == None)
					{
						category = Namespace;
					}
					else if (category != Namespace)
					{
						AddError(node);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (category == None)
					{
						category = Function;
					}
					else if (category != Function)
					{
						AddError(node);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (category == None)
					{
						category = Variable;
					}
					else
					{
						AddError(node);
					}
				}
			};

			void WfLexicalScopeManager::ValidateScopeName(Ptr<WfLexicalScopeName> name)
			{
				ValidateScopeNameDeclarationVisitor visitor(this, name);
				FOREACH(Ptr<WfDeclaration>, declaration, name->declarations)
				{
					declaration->Accept(&visitor);
				}

				FOREACH(Ptr<WfLexicalScopeName>, child, name->children.Values())
				{
					ValidateScopeName(child);
				}
			}

			WfLexicalScopeManager::WfLexicalScopeManager(Ptr<parsing::tabling::ParsingTable> _parsingTable)
				:parsingTable(_parsingTable)
			{
			}

			WfLexicalScopeManager::~WfLexicalScopeManager()
			{
			}

			Ptr<WfModule> WfLexicalScopeManager::AddModule(const WString& moduleCode, vint codeIndex)
			{
				if (auto module = WfParseModule(moduleCode, parsingTable, errors, codeIndex))
				{
					modules.Add(module);
					return module;
				}
				return 0;
			}

			void WfLexicalScopeManager::Clear(bool keepTypeDescriptorNames, bool deleteModules)
			{
				if (globalName)
				{
					if (keepTypeDescriptorNames)
					{
						globalName->RemoveNonTypeDescriptorNames();
					}
					else
					{
						globalName = 0;
					}
				}
				
				if (deleteModules)
				{
					modules.Clear();
				}

				errors.Clear();
				namespaceNames.Clear();
				moduleScopes.Clear();
				declarationScopes.Clear();
				statementScopes.Clear();
				expressionScopes.Clear();
			}

			void WfLexicalScopeManager::Rebuild(bool keepTypeDescriptorNames)
			{
				Clear(keepTypeDescriptorNames, false);
				if (!globalName)
				{
					globalName = new WfLexicalScopeName(true);
					BuildGlobalNameFromTypeDescriptors();
				}

				vint errorCount = errors.Count();

#define EXIT_IF_ERRORS_EXIST\
				do\
				{\
					if (errors.Count() != errorCount) return;\
				}while (0)
				
				EXIT_IF_ERRORS_EXIST;
				FOREACH(Ptr<WfModule>, module, modules)
				{
					ValidateModuleStructure(this, module);
				}
				
				EXIT_IF_ERRORS_EXIST;
				BuildGlobalNameFromModules();
				FOREACH(Ptr<WfModule>, module, modules)
				{
					BuildScopeForModule(this, module);
				}

				ValidateScopeName(globalName);
				
				SortedList<Ptr<WfLexicalScope>> analyzedScopes;
				FOREACH(Ptr<WfLexicalScope>, scope,
					From(moduleScopes.Values())
						.Concat(declarationScopes.Values())
						.Concat(statementScopes.Values())
						.Concat(expressionScopes.Values()))
				{
					if (!analyzedScopes.Contains(scope.Obj()))
					{
						analyzedScopes.Add(scope);

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							const auto& symbols = scope->symbols.GetByIndex(i);
							if (symbols.Count() > 1)
							{
								if (!scope->ownerModule && !scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
								{
									if (symbols.Count() > 1)
									{
										FOREACH(Ptr<WfLexicalSymbol>, symbol, From(symbols))
										{
											if (symbol->creatorDeclaration)
											{
												if (!symbol->creatorDeclaration.Cast<WfFunctionDeclaration>())
												{
													errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorDeclaration.Obj(), symbol));
												}
											}
											else if (symbol->creatorArgument)
											{
												errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorArgument.Obj(), symbol));
											}
											else if (symbol->creatorStatement)
											{
												errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorStatement.Obj(), symbol));
											}
											else if (symbol->creatorExpression)
											{
												errors.Add(WfErrors::DuplicatedSymbol(symbol->creatorExpression.Obj(), symbol));
											}
										}
									}
								}
							}
						}

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							FOREACH(Ptr<WfLexicalSymbol>, symbol, scope->symbols.GetByIndex(i))
							{
								if (symbol->type)
								{
									symbol->typeInfo = CreateTypeInfoFromType(scope.Obj(), symbol->type);
								}
							}
						}
					}
				}
				
				EXIT_IF_ERRORS_EXIST;
				FOREACH(Ptr<WfModule>, module, modules)
				{
					ValidateModuleSemantic(this, module);
				}

#undef EXIT_IF_ERRORS_EXIST
			}
			
			void WfLexicalScopeManager::ResolveSymbol(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalSymbol>>& symbols)
			{
				while (scope && !scope->ownerModule && !scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
				{
					vint index = scope->symbols.Keys().IndexOf(symbolName);
					if (index != -1)
					{
						CopyFrom(symbols, scope->symbols.GetByIndex(index), true);
					}
					scope = scope->parentScope.Obj();
				}
			}

			class UsingPathToNameVisitor :public Object, public WfModuleUsingFragment::IVisitor
			{
			public:
				WString					name;
				WString					result;

				UsingPathToNameVisitor(const WString& _name)
					:name(_name)
				{
				}

				void Visit(WfModuleUsingNameFragment* node)
				{
					result = node->name.value;
				}

				void Visit(WfModuleUsingWildCardFragment* node)
				{
					result = name;
				}

				static WString Execute(Ptr<WfModuleUsingFragment> fragment, const WString& name)
				{
					UsingPathToNameVisitor visitor(name);
					fragment->Accept(&visitor);
					return visitor.result;
				}
			};

			void WfLexicalScopeManager::ResolveScopeName(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalScopeName>>& names)
			{
				while (scope)
				{
					if (scope->ownerModule || scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
					{
						break;
					}
					scope = scope->parentScope.Obj();
				}

				List<WString> namespacePath;
				Ptr<WfModule> module;
				while (scope)
				{
					if (auto ns = scope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
					{
						namespacePath.Add(ns->name.value);
					}
					if (!module)
					{
						module = scope->ownerModule;
					}
					scope = scope->parentScope.Obj();
				}

				Ptr<WfLexicalScopeName> scopeName = globalName;
				vint nsIndex = namespacePath.Count();
				while (scopeName)
				{
					vint index = scopeName->children.Keys().IndexOf(symbolName);
					if (index != -1)
					{
						names.Add(scopeName->children.Values()[index]);
					}

					if (--nsIndex < 0) break;
					index = scopeName->children.Keys().IndexOf(namespacePath[nsIndex]);
					if (index == -1) break;
					scopeName = scopeName->children.Values()[index];
				}

				FOREACH(Ptr<WfModuleUsingPath>, path, module->paths)
				{
					scopeName = globalName;
					FOREACH(Ptr<WfModuleUsingItem>, item, path->items)
					{
						WString name;
						FOREACH(Ptr<WfModuleUsingFragment>, fragment, item->fragments)
						{
							name += UsingPathToNameVisitor::Execute(fragment, symbolName);
						}
						vint index = scopeName->children.Keys().IndexOf(name);
						if (index == -1) goto USING_PATH_MATCHING_FAILED;
						scopeName = scopeName->children.Values()[index];
					}
					names.Add(scopeName);
				USING_PATH_MATCHING_FAILED:;
				}
			}

/***********************************************************************
WfCodegenFunctionContext
***********************************************************************/

			Ptr<WfCodegenLoopContext> WfCodegenFunctionContext::GetCurrentLoopContext()
			{
				return loopContextStack[loopContextStack.Count() - 1];
			}

/***********************************************************************
WfCodegenContext
***********************************************************************/

			WfCodegenContext::WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, WfLexicalScopeManager* _manager)
				:assembly(_assembly)
				, manager(_manager)
			{
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_BuildScope.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
BuildScopeForDeclaration
***********************************************************************/

			class BuildScopeForDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ParsingTreeCustomBase*					source;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope, ParsingTreeCustomBase* _source)
					:manager(_manager)
					, source(_source)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					parentScope->symbols.Add(symbol->name, symbol);

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						BuildScopeForDeclaration(manager, resultScope, declaration);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					if (node->anonymity == WfFunctionAnonymity::Named)
					{
						Ptr<WfLexicalScope> functionNameScope = parentScope;
						if (source && dynamic_cast<WfFunctionExpression*>(source))
						{
							functionNameScope = resultScope;
						}

						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(functionNameScope.Obj());
						symbol->name = node->name.value;
						symbol->creatorDeclaration = node;
						{
							Ptr<WfFunctionType> type = new WfFunctionType;
							type->result = node->returnType;
							FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
							{
								type->arguments.Add(argument->type);
							}
							symbol->type = type;
						}
						functionNameScope->symbols.Add(symbol->name, symbol);
					}

					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						Ptr<WfLexicalSymbol> argumentSymbol = new WfLexicalSymbol(resultScope.Obj());
						argumentSymbol->name = argument->name.value;
						argumentSymbol->type = argument->type;
						argumentSymbol->creatorArgument = argument;
						resultScope->symbols.Add(argumentSymbol->name, argumentSymbol);
					}

					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(parentScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorDeclaration = node;
					{
						symbol->type = node->type;
					}
					parentScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, ParsingTreeCustomBase* source, Ptr<WfDeclaration> declaration)
				{
					BuildScopeForDeclarationVisitor visitor(manager, parentScope, source);
					declaration->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->declarationScopes.Add(declaration, visitor.resultScope);
						visitor.resultScope->ownerDeclaration = declaration;
					}
					else
					{
						manager->declarationScopes.Add(declaration, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForStatement
***********************************************************************/

			class BuildScopeForStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForStatementVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);
					if (node->type)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = node->name.value;
						symbol->type = node->type;
						symbol->creatorStatement = node;
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
					BuildScopeForStatement(manager, resultScope, node->trueBranch);
					if (node->falseBranch)
					{
						BuildScopeForStatement(manager, resultScope, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						BuildScopeForExpression(manager, parentScope, switchCase->expression);
						BuildScopeForStatement(manager, parentScope, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						BuildScopeForStatement(manager, parentScope, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForStatement(manager, parentScope, node->statement);
				}

				void Visit(WfForEachStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
					symbol->name = node->name.value;
					symbol->creatorStatement = node;
					resultScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->collection);
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					BuildScopeForStatement(manager, parentScope, node->protectedStatement);
					if (node->catchStatement)
					{
						resultScope = new WfLexicalScope(parentScope);

						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = node->name.value;
						symbol->creatorStatement = node;
						{
							Ptr<WfPredefinedType> type = new WfPredefinedType;
							type->name = WfPredefinedTypeName::Object;
							symbol->type = type;
						}
						resultScope->symbols.Add(symbol->name, symbol);

						BuildScopeForStatement(manager, resultScope, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						BuildScopeForStatement(manager, parentScope, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					resultScope = new WfLexicalScope(parentScope);

					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						BuildScopeForStatement(manager, resultScope, statement);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					BuildScopeForDeclaration(manager, parentScope, node->variable, node);
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
				{
					BuildScopeForStatementVisitor visitor(manager, parentScope);
					statement->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->statementScopes.Add(statement, visitor.resultScope);
						visitor.resultScope->ownerStatement = statement;
					}
					else
					{
						manager->statementScopes.Add(statement, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForExpression
***********************************************************************/

			class BuildScopeForExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					SortedList<vint> names;
					SearchOrderedName(node->body, names);

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(vint, name, names)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = L"$" + itow(name);
						symbol->creatorExpression = node;
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->body);
				}

				void Visit(WfMemberExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (node->expandedExpression)
					{
						BuildScopeForExpression(manager, parentScope, node->expandedExpression);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->first);
					BuildScopeForExpression(manager, parentScope, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
						symbol->name = variable->name.value;
						symbol->creatorExpression = node;
						resultScope->symbols.Add(symbol->name, symbol);
						BuildScopeForExpression(manager, resultScope, variable->value);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForExpression(manager, parentScope, node->trueBranch);
					BuildScopeForExpression(manager, parentScope, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->begin);
					BuildScopeForExpression(manager, parentScope, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->element);
					BuildScopeForExpression(manager, parentScope, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument->key);
						if (argument->value)
						{
							BuildScopeForExpression(manager, parentScope, argument->value);
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->event);
					BuildScopeForExpression(manager, parentScope, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->handler);
				}

				void Visit(WfBindExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfObserveExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
					if (node->observeType == WfObserveType::SimpleObserve)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							BuildScopeForExpression(manager, parentScope, event);
						}
					}
					else
					{
						resultScope = new WfLexicalScope(parentScope);
						{
							Ptr<WfLexicalSymbol> symbol = new WfLexicalSymbol(resultScope.Obj());
							symbol->name = node->name.value;
							symbol->creatorExpression = node;
							resultScope->symbols.Add(symbol->name, symbol);
						}

						BuildScopeForExpression(manager, resultScope, node->expression);
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							BuildScopeForExpression(manager, resultScope, event);
						}
					}
				}

				void Visit(WfCallExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->function);
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					BuildScopeForDeclaration(manager, parentScope, node->function, node);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}

					resultScope = new WfLexicalScope(parentScope);
					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						BuildScopeForDeclaration(manager, resultScope, function);
					}
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
				{
					BuildScopeForExpressionVisitor visitor(manager, parentScope);
					expression->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->expressionScopes.Add(expression, visitor.resultScope);
						visitor.resultScope->ownerExpression = expression;
					}
					else
					{
						manager->expressionScopes.Add(expression, parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScope
***********************************************************************/

			void BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				Ptr<WfLexicalScope> scope = new WfLexicalScope(manager);
				scope->ownerModule = module;
				manager->moduleScopes.Add(module, scope);

				FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
				{
					BuildScopeForDeclaration(manager, scope, declaration);
				}
			}

			void BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, parsing::ParsingTreeCustomBase* source)
			{
				BuildScopeForDeclarationVisitor::Execute(manager, parentScope, source, declaration);
			}

			void BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
			{
				BuildScopeForStatementVisitor::Execute(manager, parentScope, statement);
			}

			void BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
			{
				BuildScopeForExpressionVisitor::Execute(manager, parentScope, expression);
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_Errors.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfErrors
***********************************************************************/

			Ptr<parsing::ParsingError> WfErrors::WrongFormatStringSyntax(WfExpression* node)
			{
				return new ParsingError(node, L"A0: Wrong format string syntax.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongSimpleObserveExpression(WfExpression* node)
			{
				return new ParsingError(node, L"A1: Simple observe expression should observe a property under the observed object.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongSimpleObserveEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A2: Simple observe expression should react to an event under the observed object.");
			}

			Ptr<parsing::ParsingError> WfErrors::EmptyExtendedObserveEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A2: Extended observe expression should react to at least one event.");
			}

			Ptr<parsing::ParsingError> WfErrors::ObserveNotInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A3: Observe expression should appear in a bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::BindInBind(WfExpression* node)
			{
				return new ParsingError(node, L"A4: Bind expression should not appear in another bind expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorMixMapAndList(WfExpression* node)
			{
				return new ParsingError(node, L"A5: Key-value pairs are not allowed in list constructor expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorMixClassAndInterface(WfExpression* node)
			{
				return new ParsingError(node, L"A6: Functions are not allowed in class constructor expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return new ParsingError(node, L"A7: Symbol \"" + scopeName->GetFriendlyName() + L"\" cannot be used as an expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo)
			{
				return new ParsingError(node, L"A7: Event \"" + eventInfo->GetName() + L"\" of type \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\" cannot be used as an expression.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotScopeName(WfExpression* node)
			{
				return new ParsingError(node, L"A8: Expression does not reference to a declaration.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotEvent(WfExpression* node)
			{
				return new ParsingError(node, L"A8: Expression does not reference to an event.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"A9: Expression referencing to symbol \"" + symbol->name + L"\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Expression \"null\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Expression \"{}\" failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::OrderedLambdaCannotResolveType(WfExpression* node)
			{
				return new ParsingError(node, L"A9: Ordered lambda expression failed to resolve its type.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression \"null\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression \"{}\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Ordered lambda expression cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A10: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A11: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot explicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A12: Expression cannot weakly cast to \"" + toType->GetTypeFriendlyName() + L"\" because it cannot be \"null\".");
			}

			Ptr<parsing::ParsingError> WfErrors::IntegerLiteralOutOfRange(WfIntegerExpression* node)
			{
				return new ParsingError(node, L"A13: Integer literal \"" + node->value.value + L"\" out of range.");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType)
			{
				return new ParsingError(node, L"A14: Failed to merge type \"" + firstType->GetTypeFriendlyName() + L"\" with type \"" + secondType->GetTypeFriendlyName() + L"\" together to calculate the result type.");
			}

			Ptr<parsing::ParsingError> WfErrors::RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A15: Elements in a range expression should be integer, not \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A16: Unary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A16: Binary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType)
			{
				return new ParsingError(node, L"A17: Container of type \"" + containerType->GetTypeFriendlyName() + L"\" cannot be accessed using index.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A18: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an enumerable type.");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A19: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an invokable function type.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionArgumentCountMismatched(WfExpression* node, vint expectedCount, const ResolveExpressionResult& function)
			{
				return new ParsingError(node, L"A20: Function " + function.GetFriendlyName() + L"\" is not allowed to call with " + itow(expectedCount) + L" arguments.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionArgumentTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A21: The " + itow(index) + L"-th argument of function " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedFunctions(WfExpression* node, collections::List<ResolveExpressionResult>& results)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"A22: Cannot decide which function to call in multiple targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"A23: Class \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor.");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				Ptr<ITypeInfo> proxy = TypeInfoRetriver<Ptr<IValueInterfaceProxy>>::CreateTypeInfo();
				return new ParsingError(node, L"A23: Interface \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor receiving an \"" + proxy->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return new ParsingError(node, L"A24: The return type of " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result)
			{
				return new ParsingError(node, L"A25: Expression " + result.GetFriendlyName() + L" is not assignable.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongVoidType(WfType* node)
			{
				return new ParsingError(node, L"B0: Void is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongInterfaceType(WfType* node)
			{
				return new ParsingError(node, L"B1: Interface is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B2: A raw pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			Ptr<parsing::ParsingError> WfErrors::SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B3: A shared pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			Ptr<parsing::ParsingError> WfErrors::NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B4: A nullable value" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a struct.");
			}

			Ptr<parsing::ParsingError> WfErrors::ChildOfNonReferenceType(WfType* node)
			{
				return new ParsingError(node, L"B5: Only a reference type have child types.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return new ParsingError(node, L"B6: \"" + scopeName->GetFriendlyName() + L"\" is not a type.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotExists(WfType* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"B6: \"" + symbol->name + L"\" is not a type.");
			}

			Ptr<parsing::ParsingError> WfErrors::TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return new ParsingError(node, L"B7: Type \"" + typeInfo->GetTypeFriendlyName() + L"\" is not a type for a value.");
			}

			Ptr<parsing::ParsingError> WfErrors::BreakNotInLoop(WfStatement* node)
			{
				return new ParsingError(node, L"C0: Break statement should appear in a loop.");
			}

			Ptr<parsing::ParsingError> WfErrors::ContinueNotInLoop(WfStatement* node)
			{
				return new ParsingError(node, L"C1: Continue statement should appear in a loop.");
			}

			Ptr<parsing::ParsingError> WfErrors::RethrowNotInCatch(WfStatement* node)
			{
				return new ParsingError(node, L"C2: Re-raise exception statement should appear in catch.");
			}

			Ptr<parsing::ParsingError> WfErrors::TryMissCatchAndFinally(WfStatement* node)
			{
				return new ParsingError(node, L"C3: Try statement should not appear without both catch and finally.");
			}

			Ptr<parsing::ParsingError> WfErrors::ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"C4: Return statement requires an expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"C5: Delete statement cannot apply on an expression of type \"" + type->GetTypeFriendlyName() + L"\", which is expected to be a raw pointer.");
			}

			Ptr<parsing::ParsingError> WfErrors::FunctionShouldHaveName(WfDeclaration* node)
			{
				return new ParsingError(node, L"D0: Function should have a name.");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory)
			{
				return new ParsingError(node, L"D1: Duplicated declaration \"" + node->name.value + L"\", it has already beed defined as a " + firstDeclarationCategory + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return new ParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceMethodNotImplemented(WfNewTypeExpression* node, reflection::description::IMethodInfo* method)
			{
				ResolveExpressionResult result(method, CreateTypeInfoFromMethodInfo(method));
				return new ParsingError(node, L"D3: Interface method not implemented: " + result.GetFriendlyName() + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType)
			{
				return new ParsingError(node, L"D4: Interface \"" + interfaceType->GetTypeFriendlyName() + L"\" does not contain method \"" + node->name.value + L"\" which is in type \"" + methodType->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"D5: Cannot decide which function to implement in multiple targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type)
			{
				return new ParsingError(node, L"D6: There are some other methods named \"" + node->name.value + L"\" whose types are also \"" + type->GetTypeFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::WrongUsingPathWildCard(WfModuleUsingPath* node)
			{
				return new ParsingError(node, L"E0: Wild card \"*\" should only appear in the last item of the using path and should appear once.");
			}

			Ptr<parsing::ParsingError> WfErrors::TopQualifiedSymbolNotExists(parsing::ParsingTreeCustomBase* node, const WString& name)
			{
				return new ParsingError(node, L"F0: Top qualified symbol \"" + name + L"\" does not exist.");
			}

			Ptr<parsing::ParsingError> WfErrors::ChildSymbolNotExists(parsing::ParsingTreeCustomBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name)
			{
				return new ParsingError(node, L"F1: Symbol \"" + name + L"\" does not exist in \"" + scopeName->GetFriendlyName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::MemberNotExists(parsing::ParsingTreeCustomBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name)
			{
				return new ParsingError(node, L"F1: Member \"" + name + L"\" does not exist in \"" + typeDescriptor->GetTypeName() + L"\".");
			}

			Ptr<parsing::ParsingError> WfErrors::ReferenceNotExists(parsing::ParsingTreeCustomBase* node, const WString& name)
			{
				return new ParsingError(node, L"F2: Symbol \"" + name + L"\" does not exist in the current scope.");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<ResolveExpressionResult>& results, const WString& name)
			{
				WString description;
				FOREACH_INDEXER(ResolveExpressionResult, result, index, results)
				{
					description += L"\r\n\t";
					description += result.GetFriendlyName();
				}
				return new ParsingError(node, L"F3: Symbol \"" + name + L"\" references to too many targets: " + description + L".");
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalSymbol>>& symbols, const WString& name)
			{
				List<ResolveExpressionResult> results;
				CopyFrom(
					results,
					From(symbols)
					.Select([](Ptr<WfLexicalSymbol> symbol)
					{
						return ResolveExpressionResult(symbol, 0);
					}));
				return TooManyTargets(node, results, name);
			}

			Ptr<parsing::ParsingError> WfErrors::TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalScopeName>>& names, const WString& name)
			{
				List<ResolveExpressionResult> results;
				CopyFrom(
					results,
					From(names)
					.Select([](Ptr<WfLexicalScopeName> name)
					{
						return ResolveExpressionResult(name);
					}));
				return TooManyTargets(node, results, name);
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_GenerateAssembly.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace regex;
			using namespace parsing;
			using namespace reflection;
			using namespace reflection::description;
			using namespace runtime;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.assembly->instructions.Add(X)

/***********************************************************************
GenerateGlobalDeclarationMetadata
***********************************************************************/

			class GenerateGlobalDeclarationMetadataVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WString									namePrefix;

				GenerateGlobalDeclarationMetadataVisitor(WfCodegenContext& _context, const WString& _namePrefix)
					:context(_context)
					, namePrefix(_namePrefix)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, decl, node->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl, namePrefix + node->name.value + L"::");
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto meta = MakePtr<WfAssemblyFunction>();
					meta->name = namePrefix + node->name.value;
					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						meta->argumentNames.Add(argument->name.value);
					}

					vint index = context.assembly->functions.Add(meta);
					context.assembly->functionByName.Add(meta->name, index);

					auto scope = context.manager->declarationScopes[node]->parentScope.Obj();
					auto symbol = From(scope->symbols[node->name.value])
						.Where([=](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorDeclaration == node;
						})
						.First();
					context.globalFunctions.Add(symbol.Obj(), index);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					vint index = context.assembly->variableNames.Add(namePrefix + node->name.value);

					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					context.globalVariables.Add(symbol.Obj(), index);
				}
			};

			void GenerateGlobalDeclarationMetadata(WfCodegenContext& context, Ptr<WfDeclaration> declaration, const WString& namePrefix)
			{
				GenerateGlobalDeclarationMetadataVisitor visitor(context, namePrefix);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Initialize)
***********************************************************************/

			class GenerateInitializeInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateInitializeInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = context.manager->declarationScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					vint variableIndex = context.globalVariables[symbol.Obj()];
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
				}
			};

			void GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration)
			{
				GenerateInitializeInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Declaration)
***********************************************************************/

			class GenerateDeclarationInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateDeclarationInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto scope = context.manager->declarationScopes[node];
					auto symbol = From(scope->parentScope->symbols[node->name.value])
						.Where([=](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorDeclaration == node;
						})
						.First();
					auto meta = context.assembly->functions[context.globalFunctions[symbol.Obj()]];

					auto functionContext = MakePtr<WfCodegenFunctionContext>();
					functionContext->function = meta;
					context.functionContext = functionContext;
					FOREACH_INDEXER(Ptr<WfFunctionArgument>, argument, index, node->arguments)
					{
						auto argumentSymbol = scope->symbols[argument->name.value][0];
						functionContext->arguments.Add(argumentSymbol.Obj(), index);
					}
					
					meta->firstInstruction = context.assembly->instructions.Count();
					GenerateStatementInstructions(context, node->statement);
					auto returnType = symbol->typeInfo->GetElementType()->GetGenericArgument(0);
					if (returnType->GetDecorator() == ITypeInfo::TypeDescriptor && returnType->GetTypeDescriptor()->GetValueSerializer())
					{
						auto serializer = returnType->GetTypeDescriptor()->GetValueSerializer();
						auto defaultText = serializer->GetDefaultText();
						Value result;
						serializer->Parse(defaultText, result);
						INSTRUCTION(Ins::LoadValue(result));
					}
					else
					{
						INSTRUCTION(Ins::LoadValue(Value()));
					}
					INSTRUCTION(Ins::Return());
					meta->lastInstruction = context.assembly->instructions.Count() - 1;
					context.functionContext = 0;

					GenerateClosureInstructions(context, functionContext);
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}
			};

			void GenerateDeclarationInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration)
			{
				GenerateDeclarationInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Closure)
***********************************************************************/

			void GenerateClosureInstructions_StaticMethod(WfCodegenContext& context, vint functionIndex, WfExpression* expression)
			{
				auto result = context.manager->expressionResolvings[expression];
				auto methodInfo = result.methodInfo;
				auto meta = context.assembly->functions[functionIndex];

				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					meta->argumentNames.Add(methodInfo->GetParameter(j)->GetName());
				}

				meta->firstInstruction = context.assembly->instructions.Count();
				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					INSTRUCTION(Ins::LoadLocalVar(j));
				}
				INSTRUCTION(Ins::LoadValue(Value()));
				INSTRUCTION(Ins::InvokeMethod(methodInfo, methodInfo->GetParameterCount()));
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
			}

			void GenerateClosureInstructions_Method(WfCodegenContext& context, vint functionIndex, WfMemberExpression* expression)
			{
				auto result = context.manager->expressionResolvings[expression];
				auto methodInfo = result.methodInfo;
				auto meta = context.assembly->functions[functionIndex];

				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					meta->argumentNames.Add(methodInfo->GetParameter(j)->GetName());
				}
				meta->capturedVariableNames.Add(L"<this>");

				meta->firstInstruction = context.assembly->instructions.Count();
				for (vint j = 0; j < methodInfo->GetParameterCount(); j++)
				{
					INSTRUCTION(Ins::LoadLocalVar(j));
				}
				INSTRUCTION(Ins::LoadCapturedVar(0));
				INSTRUCTION(Ins::InvokeMethod(methodInfo, methodInfo->GetParameterCount()));
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
			}

			void GenerateClosureInstructions_Function(WfCodegenContext& context, vint functionIndex, WfFunctionExpression* expression)
			{
				// next version
				throw 0;
			}

			void GenerateClosureInstructions_Ordered(WfCodegenContext& context, vint functionIndex, WfOrderedLambdaExpression* expression)
			{
				// next version
				throw 0;
			}

			void GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext)
			{
				for (vint i = 0; i < functionContext->closuresToCodegen.Count(); i++)
				{
					vint functionIndex = functionContext->closuresToCodegen.Keys()[i];
					auto closure = functionContext->closuresToCodegen.Values()[i];
					
					if (closure.staticMethodReferenceExpression)
					{
						GenerateClosureInstructions_StaticMethod(context, functionIndex, closure.staticMethodReferenceExpression);
					}
					else if (closure.methodReferenceExpression)
					{
						GenerateClosureInstructions_Method(context, functionIndex, closure.methodReferenceExpression);
					}
					else if (closure.functionExpression)
					{
						GenerateClosureInstructions_Function(context, functionIndex, closure.functionExpression);
					}
					else if (closure.orderedLambdaExpression)
					{
						GenerateClosureInstructions_Ordered(context, functionIndex, closure.orderedLambdaExpression);
					}
				}
			}

/***********************************************************************
GenerateInstructions(Statement)
***********************************************************************/

			class GenerateStatementInstructionsVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateStatementInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
					// next version: inline try-finally
					context.functionContext->GetCurrentLoopContext()->breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfContinueStatement* node)override
				{
					// next version: inline try-finally
					context.functionContext->GetCurrentLoopContext()->continueInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfReturnStatement* node)override
				{
					// next version: inline try-finally
					if (node->expression)
					{
						GenerateExpressionInstructions(context, node->expression);
					}
					else
					{
						INSTRUCTION(Ins::LoadValue(Value()));
					}
					INSTRUCTION(Ins::Return());
				}

				void Visit(WfDeleteStatement* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					// next version: inline exit code
					// next version
					throw 0;
				}

				void Visit(WfIfStatement* node)override
				{
					vint variableIndex = -1;

					GenerateExpressionInstructions(context, node->expression);
					if (node->name.value != L"")
					{
						auto scope = context.manager->statementScopes[node];
						auto symbol = scope->symbols[node->name.value][0];
						auto function = context.functionContext->function;
						variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<if>" + node->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);

						GenerateTypeCastInstructions(context, symbol->typeInfo, false);
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
					}
					else
					{
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					}
					vint fillElseIndex = INSTRUCTION(Ins::JumpIf(-1));

					GenerateStatementInstructions(context, node->trueBranch);
					if (variableIndex != -1)
					{
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					context.assembly->instructions[fillElseIndex].indexParameter = context.assembly->instructions.Count();

					if (node->falseBranch)
					{
						GenerateStatementInstructions(context, node->falseBranch);
					}
					context.assembly->instructions[fillEndIndex].indexParameter = context.assembly->instructions.Count();
				}

				void Visit(WfSwitchStatement* node)override
				{
					auto function = context.functionContext->function;
					vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<switch>");
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::StoreLocalVar(variableIndex));

					List<vint> caseInstructions, caseLabelIndices, breakInstructions;
					auto expressionResult = context.manager->expressionResolvings[node->expression.Obj()];
					auto expressionType = expressionResult.expectedType ? expressionResult.expectedType : expressionResult.type;
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						auto caseResult = context.manager->expressionResolvings[switchCase->expression.Obj()];
						auto caseType = caseResult.expectedType ? caseResult.expectedType : caseResult.type;
						auto mergedType = GetMergedType(expressionType, caseType);

						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						if (!IsSameType(expressionType.Obj(), mergedType.Obj()))
						{
							GenerateTypeCastInstructions(context, mergedType, true);
						}
						GenerateExpressionInstructions(context, switchCase->expression);
						if (!IsSameType(caseType.Obj(), mergedType.Obj()))
						{
							GenerateTypeCastInstructions(context, mergedType, true);
						}
						if (mergedType->GetDecorator() == ITypeInfo::RawPtr || mergedType->GetDecorator() == ITypeInfo::SharedPtr)
						{
							INSTRUCTION(Ins::CompareReference());
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						else
						{
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpNE());
						}
						caseInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));

						GenerateStatementInstructions(context, switchCase->statement);
						breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
						caseLabelIndices.Add(context.assembly->instructions.Count());
					}

					if (node->defaultBranch)
					{
						GenerateStatementInstructions(context, node->defaultBranch);
					}
					
					vint breakLabelIndex = context.assembly->instructions.Count();
					for (vint i = 0; i < caseInstructions.Count(); i++)
					{
						context.assembly->instructions[caseInstructions[i]].indexParameter = caseLabelIndices[i];
					}
					FOREACH(vint, index, breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					// next version: mark exit code
					INSTRUCTION(Ins::LoadValue(Value()));
					INSTRUCTION(Ins::StoreLocalVar(variableIndex));
				}

				void Visit(WfWhileStatement* node)override
				{
					vint continueLabelIndex = -1;
					vint breakLabelIndex = -1;
					vint loopLabelIndex = -1;
					auto loopContext = MakePtr<WfCodegenLoopContext>();
					context.functionContext->loopContextStack.Add(loopContext);

					loopLabelIndex = context.assembly->instructions.Count();
					continueLabelIndex = context.assembly->instructions.Count();
					GenerateExpressionInstructions(context, node->condition);
					INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
					GenerateStatementInstructions(context, node->statement);
					INSTRUCTION(Ins::Jump(loopLabelIndex));
					breakLabelIndex = context.assembly->instructions.Count();

					FOREACH(vint, index, loopContext->continueInstructions)
					{
						context.assembly->instructions[index].indexParameter = continueLabelIndex;
					}
					FOREACH(vint, index, loopContext->breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					context.functionContext->loopContextStack.RemoveAt(context.functionContext->loopContextStack.Count() - 1);
				}

				void Visit(WfForEachStatement* node)override
				{
					vint continueLabelIndex = -1;
					vint breakLabelIndex = -1;
					vint loopLabelIndex = -1;
					auto loopContext = MakePtr<WfCodegenLoopContext>();
					context.functionContext->loopContextStack.Add(loopContext);

					auto scope = context.manager->statementScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					auto function = context.functionContext->function;
					vint elementIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for>" + node->name.value);
					context.functionContext->localVariables.Add(symbol.Obj(), elementIndex);

					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto typeArgument = GetInstructionTypeArgument(symbol->typeInfo);
						vint beginIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-begin>" + node->name.value);
						vint endIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-end>" + node->name.value);
						GenerateExpressionInstructions(context, range->begin, symbol->typeInfo);
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpAdd(typeArgument));
						}
						INSTRUCTION(Ins::StoreLocalVar(beginIndex));
						GenerateExpressionInstructions(context, range->end, symbol->typeInfo);
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpSub(typeArgument));
						}
						INSTRUCTION(Ins::StoreLocalVar(endIndex));

						if (node->direction == WfForEachDirection::Normal)
						{
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
							loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpGT());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						}
						else
						{
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
							loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpLT());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						}
						GenerateStatementInstructions(context, node->statement);
						continueLabelIndex = context.assembly->instructions.Count();
						if (node->direction == WfForEachDirection::Normal)
						{
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(endIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpEQ());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpAdd(typeArgument));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						}
						else
						{
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadLocalVar(beginIndex));
							INSTRUCTION(Ins::CompareLiteral(typeArgument));
							INSTRUCTION(Ins::OpEQ());
							loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
							INSTRUCTION(Ins::LoadLocalVar(elementIndex));
							INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
							INSTRUCTION(Ins::OpSub(typeArgument));
							INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						}
						INSTRUCTION(Ins::Jump(loopLabelIndex));

						breakLabelIndex = context.assembly->instructions.Count();
						// next version: mark exit code
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(beginIndex));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(endIndex));
					}
					else
					{
						vint enumerableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-enumerable>" + node->name.value);
						vint enumeratorIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<for-enumerator>" + node->name.value);
						auto methodCreateEnumerator = description::GetTypeDescriptor<IValueEnumerable>()->GetMethodGroupByName(L"CreateEnumerator", true)->GetMethod(0);
						auto methodNext = description::GetTypeDescriptor<IValueEnumerator>()->GetMethodGroupByName(L"Next", true)->GetMethod(0);
						auto methodGetCurrent = description::GetTypeDescriptor<IValueEnumerator>()->GetMethodGroupByName(L"GetCurrent", true)->GetMethod(0);

						GenerateExpressionInstructions(context, node->collection);
						if (node->direction == WfForEachDirection::Reversed)
						{
							INSTRUCTION(Ins::ReverseEnumerable());
						}
						INSTRUCTION(Ins::StoreLocalVar(enumerableIndex));
						INSTRUCTION(Ins::LoadLocalVar(enumerableIndex));
						INSTRUCTION(Ins::InvokeMethod(methodCreateEnumerator, 0));
						INSTRUCTION(Ins::StoreLocalVar(enumeratorIndex));
						
						loopLabelIndex = INSTRUCTION(Ins::LoadLocalVar(elementIndex));
						INSTRUCTION(Ins::LoadLocalVar(enumeratorIndex));
						INSTRUCTION(Ins::InvokeMethod(methodNext, 0));
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
						INSTRUCTION(Ins::LoadLocalVar(enumeratorIndex));
						INSTRUCTION(Ins::InvokeMethod(methodGetCurrent, 0));
						INSTRUCTION(Ins::StoreLocalVar(elementIndex));
						GenerateStatementInstructions(context, node->statement);
						continueLabelIndex = context.assembly->instructions.Count();
						INSTRUCTION(Ins::Jump(loopLabelIndex));

						breakLabelIndex = context.assembly->instructions.Count();
						// next version: mark exit code
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(enumerableIndex));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(enumeratorIndex));
					}
					// next version: mark exit code
					INSTRUCTION(Ins::LoadValue(Value()));
					INSTRUCTION(Ins::StoreLocalVar(elementIndex));

					FOREACH(vint, index, loopContext->continueInstructions)
					{
						context.assembly->instructions[index].indexParameter = continueLabelIndex;
					}
					FOREACH(vint, index, loopContext->breakInstructions)
					{
						context.assembly->instructions[index].indexParameter = breakLabelIndex;
					}
					context.functionContext->loopContextStack.RemoveAt(context.functionContext->loopContextStack.Count() - 1);
				}

				void Visit(WfTryStatement* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						GenerateStatementInstructions(context, statement);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::Pop());
				}

				void Visit(WfVariableStatement* node)override
				{
					auto manager = context.manager;
					auto scope = manager->declarationScopes[node->variable.Obj()];
					auto symbol = scope->symbols[node->variable->name.value][0].Obj();
					auto function = context.functionContext->function;
					vint index = function->argumentNames.Count() + function->localVariableNames.Add(node->variable->name.value);
					context.functionContext->localVariables.Add(symbol, index);

					GenerateExpressionInstructions(context, node->variable->expression);
					INSTRUCTION(Ins::StoreLocalVar(index));
				}
			};

			void GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement)
			{
				GenerateStatementInstructionsVisitor visitor(context);
				statement->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Expression)
***********************************************************************/

			class GenerateExpressionInstructionsVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateExpressionInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void VisitReferenceExpression(WfExpression* node)
				{
					auto result = context.manager->expressionResolvings[node];
					vint index = -1;
					if ((index = context.globalFunctions.Keys().IndexOf(result.symbol.Obj())) != -1)
					{
						vint functionIndex = context.globalFunctions.Values()[index];
						INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
					}
					else if ((index = context.globalVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
					{
						vint variableIndex = context.globalVariables.Values()[index];
						INSTRUCTION(Ins::LoadGlobalVar(variableIndex));
					}
					else if ((index = context.functionContext->capturedVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
					{
						vint variableIndex = context.functionContext->capturedVariables.Values()[index];
						INSTRUCTION(Ins::LoadCapturedVar(variableIndex));
					}
					else if ((index = context.functionContext->localVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
					{
						vint variableIndex = context.functionContext->localVariables.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
					else if ((index = context.functionContext->arguments.Keys().IndexOf(result.symbol.Obj())) != -1)
					{
						vint variableIndex = context.functionContext->arguments.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
					else if (result.methodInfo && result.methodInfo->IsStatic())
					{
						auto meta = MakePtr<WfAssemblyFunction>();
						meta->name = result.methodInfo->GetName() + L"<" + result.methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L">";
						vint functionIndex = context.assembly->functions.Add(meta);
						context.assembly->functionByName.Add(meta->name, functionIndex);
						
						WfCodegenLambdaContext lc;
						lc.staticMethodReferenceExpression = node;
						context.functionContext->closuresToCodegen.Add(functionIndex, lc);

						INSTRUCTION(Ins::LoadClosure(functionIndex, 0));
					}
					else
					{
						// next version: named lambda reference
						throw 0;
					}
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfReferenceExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfMemberExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					if (result.propertyInfo)
					{
						GenerateExpressionInstructions(context, node->parent);
						if (result.propertyInfo->GetGetter())
						{
							INSTRUCTION(Ins::InvokeMethod(result.propertyInfo->GetGetter(), 0));
						}
						else
						{
							INSTRUCTION(Ins::GetProperty(result.propertyInfo));
						}
					}
					else
					{
						auto meta = MakePtr<WfAssemblyFunction>();
						meta->name = result.methodInfo->GetName() + L"<" + result.methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L">";
						vint functionIndex = context.assembly->functions.Add(meta);
						context.assembly->functionByName.Add(meta->name, functionIndex);
						
						WfCodegenLambdaContext lc;
						lc.methodReferenceExpression = node;
						context.functionContext->closuresToCodegen.Add(functionIndex, lc);

						GenerateExpressionInstructions(context, node->parent);
						INSTRUCTION(Ins::LoadClosure(functionIndex, 1));
					}
				}

				void Visit(WfChildExpression* node)override
				{
					VisitReferenceExpression(node);
				}

				void Visit(WfLiteralExpression* node)override
				{
					switch (node->value)
					{
					case WfLiteralValue::Null:
						INSTRUCTION(Ins::LoadValue(Value()));
						break;
					case WfLiteralValue::True:
						INSTRUCTION(Ins::LoadValue(BoxValue(true)));
						break;
					case WfLiteralValue::False:
						INSTRUCTION(Ins::LoadValue(BoxValue(false)));
						break;
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					INSTRUCTION(Ins::LoadValue(BoxValue(wtof(node->value.value))));
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();
					if (td == description::GetTypeDescriptor<vint32_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vint32_t)wtoi(node->value.value))));
					}
					else if (td == description::GetTypeDescriptor<vint64_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vint64_t)wtoi64(node->value.value))));
					}
					else if (td == description::GetTypeDescriptor<vuint64_t>())
					{
						INSTRUCTION(Ins::LoadValue(BoxValue((vuint64_t)wtou64(node->value.value))));
					}
				}

				void Visit(WfStringExpression* node)override
				{
					INSTRUCTION(Ins::LoadValue(BoxValue(node->value.value)));
				}

				void Visit(WfFormatExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expandedExpression);
				}

				void Visit(WfUnaryExpression* node)override
				{
					auto type = GenerateExpressionInstructions(context, node->operand);
					switch (node->op)
					{
					case WfUnaryOperator::Not:
						INSTRUCTION(Ins::OpNot(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Positive:
						INSTRUCTION(Ins::OpPositive(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Negative:
						INSTRUCTION(Ins::OpNegative(GetInstructionTypeArgument(type)));
						break;
					}
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::Assign)
					{
						if (auto binary = node->first.Cast<WfBinaryExpression>())
						{
							auto result = context.manager->expressionResolvings[binary->first.Obj()];
							auto containerType = result.expectedType ? result.expectedType : result.type;
							auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Set", true)->GetMethod(0);
							GenerateExpressionInstructions(context, binary->second);
							INSTRUCTION(Ins::Duplicate(0));
							GenerateExpressionInstructions(context, node->second);
							GenerateExpressionInstructions(context, binary->first);
							INSTRUCTION(Ins::InvokeMethod(methodInfo, 2));
							INSTRUCTION(Ins::Pop());
						}
						else if (auto member = node->first.Cast<WfMemberExpression>())
						{
							auto result = context.manager->expressionResolvings[member.Obj()];
							auto methodInfo = result.propertyInfo->GetSetter();
							GenerateExpressionInstructions(context, node->second);
							INSTRUCTION(Ins::Duplicate(0));
							GenerateExpressionInstructions(context, member->parent);
							INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
							INSTRUCTION(Ins::Pop());
						}
						else
						{
							GenerateExpressionInstructions(context, node->second);
							INSTRUCTION(Ins::Duplicate(0));
							auto result = context.manager->expressionResolvings[node->first.Obj()];
							vint index = -1;
							if ((index = context.globalVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.globalVariables.Values()[index];
								INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
							}
							else if ((index = context.functionContext->localVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.functionContext->localVariables.Values()[index];
								INSTRUCTION(Ins::StoreLocalVar(variableIndex));
							}
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						auto result = context.manager->expressionResolvings[node->first.Obj()];
						auto containerType = result.expectedType ? result.expectedType : result.type;
						auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Get", true)->GetMethod(0);
						GenerateExpressionInstructions(context, node->second);
						GenerateExpressionInstructions(context, node->first);
						INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
					}
					else if (node->op == WfBinaryOperator::Concat)
					{
						auto type = TypeInfoRetriver<WString>::CreateTypeInfo();
						GenerateExpressionInstructions(context, node->first, type);
						GenerateExpressionInstructions(context, node->second, type);
						INSTRUCTION(Ins::OpConcat());
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						// next version: FailedThen
						throw 0;
					}
					else
					{
						Ptr<ITypeInfo> mergedType;
						switch (node->op)
						{
						case WfBinaryOperator::Exp:
						case WfBinaryOperator::Add:
						case WfBinaryOperator::Sub:
						case WfBinaryOperator::Mul:
						case WfBinaryOperator::Div:
						case WfBinaryOperator::Shl:
						case WfBinaryOperator::Shr:
							{
								auto result = context.manager->expressionResolvings[node];
								mergedType = result.type;
							}
							break;
						default:
							{
								auto firstResult = context.manager->expressionResolvings[node->first.Obj()];
								auto secondResult = context.manager->expressionResolvings[node->second.Obj()];
								auto firstType = firstResult.expectedType ? firstResult.expectedType : firstResult.type;
								auto secondType = secondResult.expectedType ? secondResult.expectedType : secondResult.type;
								if (node->op == WfBinaryOperator::EQ || node->op == WfBinaryOperator::NE)
								{
									if (firstType->GetDecorator() == ITypeInfo::RawPtr || firstType->GetDecorator() == ITypeInfo::SharedPtr)
									{
										GenerateExpressionInstructions(context, node->first);
										GenerateExpressionInstructions(context, node->second);
										INSTRUCTION(Ins::CompareReference());
										if (node->op == WfBinaryOperator::NE)
										{
											INSTRUCTION(Ins::OpNot(WfInsType::Bool));
										}
										return;
									}
								}
								mergedType = GetMergedType(firstType, secondType);
							}
						}

						GenerateExpressionInstructions(context, node->first, mergedType);
						GenerateExpressionInstructions(context, node->second, mergedType);

						switch (node->op)
						{
						case WfBinaryOperator::Exp:
							INSTRUCTION(Ins::OpExp(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Add:
							INSTRUCTION(Ins::OpAdd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Sub:
							INSTRUCTION(Ins::OpSub(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Mul:
							INSTRUCTION(Ins::OpMul(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Div:
							INSTRUCTION(Ins::OpDiv(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shl:
							INSTRUCTION(Ins::OpShl(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shr:
							INSTRUCTION(Ins::OpShr(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::LT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLT());
							break;
						case WfBinaryOperator::GT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGT());
							break;
						case WfBinaryOperator::LE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLE());
							break;
						case WfBinaryOperator::GE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGE());
							break;
						case WfBinaryOperator::EQ:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpEQ());
							break;
						case WfBinaryOperator::NE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpNE());
							break;
						case WfBinaryOperator::Xor:
							INSTRUCTION(Ins::OpXor(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::And:
							INSTRUCTION(Ins::OpAnd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Or:
							INSTRUCTION(Ins::OpOr(GetInstructionTypeArgument(mergedType)));
							break;
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = context.manager->expressionScopes[node].Obj();
					Array<vint> variableIndices(node->variables.Count());
					auto function = context.functionContext->function;
					FOREACH_INDEXER(Ptr<WfLetVariable>, var, index, node->variables)
					{
						auto symbol = scope->symbols[var->name.value][0];
						vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<let>" + var->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);
						variableIndices[index] = variableIndex;

						GenerateExpressionInstructions(context, var->value);
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					GenerateExpressionInstructions(context, node->expression);
					FOREACH_INDEXER(Ptr<WfLetVariable>, var, index, node->variables)
					{
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(variableIndices[index]));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					GenerateExpressionInstructions(context, node->condition);
					vint fillTrueIndex = INSTRUCTION(Ins::JumpIf(-1));
					GenerateExpressionInstructions(context, node->falseBranch, result.type);
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					context.assembly->instructions[fillTrueIndex].indexParameter = context.assembly->instructions.Count();
					GenerateExpressionInstructions(context, node->trueBranch, result.type);
					context.assembly->instructions[fillEndIndex].indexParameter = context.assembly->instructions.Count();
				}

				void Visit(WfRangeExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto elementType = result.type->GetElementType()->GetGenericArgument(0);
					auto type = GetInstructionTypeArgument(elementType);
					
					GenerateExpressionInstructions(context, node->begin, elementType);
					if (node->beginBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
						INSTRUCTION(Ins::OpAdd(type));
					}
					
					GenerateExpressionInstructions(context, node->end, elementType);
					if (node->endBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(BoxValue<vint>(1)));
						INSTRUCTION(Ins::OpSub(type));
					}

					INSTRUCTION(Ins::CreateRange(type));
				}

				void Visit(WfSetTestingExpression* node)override
				{
					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto resultElement = context.manager->expressionResolvings[node->element.Obj()];
						auto resultBegin = context.manager->expressionResolvings[range->begin.Obj()];
						auto resultEnd = context.manager->expressionResolvings[range->end.Obj()];
						auto typeElement = resultElement.expectedType ? resultElement.expectedType : resultElement.type;
						auto typeBegin = resultBegin.expectedType ? resultBegin.expectedType : resultBegin.type;
						auto typeEnd = resultEnd.expectedType ? resultEnd.expectedType : resultEnd.type;
						auto typeLeft = GetMergedType(typeElement, typeBegin);
						auto typeRight = GetMergedType(typeElement, typeEnd);

						auto function = context.functionContext->function;
						vint index = function->argumentNames.Count() + function->localVariableNames.Add(L"<anonymous-range-test>");
						GenerateExpressionInstructions(context, node->element);
						INSTRUCTION(Ins::StoreLocalVar(index));
						
						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeLeft.Obj()))
						{
							GenerateTypeCastInstructions(context, typeLeft, true);
						}
						GenerateExpressionInstructions(context, range->begin, typeLeft);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeLeft)));
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpGT());
						}
						else
						{
							INSTRUCTION(Ins::OpGE());
						}

						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeRight.Obj()))
						{
							GenerateTypeCastInstructions(context, typeRight, true);
						}
						GenerateExpressionInstructions(context, range->end, typeRight);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeRight)));
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpLT());
						}
						else
						{
							INSTRUCTION(Ins::OpLE());
						}

						INSTRUCTION(Ins::OpAnd(WfInsType::Bool));
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::StoreLocalVar(index));
					}
					else
					{
						auto result = context.manager->expressionResolvings[node->collection.Obj()];
						auto type = result.expectedType ? result.expectedType : result.type;

						GenerateExpressionInstructions(context, node->element);
						GenerateExpressionInstructions(context, node->collection);

						auto tdList = description::GetTypeDescriptor<IValueReadonlyList>();
						if (result.type->GetTypeDescriptor()->CanConvertTo(tdList))
						{
							auto method = tdList->GetMethodGroupByName(L"Contains", true)->GetMethod(0);
							INSTRUCTION(Ins::InvokeMethod(method, 1));
						}
						else
						{
							INSTRUCTION(Ins::TestElementInSet());
						}
					}
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];

					if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						FOREACH(Ptr<WfConstructorArgument>, argument, From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
						}
						INSTRUCTION(Ins::CreateArray(node->arguments.Count()));
					}
					else
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						Ptr<ITypeInfo> valueType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(1));
						FOREACH(Ptr<WfConstructorArgument>, argument, From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
							GenerateExpressionInstructions(context, argument->value, valueType);
						}
						INSTRUCTION(Ins::CreateMap(node->arguments.Count() * 2));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					if (node->strategy == WfTypeCastingStrategy::Strong)
					{
						auto result = context.manager->expressionResolvings[node];
						GenerateExpressionInstructions(context, node->expression, result.type);
					}
					else
					{
						auto scope = context.manager->expressionScopes[node].Obj();
						auto type = CreateTypeInfoFromType(scope, node->type);
						GenerateExpressionInstructions(context, node->expression);
						GenerateTypeCastInstructions(context, type, false);
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					switch (node->test)
					{
					case WfTypeTesting::IsNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
						break;
					case WfTypeTesting::IsNotNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::CompareReference());
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						break;
					case WfTypeTesting::IsType:
						{
							auto scope = context.manager->expressionScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type);
						}
						break;
					case WfTypeTesting::IsNotType:
						{
							auto scope = context.manager->expressionScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type);
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						break;
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					auto scope = context.manager->expressionScopes[node].Obj();
					auto type = CreateTypeInfoFromType(scope, node->type);
					auto value = Value::From(type->GetTypeDescriptor());
					INSTRUCTION(Ins::LoadValue(value));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::GetType());
				}

				void Visit(WfAttachEventExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node->event.Obj()];
					auto parent = node->event.Cast<WfMemberExpression>()->parent;
					GenerateExpressionInstructions(context, parent);
					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::AttachEvent(result.eventInfo));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					GenerateExpressionInstructions(context, node->handler);
					INSTRUCTION(Ins::DetachEvent());
				}

				void Visit(WfBindExpression* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfObserveExpression* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfCallExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						GenerateExpressionInstructions(context, argument);
					}

					auto result = context.manager->expressionResolvings[node->function.Obj()];
					if (result.methodInfo)
					{
						if (result.methodInfo->IsStatic())
						{
							INSTRUCTION(Ins::LoadValue(Value()));
						}
						else
						{
							auto member = node->function.Cast<WfMemberExpression>();
							GenerateExpressionInstructions(context, member->parent);
						}

						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, node->arguments.Count()));
						return;
					}
					else if (result.symbol)
					{
						vint index = context.globalFunctions.Keys().IndexOf(result.symbol.Obj());
						if (index != -1)
						{
							vint functionIndex = context.globalFunctions.Values()[index];
							INSTRUCTION(Ins::Invoke(functionIndex, node->arguments.Count()));
							return;
						}
					}

					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::InvokeProxy(node->arguments.Count()));
				}

				void Visit(WfFunctionExpression* node)override
				{
					// next version
					throw 0;
				}

				void Visit(WfNewTypeExpression* node)override
				{
					if (node->functions.Count() == 0)
					{
						auto result = context.manager->expressionResolvings[node];
						FOREACH(Ptr<WfExpression>, argument, node->arguments)
						{
							GenerateExpressionInstructions(context, argument);
						}
						INSTRUCTION(Ins::LoadValue(Value()));
						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, node->arguments.Count()));
					}
					else
					{
						// next version
						throw 0;
					}
				}
			};

			Ptr<reflection::description::ITypeInfo> GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				GenerateExpressionInstructionsVisitor visitor(context);
				expression->Accept(&visitor);

				auto result = context.manager->expressionResolvings[expression.Obj()];
				auto type = result.type;

				if (result.expectedType && !IsSameType(type.Obj(), result.expectedType.Obj()))
				{
					type = result.expectedType;
					GenerateTypeCastInstructions(context, type, true);
				}

				if (expectedType && !IsSameType(type.Obj(), expectedType.Obj()))
				{
					type = expectedType;
					GenerateTypeCastInstructions(context, type, true);
				}

				return type;
			}

/***********************************************************************
GenerateTypeCastInstructions
***********************************************************************/

			void GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					if (strongCast)
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::ConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::ConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::ConvertToType(Value::Text, expectedType->GetTypeDescriptor()));
							break;
						}
					}
					else
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::TryConvertToType(Value::Text, expectedType->GetTypeDescriptor()));
							break;
						}
					}
				}
			}

/***********************************************************************
GetInstructionTypeArgument
***********************************************************************/

			void GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					switch (expectedType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						INSTRUCTION(Ins::TestType(Value::RawPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::SharedPtr:
						INSTRUCTION(Ins::TestType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						INSTRUCTION(Ins::TestType(Value::Text, expectedType->GetTypeDescriptor()));
						break;
					}
				}
				else
				{
					INSTRUCTION(Ins::Pop());
					INSTRUCTION(Ins::LoadValue(BoxValue(true)));
				}
			}

/***********************************************************************
GenerateTypeCastInstructions
***********************************************************************/

			runtime::WfInsType GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType)
			{
				auto td = expectedType->GetTypeDescriptor();
				if (td == GetTypeDescriptor<bool>()) return WfInsType::Bool;
				if (td == GetTypeDescriptor<vint8_t>()) return WfInsType::I1;
				if (td == GetTypeDescriptor<vint16_t>()) return WfInsType::I2;
				if (td == GetTypeDescriptor<vint32_t>()) return WfInsType::I4;
				if (td == GetTypeDescriptor<vint64_t>()) return WfInsType::I8;
				if (td == GetTypeDescriptor<vuint8_t>()) return WfInsType::U1;
				if (td == GetTypeDescriptor<vuint16_t>()) return WfInsType::U2;
				if (td == GetTypeDescriptor<vuint32_t>()) return WfInsType::U4;
				if (td == GetTypeDescriptor<vuint64_t>()) return WfInsType::U8;
				if (td == GetTypeDescriptor<float>()) return WfInsType::F4;
				if (td == GetTypeDescriptor<double>()) return WfInsType::F8;
				if (td == GetTypeDescriptor<WString>()) return WfInsType::String;
				return WfInsType::Unknown;
			}

/***********************************************************************
GenerateAssembly
***********************************************************************/

			Ptr<runtime::WfAssembly> GenerateAssembly(WfLexicalScopeManager* manager)
			{
				auto assembly = MakePtr<WfAssembly>();
				WfCodegenContext context(assembly, manager);
				FOREACH(Ptr<WfModule>, module, manager->modules)
				{
					FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl);
					}
				}

				{
					auto meta = MakePtr<WfAssemblyFunction>();
					meta->name = L"<initialize>";
					vint functionIndex = assembly->functions.Add(meta);
					assembly->functionByName.Add(meta->name, functionIndex);

					auto functionContext = MakePtr<WfCodegenFunctionContext>();
					functionContext->function = meta;
					context.functionContext = functionContext;
					
					meta->firstInstruction = assembly->instructions.Count();
					FOREACH(Ptr<WfModule>, module, manager->modules)
					{
						FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
						{
							GenerateInitializeInstructions(context, decl);
						}
					}
					INSTRUCTION(Ins::LoadValue(Value()));
					INSTRUCTION(Ins::Return());
					meta->lastInstruction = assembly->instructions.Count() - 1;

					context.functionContext = 0;
					GenerateClosureInstructions(context, functionContext);
				}

				FOREACH(Ptr<WfModule>, module, manager->modules)
				{
					FOREACH(Ptr<WfDeclaration>, decl, module->declarations)
					{
						GenerateDeclarationInstructions(context, decl);
					}
				}

				//for (vint i = 0; i < assembly->instructions.Count(); i++)
				//{
				//	WfInstruction& ins = assembly->instructions[i];
				//	switch (ins.code)
				//	{
				//	case WfInsCode::LoadClosure:
				//		ins.countParameter = assembly->functions[ins.indexParameter]->capturedVariableNames.Count();
				//		break;
				//	}
				//}
				return assembly;
			}

#undef INSTRUCTION

/***********************************************************************
Compile
***********************************************************************/

			Ptr<runtime::WfAssembly> Compile(Ptr<parsing::tabling::ParsingTable> table, WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors)
			{
				manager->Clear(true, true);
				FOREACH_INDEXER(WString, code, index, moduleCodes)
				{
					Ptr<ParsingTreeNode> node = WfParseModuleAsParsingTreeNode(code, table, errors);
					if (node)
					{
						List<RegexToken> tokens;
						Ptr<WfModule> module = WfConvertParsingTreeNode(node, tokens).Cast<WfModule>();
						if (module)
						{
							manager->modules.Add(module);
						}
					}
				}
				if (errors.Count() > 0) return 0;

				manager->Rebuild(true);
				if (manager->errors.Count() > 0)
				{
					CopyFrom(errors, manager->errors);
					return 0;
				}

				return GenerateAssembly(manager);
			}

			Ptr<runtime::WfAssembly> Compile(Ptr<parsing::tabling::ParsingTable> table, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors)
			{
				WfLexicalScopeManager manager(table);
				return Compile(table, &manager, moduleCodes, errors);
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_Misc.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
IsExpressionDependOnExpectedType(Expression)
***********************************************************************/

			class IsExpressionDependOnExpectedTypeVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				bool								result;

				IsExpressionDependOnExpectedTypeVisitor()
					:result(false)
				{
				}

				static bool Execute(Ptr<WfExpression> expression)
				{
					IsExpressionDependOnExpectedTypeVisitor visitor;
					expression->Accept(&visitor);
					return visitor.result;
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					result = true;
				}

				void Visit(WfMemberExpression* node)override
				{
				}

				void Visit(WfChildExpression* node)override
				{
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						result = true;
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
				}

				void Visit(WfBinaryExpression* node)override
				{
				}

				void Visit(WfLetExpression* node)override
				{
				}

				void Visit(WfIfExpression* node)override
				{
					result = Execute(node->trueBranch) && Execute(node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
				}

				void Visit(WfSetTestingExpression* node)override
				{
				}

				void Visit(WfConstructorExpression* node)override
				{
					result = node->arguments.Count() == 0;
				}

				void Visit(WfInferExpression* node)override
				{
				}

				void Visit(WfTypeCastingExpression* node)override
				{
				}

				void Visit(WfTypeTestingExpression* node)override
				{
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
				}

				void Visit(WfAttachEventExpression* node)override
				{
				}

				void Visit(WfDetachEventExpression* node)override
				{
				}

				void Visit(WfBindExpression* node)override
				{
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
				}

				void Visit(WfFunctionExpression* node)override
				{
				}

				void Visit(WfNewTypeExpression* node)override
				{
				}
			};

			bool IsExpressionDependOnExpectedType(Ptr<WfExpression> expression)
			{
				IsExpressionDependOnExpectedTypeVisitor visitor;
				expression->Accept(&visitor);
				return visitor.result;
			}

/***********************************************************************
GetExpressionName(Expression)
***********************************************************************/

			class GetExpressionNameVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WString								result;

				void Visit(WfTopQualifiedExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfReferenceExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
				}

				void Visit(WfMemberExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfChildExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
				}

				void Visit(WfBinaryExpression* node)override
				{
				}

				void Visit(WfLetExpression* node)override
				{
				}

				void Visit(WfIfExpression* node)override
				{
				}

				void Visit(WfRangeExpression* node)override
				{
				}

				void Visit(WfSetTestingExpression* node)override
				{
				}

				void Visit(WfConstructorExpression* node)override
				{
				}

				void Visit(WfInferExpression* node)override
				{
				}

				void Visit(WfTypeCastingExpression* node)override
				{
				}

				void Visit(WfTypeTestingExpression* node)override
				{
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
				}

				void Visit(WfAttachEventExpression* node)override
				{
				}

				void Visit(WfDetachEventExpression* node)override
				{
				}

				void Visit(WfBindExpression* node)override
				{
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
				}

				void Visit(WfFunctionExpression* node)override
				{
				}

				void Visit(WfNewTypeExpression* node)override
				{
				}
			};

			WString GetExpressionName(Ptr<WfExpression> expression)
			{
				GetExpressionNameVisitor visitor;
				expression->Accept(&visitor);
				return visitor.result;
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_SearchOrderedName.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;

/***********************************************************************
SearchOrderedName(Declaration)
***********************************************************************/

			class SearchOrderedNameDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				SortedList<vint>&						names;

				SearchOrderedNameDeclarationVisitor(SortedList<vint>& _names)
					:names(_names)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						SearchOrderedName(declaration, names);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					SearchOrderedName(node->statement, names);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					SearchOrderedName(node->expression, names);
				}

				static void Execute(Ptr<WfDeclaration> declaration, SortedList<vint>& names)
				{
					SearchOrderedNameDeclarationVisitor visitor(names);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName(Statement)
***********************************************************************/

			class SearchOrderedNameStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				SortedList<vint>&						names;

				SearchOrderedNameStatementVisitor(SortedList<vint>& _names)
					:names(_names)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						SearchOrderedName(node->expression, names);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					SearchOrderedName(node->expression, names);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						SearchOrderedName(node->expression, names);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					SearchOrderedName(node->expression, names);
					node->trueBranch->Accept(this);
					if (node->falseBranch)
					{
						node->falseBranch->Accept(this);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					SearchOrderedName(node->expression, names);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						SearchOrderedName(switchCase->expression, names);
						switchCase->statement->Accept(this);
					}
					if (node->defaultBranch)
					{
						node->defaultBranch->Accept(this);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					SearchOrderedName(node->condition, names);
					node->statement->Accept(this);
				}

				void Visit(WfForEachStatement* node)override
				{
					SearchOrderedName(node->collection, names);
					node->statement->Accept(this);
				}

				void Visit(WfTryStatement* node)override
				{
					node->protectedStatement->Accept(this);
					if (node->catchStatement)
					{
						node->catchStatement->Accept(this);
					}
					if (node->finallyStatement)
					{
						node->finallyStatement->Accept(this);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						statement->Accept(this);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					SearchOrderedName(node->expression, names);
				}

				void Visit(WfVariableStatement* node)override
				{
					SearchOrderedName(node->variable.Cast<WfDeclaration>(), names);
				}

				static void Execute(Ptr<WfStatement> statement, SortedList<vint>& names)
				{
					SearchOrderedNameStatementVisitor visitor(names);
					statement->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName(Expression)
***********************************************************************/

			class SearchOrderedNameExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				SortedList<vint>&						names;

				SearchOrderedNameExpressionVisitor(SortedList<vint>& _names)
					:names(_names)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					vint name = wtoi(node->name.value.Sub(1, node->name.value.Length() - 1));
					if (!names.Contains(name))
					{
						names.Add(name);
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					// names in nested ordered lambda expression is not counted
				}

				void Visit(WfMemberExpression* node)override
				{
					node->parent->Accept(this);
				}

				void Visit(WfChildExpression* node)override
				{
					node->parent->Accept(this);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (node->expandedExpression)
					{
						node->expandedExpression->Accept(this);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					node->operand->Accept(this);
				}

				void Visit(WfBinaryExpression* node)override
				{
					node->first->Accept(this);
					node->second->Accept(this);
				}

				void Visit(WfLetExpression* node)override
				{
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						variable->value->Accept(this);
					}
					
					node->expression->Accept(this);
				}

				void Visit(WfIfExpression* node)override
				{
					node->condition->Accept(this);
					node->trueBranch->Accept(this);
					node->falseBranch->Accept(this);
				}

				void Visit(WfRangeExpression* node)override
				{
					node->begin->Accept(this);
					node->end->Accept(this);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					node->element->Accept(this);
					node->collection->Accept(this);
				}

				void Visit(WfConstructorExpression* node)override
				{
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						argument->value->Accept(this);
					}
				}

				void Visit(WfInferExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->expression)
					{
						node->expression->Accept(this);
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					node->event->Accept(this);
					node->function->Accept(this);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					node->handler->Accept(this);
				}

				void Visit(WfBindExpression* node)override
				{
					node->expression->Accept(this);
				}

				void Visit(WfObserveExpression* node)override
				{
					node->parent->Accept(this);
					node->expression->Accept(this);
					FOREACH(Ptr<WfExpression>, event, node->events)
					{
						event->Accept(this);
					}
				}

				void Visit(WfCallExpression* node)override
				{
					node->function->Accept(this);
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						argument->Accept(this);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					SearchOrderedName(node->function.Cast<WfDeclaration>(), names);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					FOREACH(Ptr<WfExpression>, argument, node->arguments)
					{
						argument->Accept(this);
					}

					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						SearchOrderedName(function.Cast<WfDeclaration>(), names);
					}
				}

				static void Execute(Ptr<WfExpression> expression, SortedList<vint>& names)
				{
					SearchOrderedNameExpressionVisitor visitor(names);
					expression->Accept(&visitor);
				}
			};

/***********************************************************************
SearchOrderedName
***********************************************************************/

			void SearchOrderedName(Ptr<WfDeclaration> declaration, collections::SortedList<vint>& names)
			{
				SearchOrderedNameDeclarationVisitor::Execute(declaration, names);
			}

			void SearchOrderedName(Ptr<WfStatement> statement, collections::SortedList<vint>& names)
			{
				SearchOrderedNameStatementVisitor::Execute(statement, names);
			}

			void SearchOrderedName(Ptr<WfExpression> expression, collections::SortedList<vint>& names)
			{
				SearchOrderedNameExpressionVisitor::Execute(expression, names);
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_TypeInfo.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
GetTypeFlag
***********************************************************************/

			TypeFlag GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				if (typeDescriptor == GetTypeDescriptor<bool>())		return TypeFlag::Bool;
				if (typeDescriptor == GetTypeDescriptor<vint8_t>())		return TypeFlag::I1;
				if (typeDescriptor == GetTypeDescriptor<vint16_t>())	return TypeFlag::I2;
				if (typeDescriptor == GetTypeDescriptor<vint32_t>())	return TypeFlag::I4;
				if (typeDescriptor == GetTypeDescriptor<vint64_t>())	return TypeFlag::I8;
				if (typeDescriptor == GetTypeDescriptor<vuint8_t>())	return TypeFlag::U1;
				if (typeDescriptor == GetTypeDescriptor<vuint16_t>())	return TypeFlag::U2;
				if (typeDescriptor == GetTypeDescriptor<vuint32_t>())	return TypeFlag::U4;
				if (typeDescriptor == GetTypeDescriptor<vuint64_t>())	return TypeFlag::U8;
				if (typeDescriptor == GetTypeDescriptor<float>())		return TypeFlag::F4;
				if (typeDescriptor == GetTypeDescriptor<double>())		return TypeFlag::F8;
				if (typeDescriptor == GetTypeDescriptor<WString>())		return TypeFlag::String;
				return TypeFlag::Others;
			}

			TypeFlag GetTypeFlag(reflection::description::ITypeInfo* typeInfo)
			{
				ITypeDescriptor* td = typeInfo->GetTypeDescriptor();
				return GetTypeFlag(td);
			}

/***********************************************************************
CreateTypeInfoFromTypeFlag
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromTypeFlag(TypeFlag flag)
			{
				switch (flag)
				{
				case TypeFlag::Bool:	return TypeInfoRetriver<bool>::CreateTypeInfo();
				case TypeFlag::I1:		return TypeInfoRetriver<vint8_t>::CreateTypeInfo();
				case TypeFlag::I2:		return TypeInfoRetriver<vint16_t>::CreateTypeInfo();
				case TypeFlag::I4:		return TypeInfoRetriver<vint32_t>::CreateTypeInfo();
				case TypeFlag::I8:		return TypeInfoRetriver<vint64_t>::CreateTypeInfo();
				case TypeFlag::U1:		return TypeInfoRetriver<vuint8_t>::CreateTypeInfo();
				case TypeFlag::U2:		return TypeInfoRetriver<vuint16_t>::CreateTypeInfo();
				case TypeFlag::U4:		return TypeInfoRetriver<vuint32_t>::CreateTypeInfo();
				case TypeFlag::U8:		return TypeInfoRetriver<vuint64_t>::CreateTypeInfo();
				case TypeFlag::F4:		return TypeInfoRetriver<float>::CreateTypeInfo();
				case TypeFlag::F8:		return TypeInfoRetriver<double>::CreateTypeInfo();
				case TypeFlag::String:	return TypeInfoRetriver<WString>::CreateTypeInfo();
				}
				return 0;
			}

/***********************************************************************
GetTypeFromTypeInfo
***********************************************************************/

			Ptr<WfType> GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							Ptr<WfRawPointerType> type = new WfRawPointerType;
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::SharedPtr:
					{
						if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::Generic)
						{
							return GetTypeFromTypeInfo(typeInfo->GetElementType());
						}
						else
						{
							Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
							if (element)
							{
								Ptr<WfSharedPointerType> type = new WfSharedPointerType;
								type->element = element;
								return type;
							}
							return 0;
						}
					}
				case ITypeInfo::Nullable:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							Ptr<WfNullableType> type = new WfNullableType;
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::TypeDescriptor:
					{
						List<WString> fragments;
						{
							WString name = typeInfo->GetTypeDescriptor()->GetTypeName();
							const wchar_t* reading = name.Buffer();
							while (reading)
							{
								const wchar_t* delimiter = wcsstr(reading, L"::");
								if (delimiter)
								{
									fragments.Add(WString(reading, delimiter - reading));
									reading = delimiter + 2;
								}
								else
								{
									fragments.Add(reading);
									break;
								}
							}
						}

						Ptr<WfType> parentType;
						FOREACH(WString, fragment, fragments)
						{
							if (parentType)
							{
								Ptr<WfTopQualifiedType> type = new WfTopQualifiedType;
								type->name.value = fragment;
								parentType = type;
							}
							else
							{
								Ptr<WfChildType> type = new WfChildType;
								type->parent = parentType;
								type->name.value = fragment;
								parentType = type;
							}
						}
						return parentType;
					}
				case ITypeInfo::Generic:
					{
						ITypeInfo* genericType = typeInfo->GetElementType();
						if (genericType->GetDecorator() == ITypeInfo::TypeDescriptor)
						{
							if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueEnumerable>())
							{
								if (genericType->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> elementType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									{
										Ptr<WfEnumerableType> type = new WfEnumerableType;
										type->element = elementType;
										return type;
									}
								}
							}
							else if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyList>())
							{
								if (genericType->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Readonly;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueList>())
							{
								if (genericType->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Writable;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyDictionary>())
							{
								if (genericType->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(genericType->GetGenericArgument(1)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Readonly;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueDictionary>())
							{
								if (genericType->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(genericType->GetGenericArgument(1)))
									{
										Ptr<WfMapType> type = new WfMapType;
										type->writability = WfMapWritability::Writable;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (genericType->GetTypeDescriptor() == GetTypeDescriptor<IValueFunctionProxy>())
							{
								if (genericType->GetGenericArgumentCount() >= 1)
								{
									if (Ptr<WfType> returnType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0)))
									{
										Ptr<WfFunctionType> type = new WfFunctionType;
										type->result = type;
										for (vint i = 1; i < genericType->GetGenericArgumentCount(); i++)
										{
											if (Ptr<WfType> argumentType = GetTypeFromTypeInfo(genericType->GetGenericArgument(i)))
											{
												type->arguments.Add(argumentType);
											}
											else
											{
												return 0;
											}
										}
										return type;
									}
								}
							}
						}
						return 0;
					}
				default:
					return 0;
				}
			}

/***********************************************************************
GetScopeNameFromReferenceType
***********************************************************************/

			class GetScopeNameFromReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<WfLexicalScopeName>		result;

				GetScopeNameFromReferenceTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<WfLexicalScopeName> Call(WfType* node)
				{
					node->Accept(this);
					Ptr<WfLexicalScopeName> scopeName = result;
					result = 0;
					return scopeName;
				}

				void Visit(WfPredefinedType* node)override
				{
					WString name;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						name = L"Void";
						break;
					case WfPredefinedTypeName::Object:
						name = L"Object";
						break;
					case WfPredefinedTypeName::Interface:
						name = L"Interface";
						break;
					case WfPredefinedTypeName::Int:
#if defined VCZH_64
						name = L"Int64";
#else
						name = L"Int32";
#endif
						break;
					case WfPredefinedTypeName::UInt:
#if defined VCZH_64
						name = L"UInt64";
#else
						name = L"UInt32";
#endif
						break;
					case WfPredefinedTypeName::Float:
						name = L"Single";
						break;
					case WfPredefinedTypeName::Double:
						name = L"Double";
						break;
					case WfPredefinedTypeName::String:
						name = L"String";
						break;
					case WfPredefinedTypeName::Char:
						name = L"Char";
						break;
					case WfPredefinedTypeName::Bool:
						name = L"Boolean";
						break;
					default:
						CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}

					Ptr<WfTopQualifiedType> ns = new WfTopQualifiedType;
					ns->name.value = L"system";

					Ptr<WfChildType> type = new WfChildType;
					type->parent = ns;
					type->name.value = name;

					type->Accept(this);
				}

				void Visit(WfTopQualifiedType* node)override
				{
					auto manager = scope->FindManager();
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = manager->globalName->children.Values()[index];
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void Visit(WfReferenceType* node)override
				{
					auto manager = scope->FindManager();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					if (symbols.Count() > 1)
					{
						manager->errors.Add(WfErrors::TooManyTargets(node, symbols, node->name.value));
						return;
					}
					else if (symbols.Count() == 1)
					{
						manager->errors.Add(WfErrors::TypeNotExists(node, symbols[0]));
						return;
					}

					List<Ptr<WfLexicalScopeName>> scopeNames;
					manager->ResolveScopeName(scope, node->name.value, scopeNames);
					if (scopeNames.Count() > 1)
					{
						manager->errors.Add(WfErrors::TooManyTargets(node, scopeNames, node->name.value));
					}
					else if (scopeNames.Count() == 1)
					{
						result = scopeNames[0];
					}
					else
					{
						manager->errors.Add(WfErrors::ReferenceNotExists(node, node->name.value));
					}
				}

				void Visit(WfRawPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfRawPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfSharedPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfSharedPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfNullableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfNullableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfEnumerableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfEnumerableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfMapType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfMapType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfFunctionType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfFunctionType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfChildType* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = Call(node->parent.Obj()))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = scopeName->children.Values()[index];
							return;
						}
						scope->FindManager()->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
					}
				}

				static Ptr<WfLexicalScopeName> Execute(WfLexicalScope* scope, WfType* type)
				{
					return GetScopeNameFromReferenceTypeVisitor(scope).Call(type);
				}
			};

			Ptr<WfLexicalScopeName> GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type)
			{
				return GetScopeNameFromReferenceTypeVisitor::Execute(scope, type.Obj());
			}

/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/

			class CreateTypeInfoFromTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<ITypeInfo>				result;

				CreateTypeInfoFromTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<ITypeInfo> Call(WfType* node, bool checkTypeForValue)
				{
					node->Accept(this);
					Ptr<ITypeInfo> typeInfo = result;
					result = 0;
					if (typeInfo)
					{
						auto manager = scope->FindManager();
						switch (typeInfo->GetDecorator())
						{
						case ITypeInfo::RawPtr:
						case ITypeInfo::SharedPtr:
							{
								auto element = typeInfo->GetElementType();
								if (element->GetDecorator() == ITypeInfo::Generic)
								{
									element = element->GetElementType();
								}

								if (element->GetDecorator() == ITypeInfo::TypeDescriptor)
								{
									if (element->GetTypeDescriptor()->GetValueSerializer() == 0)
									{
										goto RAW_SHARED_POINTER_CORRECT;
									}
								}

								if (typeInfo->GetDecorator() == ITypeInfo::RawPtr)
								{
									manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node, element));
								}
								else
								{
									manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node, element));
								}
							RAW_SHARED_POINTER_CORRECT:
								;
							}
							break;
						case ITypeInfo::Nullable:
							{
								auto element = typeInfo->GetElementType();
								if (element->GetDecorator() == ITypeInfo::Generic)
								{
									element = element->GetElementType();
								}

								if (element->GetDecorator() == ITypeInfo::TypeDescriptor)
								{
									if (element->GetTypeDescriptor()->GetValueSerializer() != 0)
									{
										goto NULLABLE_CORRECT;
									}
								}

								manager->errors.Add(WfErrors::NullableToNonReferenceType(node, element));
							NULLABLE_CORRECT:
								;
							}
							break;
						case ITypeInfo::TypeDescriptor:
							if (checkTypeForValue)
							{
								if (typeInfo->GetTypeDescriptor()->GetValueSerializer() == 0 && typeInfo->GetTypeDescriptor() != description::GetTypeDescriptor<Value>())
								{
									manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
								}
							}
							break;
						case ITypeInfo::Generic:
							if (checkTypeForValue)
							{
								manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
							}
							break;
						}
					}
					return typeInfo;
				}

				void VisitReferenceType(WfType* node)
				{
					if (auto scopeName = GetScopeNameFromReferenceTypeVisitor::Execute(scope, node))
					{
						if (auto typeDescriptor = description::GetTypeDescriptor(scopeName->GetFriendlyName()))
						{
							Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
							typeInfo->SetTypeDescriptor(typeDescriptor);
							result = typeInfo;
						}
						else
						{
							scope->FindManager()->errors.Add(WfErrors::TypeNotExists(node, scopeName));
						}
					}
				}

				void Visit(WfPredefinedType* node)override
				{
					ITypeDescriptor* typeDescriptor = 0;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						typeDescriptor = description::GetTypeDescriptor<VoidValue>();
						break;
					case WfPredefinedTypeName::Object:
						typeDescriptor = description::GetTypeDescriptor<Value>();
						break;
					case WfPredefinedTypeName::Interface:
						typeDescriptor = description::GetTypeDescriptor<IDescriptable>();
						break;
					case WfPredefinedTypeName::Int:
						typeDescriptor = description::GetTypeDescriptor<vint>();
						break;
					case WfPredefinedTypeName::UInt:
						typeDescriptor = description::GetTypeDescriptor<vuint>();
						break;
					case WfPredefinedTypeName::Float:
						typeDescriptor = description::GetTypeDescriptor<float>();
						break;
					case WfPredefinedTypeName::Double:
						typeDescriptor = description::GetTypeDescriptor<double>();
						break;
					case WfPredefinedTypeName::String:
						typeDescriptor = description::GetTypeDescriptor<WString>();
						break;
					case WfPredefinedTypeName::Char:
						typeDescriptor = description::GetTypeDescriptor<wchar_t>();
						break;
					case WfPredefinedTypeName::Bool:
						typeDescriptor = description::GetTypeDescriptor<bool>();
						break;
					default:
						CHECK_FAIL(L"CreateTypeInfoFromTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}
					if (typeDescriptor)
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						typeInfo->SetTypeDescriptor(typeDescriptor);
						result = typeInfo;
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfReferenceType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfRawPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::RawPtr);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::SharedPtr);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::Nullable);
						typeInfo->SetElementType(element);
						result = typeInfo;
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), true))
					{
						Ptr<TypeInfoImpl> enumerableTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueEnumerable>());

						Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
						genericTypeInfo->SetElementType(enumerableTypeInfo);
						genericTypeInfo->AddGenericArgument(element);

						Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
						shared->SetElementType(genericTypeInfo);
						result = shared;
					}
				}

				void Visit(WfMapType* node)override
				{
					Ptr<ITypeInfo> key, value;
					if (!(value = Call(node->value.Obj(), true))) return;
					if (node->key)
					{
						if (!(key = Call(node->key.Obj(), true))) return;
					}
					
					Ptr<TypeInfoImpl> mapTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					if (node->writability == WfMapWritability::Writable)
					{
						if (node->key)
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueDictionary>());
						}
						else
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueList>());
						}
					}
					else
					{
						if (node->key)
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueReadonlyDictionary>());
						}
						else
						{
							mapTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueReadonlyList>());
						}
					}

					Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
					genericTypeInfo->SetElementType(mapTypeInfo);
					if (key) genericTypeInfo->AddGenericArgument(key);
					genericTypeInfo->AddGenericArgument(value);

					Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
					shared->SetElementType(genericTypeInfo);
					result = shared;
				}

				void Visit(WfFunctionType* node)override
				{
					if (Ptr<ITypeInfo> returnType = Call(node->result.Obj(), true))
					{
						Ptr<TypeInfoImpl> enumerableTypeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableTypeInfo->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());

						Ptr<TypeInfoImpl> genericTypeInfo = new TypeInfoImpl(ITypeInfo::Generic);
						genericTypeInfo->SetElementType(enumerableTypeInfo);
						genericTypeInfo->AddGenericArgument(returnType);
						FOREACH(Ptr<WfType>, argument, node->arguments)
						{
							if (Ptr<ITypeInfo> argumentType = Call(argument.Obj(), true))
							{
								genericTypeInfo->AddGenericArgument(argumentType);
							}
							else
							{
								return;
							}
						}

						Ptr<TypeInfoImpl> shared = new TypeInfoImpl(ITypeInfo::SharedPtr);
						shared->SetElementType(genericTypeInfo);
						result = shared;
					}
				}

				void Visit(WfChildType* node)override
				{
					VisitReferenceType(node);
				}

				static Ptr<ITypeInfo> Execute(WfLexicalScope* scope, WfType* type)
				{
					return CreateTypeInfoFromTypeVisitor(scope).Call(type, true);
				}
			};

			Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type)
			{
				return CreateTypeInfoFromTypeVisitor::Execute(scope, type.Obj());
			}
			


/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/
			
			Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(typeInfo->GetDecorator());
						impl->SetElementType(CopyTypeInfo(typeInfo->GetElementType()));
						return impl;
					}
				case ITypeInfo::TypeDescriptor:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						impl->SetTypeDescriptor(typeInfo->GetTypeDescriptor());
						return impl;
					}
				case ITypeInfo::Generic:
					{
						Ptr<TypeInfoImpl> impl = new TypeInfoImpl(ITypeInfo::Generic);
						impl->SetElementType(CopyTypeInfo(typeInfo->GetElementType()));
						vint count = typeInfo->GetGenericArgumentCount();
						for (vint i = 0; i < count; i++)
						{
							impl->AddGenericArgument(CopyTypeInfo(typeInfo->GetGenericArgument(i)));
						}
						return impl;
					}
				default:
					return 0;
				}
			}

/***********************************************************************
CanConvertToType
***********************************************************************/

			bool CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly)
			{
				ITypeDescriptor* objectType = GetTypeDescriptor<Value>();
				bool fromObject = fromType->GetDecorator() == ITypeInfo::TypeDescriptor && fromType->GetTypeDescriptor() == objectType;
				bool toObject = toType->GetDecorator() == ITypeInfo::TypeDescriptor && toType->GetTypeDescriptor() == objectType;

				if (fromObject && toObject)
				{
					return true;
				}
				else if (fromObject)
				{
					return explicitly;
				}
				else if (toObject)
				{
					return true;
				}

				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::SharedPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::Nullable:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::TypeDescriptor:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType, toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						{
							ITypeDescriptor* fromTd = fromType->GetTypeDescriptor();
							ITypeDescriptor* toTd = toType->GetTypeDescriptor();
							if ((fromTd->GetValueSerializer() != 0) != (toTd->GetValueSerializer() != 0))
							{
								return false;
							}

							if (fromTd->GetValueSerializer())
							{
								if (fromTd == toTd) return true;
								TypeFlag fromFlag = GetTypeFlag(fromTd);
								TypeFlag toFlag = GetTypeFlag(toTd);
								static vint conversionTable[(vint)TypeFlag::Count][(vint)TypeFlag::Count] = {
									/*Bool		*/{1, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*I1		*/{0, /**/ 1, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*I2		*/{0, /**/ 2, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*I4		*/{0, /**/ 2, 2, 1, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									/*I8		*/{0, /**/ 2, 2, 2, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*U1		*/{0, /**/ 2, 2, 2, 2, /**/ 1, 1, 1, 1, /**/ 1, 1, /**/ 1, 0},
									/*U2		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 1, 1, 1, /**/ 1, 1, /**/ 1, 0},
									/*U4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 1, 1, /**/ 2, 1, /**/ 1, 0},
									/*U8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 1, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*F4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0},
									/*F8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0},
									//-------------------------------------------------------------------------
									/*String	*/{2, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 2, /**/ 1, 2},
									/*Others	*/{0, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 1, 0},
								};
								vint conversion = conversionTable[(vint)fromFlag][(vint)toFlag];
								return conversion == 1 || (explicitly && conversion == 2);
							}
							else
							{
								if (fromTd->CanConvertTo(toTd))
								{
									return true;
								}
								if (explicitly && toTd->CanConvertTo(fromTd))
								{
									return true;
								}
							}
						}
						break;
					case ITypeInfo::Generic:
						return explicitly && CanConvertToType(fromType, toType->GetElementType(), explicitly);
					}
					break;
				case ITypeInfo::Generic:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
					case ITypeInfo::Nullable:
						return false;
					case ITypeInfo::TypeDescriptor:
						return CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						if (explicitly) return true;
						if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
						{
							return false;
						}
						if (!CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly)) return false;
						for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
						{
							if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
							{
								return false;
							}
						}
						return true;
					}
					break;
				}
				return false;
			}

/***********************************************************************
IsSameType
***********************************************************************/

			bool IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				if (fromType->GetDecorator() != toType->GetDecorator())
				{
					return false;
				}
				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return IsSameType(fromType->GetElementType(), toType->GetElementType());
				case ITypeInfo::TypeDescriptor:
					return fromType->GetTypeDescriptor() == toType->GetTypeDescriptor();
				case ITypeInfo::Generic:
					if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
					{
						return false;
					}
					if (!IsSameType(fromType->GetElementType(), toType->GetElementType())) return false;
					for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
					{
						if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

/***********************************************************************
GetMergedType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType)
			{
				if (CanConvertToType(secondType.Obj(), firstType.Obj(), false))
				{
					return firstType;
				}
				else if (CanConvertToType(firstType.Obj(), secondType.Obj(), false))
				{
					return secondType;
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
IsNullAcceptableType
***********************************************************************/

			bool IsNullAcceptableType(reflection::description::ITypeInfo* type)
			{
				switch (type->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return true;
				case ITypeInfo::TypeDescriptor:
					return type->GetTypeDescriptor() == description::GetTypeDescriptor<Value>();
				case ITypeInfo::Generic:
					return false;
				}
				return false;
			}

/***********************************************************************
CreateTypeInfoFromMethodInfo
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info)
			{
				Ptr<TypeInfoImpl> functionType = new TypeInfoImpl(ITypeInfo::SharedPtr);
				{
					Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
					functionType->SetElementType(genericType);
					{
						Ptr<TypeInfoImpl> elementType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						elementType->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());
						genericType->SetElementType(elementType);
					}

					genericType->AddGenericArgument(CopyTypeInfo(info->GetReturn()));
					vint parameterCount = info->GetParameterCount();
					for (vint j = 0; j < parameterCount; j++)
					{
						genericType->AddGenericArgument(CopyTypeInfo(info->GetParameter(j)->GetType()));
					}
				}
				return functionType;
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_ValidateSemantic.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
ValidateSemantic(Declaration)
***********************************************************************/

			class ValidateSemanticDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					FOREACH(Ptr<WfDeclaration>, declaration, node->declarations)
					{
						declaration->Accept(this);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = manager->declarationScopes[node];
					auto symbol = scope->symbols[node->name.value][0];
					symbol->typeInfo = GetExpressionType(manager, node->expression, symbol->typeInfo);
					if (symbol->typeInfo && !symbol->type)
					{
						symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
					}
				}

				static void Execute(Ptr<WfDeclaration> declaration, WfLexicalScopeManager* manager)
				{
					ValidateSemanticDeclarationVisitor visitor(manager);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Statement)
***********************************************************************/

			class ValidateSemanticStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticStatementVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					auto scope = manager->statementScopes[node].Obj();
					auto decl = scope->FindDeclaration().Cast<WfFunctionDeclaration>();
					auto returnType = CreateTypeInfoFromType(scope, decl->returnType);
					if (node->expression)
					{
						GetExpressionType(manager, node->expression, returnType);
					}
					else if (returnType->GetDecorator() != ITypeInfo::TypeDescriptor || returnType->GetTypeDescriptor() != description::GetTypeDescriptor<void>())
					{
						manager->errors.Add(WfErrors::ReturnMissExpression(node, returnType.Obj()));
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						if (type->GetDecorator() != ITypeInfo::RawPtr)
						{
							manager->errors.Add(WfErrors::DeleteNonRawPointer(node, type.Obj()));
						}
					}
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					Ptr<ITypeInfo> stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
					GetExpressionType(manager, node->expression, stringType);
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						auto scope = manager->statementScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						if (!IsNullAcceptableType(symbol->typeInfo.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), symbol->typeInfo.Obj()));
						}
						GetExpressionType(manager, node->expression, 0);
					}
					else
					{
						Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
						GetExpressionType(manager, node->expression, boolType);
					}
					ValidateStatementSemantic(manager, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementSemantic(manager, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						Ptr<ITypeInfo> caseType;
						if (IsExpressionDependOnExpectedType(switchCase->expression))
						{
							caseType = GetExpressionType(manager, switchCase->expression, type);
						}
						else
						{
							caseType = GetExpressionType(manager, switchCase->expression, 0);
						}

						if (type && caseType)
						{
							if (!GetMergedType(type, caseType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(switchCase->expression.Obj(), type.Obj(), caseType.Obj()));
							}
						}
						ValidateStatementSemantic(manager, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementSemantic(manager, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfForEachStatement* node)override
				{
					Ptr<ITypeInfo> elementType = GetEnumerableExpressionItemType(manager, node->collection, 0);
					if (elementType)
					{
						auto scope = manager->statementScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						symbol->typeInfo = elementType;
						symbol->type = GetTypeFromTypeInfo(elementType.Obj());
					}
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementSemantic(manager, node->protectedStatement);
					if (node->catchStatement)
					{
						ValidateStatementSemantic(manager, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						ValidateStatementSemantic(manager, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					FOREACH(Ptr<WfStatement>, statement, node->statements)
					{
						statement->Accept(this);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					GetExpressionType(manager, node->expression, 0);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationSemantic(manager, node->variable);
				}

				static void Execute(Ptr<WfStatement> statement, WfLexicalScopeManager* manager)
				{
					ValidateSemanticStatementVisitor visitor(manager);
					statement->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Expression)
***********************************************************************/

			class ValidateSemanticExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<ITypeInfo>						expectedType;
				List<ResolveExpressionResult>&		results;

				ValidateSemanticExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<ITypeInfo> _expectedType, List<ResolveExpressionResult>& _results)
					:manager(_manager)
					, expectedType(_expectedType)
					, results(_results)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult(manager->globalName->children.Values()[index]));
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void Visit(WfReferenceExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					if (symbols.Count() >= 1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
						{
							if (symbol->typeInfo)
							{
								bool writable = false;
								if (symbol->creatorDeclaration.Cast<WfVariableDeclaration>())
								{
									if (!symbol->ownerScope->ownerDeclaration.Cast<WfNamespaceDeclaration>())
									{
										auto currentScope = scope;
										while (currentScope)
										{
											vint index = currentScope->symbols.Keys().IndexOf(symbol->name);
											if (index != -1 && currentScope->symbols.GetByIndex(index).Contains(symbol.Obj()))
											{
												writable = true;
												break;
											}

											if (currentScope->ownerDeclaration.Cast<WfFunctionDeclaration>())
											{
												break;
											}
											if (currentScope->ownerExpression.Cast<WfOrderedLambdaExpression>())
											{
												break;
											}
											currentScope = currentScope->parentScope.Obj();
										}
									}
								}

								if (writable)
								{
									results.Add(ResolveExpressionResult(symbol, symbol->typeInfo, symbol->typeInfo));
								}
								else
								{
									results.Add(ResolveExpressionResult(symbol, symbol->typeInfo));
								}
							}
						}

						if (results.Count() == 0)
						{
							FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
							{
								manager->errors.Add(WfErrors::ExpressionCannotResolveType(node, symbol));
							}
						}
						return;
					}

					List<Ptr<WfLexicalScopeName>> scopeNames;
					manager->ResolveScopeName(scope, node->name.value, scopeNames);
					if (scopeNames.Count() >= 1)
					{
						FOREACH(Ptr<WfLexicalScopeName>, scopeName, scopeNames)
						{
							results.Add(ResolveExpressionResult(scopeName));
						}
					}
					else
					{
						manager->errors.Add(WfErrors::ReferenceNotExists(node, node->name.value));
					}
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					List<Ptr<WfLexicalSymbol>> symbols;
					manager->ResolveSymbol(scope, node->name.value, symbols);
					if (symbols.Count() >= 1)
					{
						FOREACH(Ptr<WfLexicalSymbol>, symbol, symbols)
						{
							if (symbol->typeInfo)
							{
								results.Add(ResolveExpressionResult(symbol, symbol->typeInfo));
							}
						}
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					if (!expectedType)
					{
						manager->errors.Add(WfErrors::OrderedLambdaCannotResolveType(node));
						return;
					}
					{
						ITypeInfo* type = expectedType.Obj();
						if (type->GetDecorator() != ITypeInfo::SharedPtr) goto ORDERED_FAILED;
						type = type->GetElementType();
						if (type->GetDecorator() != ITypeInfo::Generic) goto ORDERED_FAILED;
						{
							ITypeInfo* functionType = type->GetElementType();
							if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor) goto ORDERED_FAILED;
							if (functionType->GetTypeDescriptor() != description::GetTypeDescriptor<IValueFunctionProxy>()) goto ORDERED_FAILED;
						}

						auto scope = manager->expressionScopes[node].Obj();
						List<Ptr<WfLexicalSymbol>> parameterSymbols;
						CopyFrom(
							parameterSymbols,
							Range<vint>(0, scope->symbols.Count())
								.Select([scope](vint index)->Ptr<WfLexicalSymbol>{return scope->symbols.GetByIndex(index)[0];})
								.OrderBy([](Ptr<WfLexicalSymbol> a, Ptr<WfLexicalSymbol> b)
								{
									vint aId = wtoi(a->name.Sub(1, a->name.Length() - 1));
									vint bId = wtoi(b->name.Sub(1, a->name.Length() - 1));
									return aId - bId;
								})
							);
						if (type->GetGenericArgumentCount() != parameterSymbols.Count() + 1)
						{
							goto ORDERED_FAILED;
						}

						Ptr<ITypeInfo> resultType = type->GetGenericArgument(0);
						FOREACH_INDEXER(Ptr<WfLexicalSymbol>, symbol, index, parameterSymbols)
						{
							symbol->typeInfo = type->GetGenericArgument(index + 1);
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
						GetExpressionType(manager, node->body, resultType);
					}

					goto ORDERED_FINISHED;
				ORDERED_FAILED:
					manager->errors.Add(WfErrors::OrderedLambdaCannotImplicitlyConvertToType(node, expectedType.Obj()));
				ORDERED_FINISHED:
					results.Add(ResolveExpressionResult(expectedType));
				}

				void Visit(WfMemberExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->parent, 0);
					if (type)
					{
						ITypeDescriptor* typeDescriptor = type->GetTypeDescriptor();
						if (IPropertyInfo* info = typeDescriptor->GetPropertyByName(node->name.value, true))
						{
							Ptr<ITypeInfo> getterType = CopyTypeInfo(info->GetReturn());
							Ptr<ITypeInfo> setterType;
							if (IMethodInfo* setter = info->GetSetter())
							{
								setterType = getterType;
								if (setter->GetParameterCount() == 1 && !IsSameType(getterType.Obj(), setter->GetParameter(0)->GetType()))
								{
									setterType = CopyTypeInfo(setter->GetParameter(0)->GetType());
								}
							}
							ResolveExpressionResult result(info, getterType, setterType);
							results.Add(result);
						}
						if (IEventInfo* info = typeDescriptor->GetEventByName(node->name.value, true))
						{
							ResolveExpressionResult result(info);
							results.Add(result);
						}
						if (IMethodGroupInfo* groupInfo = typeDescriptor->GetMethodGroupByName(node->name.value, true))
						{
							vint count = groupInfo->GetMethodCount();
							for (vint i = 0; i < count; i++)
							{
								IMethodInfo* info = groupInfo->GetMethod(i);
								ResolveExpressionResult result(info, CreateTypeInfoFromMethodInfo(info));
								results.Add(result);
							}
						}

						if (results.Count() == 0)
						{
							manager->errors.Add(WfErrors::MemberNotExists(node, typeDescriptor, node->name.value));
						}
					}
				}

				void Visit(WfChildExpression* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = GetExpressionScopeName(manager, node->parent))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult(scopeName->children.Values()[index]));
							return;
						}

						if (scopeName->typeDescriptor)
						{
							if (auto group = scopeName->typeDescriptor->GetMethodGroupByName(node->name.value, true))
							{
								bool found = false;
								for (vint i = 0; i < group->GetMethodCount(); i++)
								{
									auto info = group->GetMethod(i);
									if (info->IsStatic())
									{
										found = true;
										results.Add(ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info)));
									}
								}

								if (found)
								{
									return;
								}
							}
						}
						manager->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
					}
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						if (!expectedType)
						{
							manager->errors.Add(WfErrors::NullCannotResolveType(node));
						}
						else if (!IsNullAcceptableType(expectedType.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node, expectedType.Obj()));
						}

						results.Add(ResolveExpressionResult(expectedType));
					}
					else
					{
						results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<double>::CreateTypeInfo()));
				}

				void Visit(WfIntegerExpression* node)override
				{
					ITypeDescriptor* typeDescriptor = 0;
#ifndef VCZH_64
					typeDescriptor = description::GetTypeDescriptor<vint32_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					typeDescriptor = description::GetTypeDescriptor<vuint32_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}
#endif
					typeDescriptor = description::GetTypeDescriptor<vint64_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					typeDescriptor = description::GetTypeDescriptor<vuint64_t>();
					if (typeDescriptor->GetValueSerializer()->Validate(node->value.value))
					{
						goto TYPE_FINISHED;
					}

					manager->errors.Add(WfErrors::IntegerLiteralOutOfRange(node));

				TYPE_FINISHED:
					Ptr<TypeInfoImpl> typeInfo = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
					typeInfo->SetTypeDescriptor(typeDescriptor);
					results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)typeInfo));
				}

				void Visit(WfStringExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<WString>::CreateTypeInfo()));
				}

				void Visit(WfFormatExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = TypeInfoRetriver<WString>::CreateTypeInfo();
					results.Add(ResolveExpressionResult(typeInfo));
					GetExpressionType(manager, node->expandedExpression, typeInfo);
				}

				void Visit(WfUnaryExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = GetExpressionType(manager, node->operand, 0);
					if (typeInfo)
					{
						TypeFlag flag = GetTypeFlag(typeInfo.Obj());
						switch (node->op)
						{
						case WfUnaryOperator::Not:
							switch (flag)
							{
							case TypeFlag::F4:
							case TypeFlag::F8:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							}
							break;
						case WfUnaryOperator::Positive:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							}
							break;
						case WfUnaryOperator::Negative:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::U1:
							case TypeFlag::U2:
							case TypeFlag::U4:
							case TypeFlag::U8:
							case TypeFlag::String:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							}
							break;
						}

						results.Add(ResolveExpressionResult(typeInfo));
					}
				}

				void Visit(WfBinaryExpression* node)override
				{

					if (node->op == WfBinaryOperator::Assign)
					{
						Ptr<ITypeInfo> variableType = GetLeftValueExpressionType(manager, node->first);
						GetExpressionType(manager, node->second, variableType);
						if (variableType)
						{
							results.Add(ResolveExpressionResult(variableType));
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						Ptr<ITypeInfo> containerType = GetExpressionType(manager, node->first, 0);
						if (containerType)
						{
							if (containerType->GetDecorator() == ITypeInfo::SharedPtr)
							{
								ITypeInfo* genericType = containerType->GetElementType();
								Ptr<ITypeInfo> indexType;
								Ptr<ITypeInfo> resultType;
								bool leftValue = false;

								if (genericType->GetDecorator() == ITypeInfo::Generic)
								{
									ITypeInfo* classType = genericType->GetElementType();
									if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
										leftValue = true;
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}
								else
								{
									if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = TypeInfoRetriver<vint>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}

								GetExpressionType(manager, node->second, indexType);
								if (resultType)
								{
									if (leftValue)
									{
										results.Add(ResolveExpressionResult(resultType, resultType));
									}
									else
									{
										results.Add(ResolveExpressionResult(resultType));
									}
								}
							}
							else
							{
								manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
							}
						}
					}
					else if (node->op == WfBinaryOperator::Concat)
					{
						Ptr<ITypeInfo> stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
						GetExpressionType(manager, node->first, stringType);
						GetExpressionType(manager, node->second, stringType);
						results.Add(ResolveExpressionResult(stringType));
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						GetExpressionType(manager, node->second, firstType);
						if (firstType)
						{
							results.Add(ResolveExpressionResult(firstType));
						}
					}
					else
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->second, 0);
						Ptr<ITypeInfo> elementType;
						if (firstType && secondType)
						{
							if (!(elementType = GetMergedType(firstType, secondType)))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
							}
						}

						if (elementType)
						{
							TypeFlag flag = GetTypeFlag(elementType.Obj());
							TypeFlag* selectedTable = 0;
							switch (node->op)
							{
							case WfBinaryOperator::Exp:
							case WfBinaryOperator::Add:
							case WfBinaryOperator::Sub:
							case WfBinaryOperator::Mul:
							case WfBinaryOperator::Div:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I,
										/*I2		*/TypeFlag::I,
										/*I4		*/TypeFlag::I,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U,
										/*U2		*/TypeFlag::U,
										/*U4		*/TypeFlag::U,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::F4,
										/*F8		*/TypeFlag::F8,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::Shl:
							case WfBinaryOperator::Shr:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I,
										/*I2		*/TypeFlag::I,
										/*I4		*/TypeFlag::I,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U,
										/*U2		*/TypeFlag::U,
										/*U4		*/TypeFlag::U,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::LT:
							case WfBinaryOperator::GT:
							case WfBinaryOperator::LE:
							case WfBinaryOperator::GE:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::Bool,
										/*I2		*/TypeFlag::Bool,
										/*I4		*/TypeFlag::Bool,
										/*I8		*/TypeFlag::Bool,
										/*U1		*/TypeFlag::Bool,
										/*U2		*/TypeFlag::Bool,
										/*U4		*/TypeFlag::Bool,
										/*U8		*/TypeFlag::Bool,
										/*F4		*/TypeFlag::Bool,
										/*F8		*/TypeFlag::Bool,
										/*String	*/TypeFlag::Bool,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::EQ:
							case WfBinaryOperator::NE:
								{
									switch (elementType->GetDecorator())
									{
									case ITypeInfo::RawPtr:
									case ITypeInfo::SharedPtr:
										results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
										return;
									default:
										static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
											/*Bool		*/TypeFlag::Bool,
											/*I1		*/TypeFlag::Bool,
											/*I2		*/TypeFlag::Bool,
											/*I4		*/TypeFlag::Bool,
											/*I8		*/TypeFlag::Bool,
											/*U1		*/TypeFlag::Bool,
											/*U2		*/TypeFlag::Bool,
											/*U4		*/TypeFlag::Bool,
											/*U8		*/TypeFlag::Bool,
											/*F4		*/TypeFlag::Bool,
											/*F8		*/TypeFlag::Bool,
											/*String	*/TypeFlag::Bool,
											/*Others	*/TypeFlag::Unknown,
										};
										selectedTable = conversionTable;
									}
								}
								break;
							case WfBinaryOperator::Xor:
							case WfBinaryOperator::And:
							case WfBinaryOperator::Or:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Bool,
										/*I1		*/TypeFlag::I1,
										/*I2		*/TypeFlag::I2,
										/*I4		*/TypeFlag::I4,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U1,
										/*U2		*/TypeFlag::U2,
										/*U4		*/TypeFlag::U4,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							}

							TypeFlag resultFlag = selectedTable[(vint)flag];
							if (resultFlag == TypeFlag::Unknown)
							{
								manager->errors.Add(WfErrors::BinaryOperatorOnWrongType(node, elementType.Obj()));
							}
							else
							{
								results.Add(ResolveExpressionResult(CreateTypeInfoFromTypeFlag(resultFlag)));
							}
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();

					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						auto symbol = scope->symbols[variable->name.value][0];
						symbol->typeInfo = GetExpressionType(manager, variable->value, 0);
						if (symbol->typeInfo)
						{
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
					}
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, expectedType);
					if (type)
					{
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);

					Ptr<ITypeInfo> firstType, secondType;

					if (expectedType)
					{
						firstType = GetExpressionType(manager, node->trueBranch, expectedType);
						secondType = GetExpressionType(manager, node->falseBranch, expectedType);
					}
					else
					{
						bool resolveFirst = !IsExpressionDependOnExpectedType(node->trueBranch);
						bool resolveSecond = !IsExpressionDependOnExpectedType(node->falseBranch);

						if (resolveFirst == resolveSecond)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, 0);
						}
						else if (resolveFirst)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, firstType);
						}
						else if (resolveSecond)
						{
							secondType = GetExpressionType(manager, node->falseBranch, 0);
							firstType = GetExpressionType(manager, node->trueBranch, secondType);
						}
					}
					
					if (firstType && !secondType)
					{
						results.Add(ResolveExpressionResult(firstType));
					}
					else if (!firstType && secondType)
					{
						results.Add(ResolveExpressionResult(secondType));
					}
					else if (firstType && secondType)
					{
						if (auto mergedType = GetMergedType(firstType, secondType))
						{
							results.Add(ResolveExpressionResult(mergedType));
						}
						else
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}
				}

				void Visit(WfRangeExpression* node)override
				{
					Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->begin, 0);
					Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->end, 0);
					Ptr<ITypeInfo> elementType;

					if (firstType && !secondType)
					{
						elementType = firstType;
					}
					else if (!firstType && secondType)
					{
						elementType = secondType;
					}
					else if (firstType && secondType)
					{
						if (!(elementType = GetMergedType(firstType, secondType)))
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}

					if (elementType)
					{
						TypeFlag flag = GetTypeFlag(elementType.Obj());
						switch (flag)
						{
						case TypeFlag::I1:
						case TypeFlag::I2:
						case TypeFlag::I4:
						case TypeFlag::I8:
						case TypeFlag::U1:
						case TypeFlag::U2:
						case TypeFlag::U4:
						case TypeFlag::U8:
							break;
						default:
							manager->errors.Add(WfErrors::RangeShouldBeInteger(node, elementType.Obj()));
						}

						Ptr<TypeInfoImpl> enumerableType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
						enumerableType->SetTypeDescriptor(description::GetTypeDescriptor<IValueEnumerable>());

						Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
						genericType->SetElementType(enumerableType);
						genericType->AddGenericArgument(elementType);

						Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
						pointerType->SetElementType(genericType);
						results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
					}
				}

				void Visit(WfSetTestingExpression* node)override
				{
					Ptr<ITypeInfo> elementType = GetExpressionType(manager, node->element, 0);

					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						Ptr<ITypeInfo> beginType = GetExpressionType(manager, range->begin, 0);
						Ptr<ITypeInfo> endType = GetExpressionType(manager, range->end, 0);

						if (elementType && beginType)
						{
							if (!GetMergedType(elementType, beginType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), beginType.Obj()));
							}
						}
						if (elementType && endType)
						{
							if (!GetMergedType(elementType, endType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), endType.Obj()));
							}
						}
					}
					else
					{
						Ptr<ITypeInfo> itemType = GetEnumerableExpressionItemType(manager, node->collection, 0);
						if (elementType && itemType)
						{
							if (!GetMergedType(elementType, itemType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), itemType.Obj()));
							}
						}
					}

					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfConstructorExpression* node)override
				{
					if (node->arguments.Count() == 0)
					{
						if (expectedType)
						{
							ITypeDescriptor* td = expectedType->GetTypeDescriptor();
							if (!td->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()) && !td->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyDictionary>()))
							{
								manager->errors.Add(WfErrors::ConstructorCannotImplicitlyConvertToType(node, expectedType.Obj()));
							}
							results.Add(ResolveExpressionResult(expectedType));
						}
						else
						{
							manager->errors.Add(WfErrors::ConstructorCannotResolveType(node));
						}
					}
					else
					{
						bool map = node->arguments[0]->value;
						Ptr<ITypeInfo> keyType, valueType;
						FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
						{
							{
								Ptr<ITypeInfo> newKeyType = GetExpressionType(manager, argument->key, 0);
								if (!keyType)
								{
									keyType = newKeyType;
								}
								else if (auto mergedType = GetMergedType(keyType, newKeyType))
								{
									keyType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, keyType.Obj(), newKeyType.Obj()));
								}
							}
							if (map)
							{
								Ptr<ITypeInfo> newValueType = GetExpressionType(manager, argument->value, 0);
								if (!valueType)
								{
									valueType = newValueType;
								}
								else if (auto mergedType = GetMergedType(valueType, newValueType))
								{
									valueType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, valueType.Obj(), newValueType.Obj()));
								}
							}
						}

						if (map)
						{
							if (keyType && valueType)
							{
								Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
								{
									Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
									pointerType->SetElementType(genericType);
									{
										Ptr<TypeInfoImpl> classType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
										classType->SetTypeDescriptor(description::GetTypeDescriptor<IValueDictionary>());
										genericType->SetElementType(classType);
									}
									genericType->AddGenericArgument(keyType);
									genericType->AddGenericArgument(valueType);
								}
								results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
							}
						}
						else
						{
							if (keyType)
							{
								Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::SharedPtr);
								{
									Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
									pointerType->SetElementType(genericType);
									{
										Ptr<TypeInfoImpl> classType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
										classType->SetTypeDescriptor(description::GetTypeDescriptor<IValueList>());
										genericType->SetElementType(classType);
									}
									genericType->AddGenericArgument(keyType);
								}
								results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)pointerType));
							}
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					Ptr<ITypeInfo> expressionType = GetExpressionType(manager, node->expression, type);
					if (expressionType)
					{
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					Ptr<ITypeInfo> expressionType = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						if (expressionType)
						{
							if (!CanConvertToType(expressionType.Obj(), type.Obj(), true))
							{
								manager->errors.Add(WfErrors::ExpressionCannotExplicitlyConvertToType(node->expression.Obj(), expressionType.Obj(), type.Obj()));
							}
						}
						if (node->strategy == WfTypeCastingStrategy::Weak)
						{
							switch (type->GetDecorator())
							{
							case ITypeInfo::RawPtr:
							case ITypeInfo::SharedPtr:
							case ITypeInfo::Nullable:
								break;
							default:
								manager->errors.Add(WfErrors::CannotWeakCastToType(node->expression.Obj(), type.Obj()));
							}
						}
						results.Add(ResolveExpressionResult(type));
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						switch (node->test)
						{
						case WfTypeTesting::IsNull:
						case WfTypeTesting::IsNotNull:
							if (!IsNullAcceptableType(type.Obj()))
							{
								manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), type.Obj()));
							}
							break;
						}
					}
					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					results.Add(ResolveExpressionResult(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfAttachEventExpression* node)override
				{
					IEventInfo* eventInfo = GetExpressionEventInfo(manager, node->event);
					Ptr<ITypeInfo> functionType;
					if (eventInfo)
					{
						functionType = CopyTypeInfo(eventInfo->GetHandlerType());
					}
					GetExpressionType(manager, node->function, functionType);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo()));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					Ptr<ITypeInfo> pointerType = TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo();
					GetExpressionType(manager, node->handler, pointerType);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfBindExpression* node)override
				{
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult(TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo()));
				}

				void Visit(WfObserveExpression* node)override
				{
					Ptr<ITypeInfo> parentType = GetExpressionType(manager, node->parent, 0);
					Ptr<ITypeInfo> observeeType;
					if (parentType)
					{
						if (node->observeType == WfObserveType::SimpleObserve)
						{
							ITypeDescriptor* td = parentType->GetTypeDescriptor();
							{
								auto ref = node->expression.Cast<WfReferenceExpression>();
								IPropertyInfo* info = td->GetPropertyByName(ref->name.value, true);
								if (info)
								{
									observeeType = CopyTypeInfo(info->GetReturn());
								}
								else
								{
									manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
								}
							}

							if (node->events.Count() == 0)
							{
								auto ref = node->expression.Cast<WfReferenceExpression>();
								IEventInfo* info = td->GetEventByName(ref->name.value + L"Changed", true);
								if (!info)
								{
									manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value + L"Changed"));
								}
							}
							else
							{
								FOREACH(Ptr<WfExpression>, eventExpr, node->events)
								{
									auto ref = eventExpr.Cast<WfReferenceExpression>();
									IEventInfo* info = td->GetEventByName(ref->name.value, true);
									if (!info)
									{
										manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
									}
								}
							}
						}
						else
						{
							auto scope = manager->expressionScopes[node].Obj();
							auto symbol = scope->symbols[node->name.value][0];
							symbol->typeInfo = parentType;
							symbol->type = GetTypeFromTypeInfo(parentType.Obj());

							observeeType = GetExpressionType(manager, node->expression, 0);
							FOREACH(Ptr<WfExpression>, eventExpr, node->events)
							{
								GetExpressionEventInfo(manager, eventExpr);
							}
						}
					}

					if (observeeType)
					{
						results.Add(ResolveExpressionResult(observeeType));
					}
				}

				Ptr<ITypeInfo> SelectFunction(WfExpression* node, Ptr<WfExpression> functionExpression, List<ResolveExpressionResult>& functions, List<Ptr<WfExpression>>& arguments)
				{
					List<bool> resolvables;
					List<Ptr<ITypeInfo>> types;
					FOREACH(Ptr<WfExpression>, argument, arguments)
					{
						if (IsExpressionDependOnExpectedType(argument))
						{
							resolvables.Add(false);
							types.Add(0);
						}
						else
						{
							resolvables.Add(true);
							types.Add(GetExpressionType(manager, argument, 0));
						}
					}

					List<Ptr<parsing::ParsingError>> functionErrors, nonFunctionErrors;
					ITypeDescriptor* functionFd = description::GetTypeDescriptor<IValueFunctionProxy>();
					for (vint i = functions.Count() - 1; i >= 0; i--)
					{
						bool failed = false;
						auto result = functions[i];
						if (result.type->GetDecorator() == ITypeInfo::SharedPtr)
						{
							ITypeInfo* genericType = result.type->GetElementType();
							if (genericType->GetDecorator() != ITypeInfo::Generic) goto FUNCTION_TYPE_FAILED;
							ITypeInfo* functionType = genericType->GetElementType();
							if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor || functionType->GetTypeDescriptor() != functionFd) goto FUNCTION_TYPE_FAILED;
								
							if (genericType->GetGenericArgumentCount() != types.Count() + 1)
							{
								functionErrors.Add(WfErrors::FunctionArgumentCountMismatched(node, arguments.Count(), result));
								failed = true;
							}
							else
							{
								for (vint j = 0; j < types.Count(); j++)
								{
									if (resolvables[j] && types[j])
									{
										ITypeInfo* argumentType = genericType->GetGenericArgument(j + 1);
										if (!CanConvertToType(types[j].Obj(), argumentType, false))
										{
											functionErrors.Add(WfErrors::FunctionArgumentTypeMismatched(node, result, i + 1, types[j].Obj(), argumentType));
											failed = true;
										}
									}
								}
							}
						}
						else
						{
							goto FUNCTION_TYPE_FAILED;
						}

						goto FUNCTION_TYPE_FINISHED;
					FUNCTION_TYPE_FAILED:
						nonFunctionErrors.Add(WfErrors::ExpressionIsNotFunction(functionExpression.Obj(), result.type.Obj()));
						failed = true;
					FUNCTION_TYPE_FINISHED:
						if (failed)
						{
							functions.RemoveAt(i);
						}
					}

					if (functions.Count() > 1)
					{
						manager->errors.Add(WfErrors::CannotPickOverloadedFunctions(node, functions));
					}

					if (functions.Count() == 1)
					{
						Ptr<ITypeInfo> functionType = functions[0].type;
						ITypeInfo* genericType = functionType->GetElementType();
						for (vint i = 0; i < types.Count(); i++)
						{
							if (!resolvables[i])
							{
								ITypeInfo* argumentType = genericType->GetGenericArgument(i + 1);
								GetExpressionType(manager, arguments[i], CopyTypeInfo(argumentType));
							}
						}

						return CopyTypeInfo(genericType->GetGenericArgument(0));
					}
					else
					{
						CopyFrom(manager->errors, (functionErrors.Count() > 0 ? functionErrors : nonFunctionErrors), true);
					}
					return 0;
				}

				void Visit(WfCallExpression* node)override
				{
					List<ResolveExpressionResult> functions;
					GetExpressionTypes(manager, node->function, 0, functions);

					Ptr<ITypeInfo> resultType = SelectFunction(node, node->function, functions, node->arguments);
					if (resultType)
					{
						manager->expressionResolvings.Add(node->function, functions[0]);
						results.Add(ResolveExpressionResult(resultType));
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationSemantic(manager, node->function);
					auto scope = manager->declarationScopes[node->function.Obj()].Obj();

					Ptr<TypeInfoImpl> functionType = new TypeInfoImpl(ITypeInfo::SharedPtr);
					{
						Ptr<TypeInfoImpl> genericType = new TypeInfoImpl(ITypeInfo::Generic);
						functionType->SetElementType(genericType);
						{
							Ptr<TypeInfoImpl> elementType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
							elementType->SetTypeDescriptor(description::GetTypeDescriptor<IValueFunctionProxy>());
							genericType->SetElementType(elementType);
						}

						genericType->AddGenericArgument(CreateTypeInfoFromType(scope, node->function->returnType));
						FOREACH(Ptr<WfFunctionArgument>, argument, node->function->arguments)
						{
							genericType->AddGenericArgument(scope->symbols[argument->name.value][0]->typeInfo);
						}
					}
					results.Add(ResolveExpressionResult((Ptr<ITypeInfo>)functionType));
				}

				Ptr<ITypeInfo> GetFunctionDeclarationType(WfLexicalScope* scope,Ptr<WfFunctionDeclaration> decl)
				{
					Ptr<WfLexicalSymbol> symbol = From(manager->declarationScopes[decl.Obj()]->parentScope->symbols[decl->name.value])
						.Where([decl](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorDeclaration == decl;
						})
						.First();
					return symbol->typeInfo;
				}

				void Visit(WfNewTypeExpression* node)override
				{
					auto scope = manager->expressionScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					if (type)
					{
						ITypeDescriptor* td = type->GetTypeDescriptor();
						ITypeDescriptor* proxyTd = description::GetTypeDescriptor<IValueInterfaceProxy>();
						IMethodGroupInfo* ctors = td->GetConstructorGroup();
						Ptr<ITypeInfo> selectedType;
						ResolveExpressionResult selectedFunction;
						if (!ctors || ctors->GetMethodCount() == 0)
						{
							manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
						}
						else
						{
							if (node->functions.Count() == 0)
							{
								List<ResolveExpressionResult> functions;
								for (vint i = 0; i < ctors->GetMethodCount(); i++)
								{
									IMethodInfo* info = ctors->GetMethod(i);
									functions.Add(ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info)));
								}

								selectedType = SelectFunction(node, 0, functions, node->arguments);
								if (selectedType)
								{
									selectedFunction = functions[0];
								}
							}
							else
							{
								for (vint i = 0; i < ctors->GetMethodCount(); i++)
								{
									IMethodInfo* info = ctors->GetMethod(i);
									if (info->GetParameterCount() == 1)
									{
										ITypeInfo* parameterType = info->GetParameter(0)->GetType();
										if (parameterType->GetDecorator() == ITypeInfo::SharedPtr)
										{
											parameterType = parameterType->GetElementType();
											if (parameterType->GetDecorator() == ITypeInfo::TypeDescriptor && parameterType->GetTypeDescriptor() == proxyTd)
											{
												selectedType = CopyTypeInfo(info->GetReturn());
												selectedFunction = ResolveExpressionResult(info, CreateTypeInfoFromMethodInfo(info));
												break;
											}
										}
									}
								}
								if (!selectedType)
								{
									manager->errors.Add(WfErrors::InterfaceContainsNoConstructor(node, type.Obj()));
								}
								
								Group<WString, IMethodInfo*> interfaceMethods;
								Group<WString, Ptr<WfFunctionDeclaration>> implementMethods;

								FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
								{
									ValidateDeclarationSemantic(manager, function);
									implementMethods.Add(function->name.value, function);
								}

								{
									List<ITypeDescriptor*> types;
									types.Add(td);
									vint begin = 0;

									while (begin < types.Count())
									{
										ITypeDescriptor* currentType = types[begin++];
										vint count = currentType->GetBaseTypeDescriptorCount();
										for (vint i = 0; i < count; i++)
										{
											types.Add(currentType->GetBaseTypeDescriptor(i));
										}

										count = currentType->GetMethodGroupCount();
										for (vint i = 0; i < count; i++)
										{
											IMethodGroupInfo* group = currentType->GetMethodGroup(i);
											vint methodCount = group->GetMethodCount();
											for (vint j = 0; j < methodCount; j++)
											{
												interfaceMethods.Add(group->GetName(), group->GetMethod(j));
											}
										}
									}
								}

								auto discardFirst = [=](const WString& key, const List<IMethodInfo*>& methods)
									{
										FOREACH(IMethodInfo*, method, methods)
										{
											manager->errors.Add(WfErrors::InterfaceMethodNotImplemented(node, method));
										}
									};
								auto discardSecond = [=](const WString& key, const List<Ptr<WfFunctionDeclaration>>& methods)
									{
										FOREACH(Ptr<WfFunctionDeclaration>, decl, methods)
										{
											Ptr<ITypeInfo> declType = GetFunctionDeclarationType(scope, decl);
											manager->errors.Add(WfErrors::InterfaceMethodNotFound(decl.Obj(), type.Obj(), declType.Obj()));
										}
									};

								GroupInnerJoin(
									interfaceMethods,
									implementMethods,
									discardFirst,
									discardSecond,
									[=](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
									{
										Group<WString, IMethodInfo*> typedInterfaceMethods;
										Group<WString, Ptr<WfFunctionDeclaration>> typedImplementMethods;

										FOREACH(IMethodInfo*, method, interfaces)
										{
											Ptr<ITypeInfo> methodType = CreateTypeInfoFromMethodInfo(method);
											typedInterfaceMethods.Add(methodType->GetTypeFriendlyName(), method);
										}

										FOREACH(Ptr<WfFunctionDeclaration>, decl, implements)
										{
											Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
											typedImplementMethods.Add(methodType->GetTypeFriendlyName(), decl);
										}

										GroupInnerJoin(
											typedInterfaceMethods,
											typedImplementMethods,
											discardFirst,
											discardSecond,
											[=](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
											{
												if (interfaces.Count() > 1)
												{
													List<ResolveExpressionResult> functions;
													FOREACH(IMethodInfo*, method, interfaces)
													{
														functions.Add(ResolveExpressionResult(method, CreateTypeInfoFromMethodInfo(method)));
														manager->errors.Add(WfErrors::CannotPickOverloadedInterfaceMethods(node, functions));
													}
												}
												if (implements.Count() > 1)
												{
													auto decl = implements[0];
													Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
													manager->errors.Add(WfErrors::CannotPickOverloadedImplementMethods(decl.Obj(), methodType.Obj()));
												}
											});
									});
							}
						}
						if (selectedType)
						{
							if (!CanConvertToType(selectedType.Obj(), type.Obj(), false))
							{
								manager->errors.Add(WfErrors::ConstructorReturnTypeMismatched(node, selectedFunction, selectedType.Obj(), type.Obj()));
							}
						}
						results.Add(ResolveExpressionResult(selectedFunction.methodInfo, type));
					}
				}

				static void Execute(Ptr<WfExpression> expression, WfLexicalScopeManager* manager, Ptr<ITypeInfo> expectedType, List<ResolveExpressionResult>& results)
				{
					ValidateSemanticExpressionVisitor visitor(manager, expectedType, results);
					expression->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic
***********************************************************************/

			void ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				FOREACH(Ptr<WfDeclaration>, declaration, module->declarations)
				{
					ValidateDeclarationSemantic(manager, declaration);
				}
			}

			void ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
			{
				return ValidateSemanticDeclarationVisitor::Execute(declaration, manager);
			}

			void ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement)
			{
				return ValidateSemanticStatementVisitor::Execute(statement, manager);
			}

			void ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateSemanticExpressionVisitor::Execute(expression, manager, expectedType, results);
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto result = results[i];
					if (result.scopeName && result.scopeName->declarations.Count() > 0)
					{
						List<ResolveExpressionResult> replaces;
						FOREACH(Ptr<WfDeclaration>, decl, result.scopeName->declarations)
						{
							vint index = manager->declarationScopes.Keys().IndexOf(decl);
							if (index == -1) continue;
							auto scope = manager->declarationScopes.Values()[index];
							bool isVariable = decl.Cast<WfVariableDeclaration>();
							if (!isVariable)
							{
								scope = scope->parentScope;
							}

							index = scope->symbols.Keys().IndexOf(decl->name.value);
							if (index == -1) continue;
							FOREACH(Ptr<WfLexicalSymbol>, symbol, scope->symbols.GetByIndex(index))
							{
								if (symbol->creatorDeclaration == decl && symbol->typeInfo)
								{
									if (isVariable)
									{
										replaces.Add(ResolveExpressionResult(symbol, symbol->typeInfo, symbol->typeInfo));
									}
									else
									{
										replaces.Add(ResolveExpressionResult(symbol, symbol->typeInfo));
									}
								}
							}
						}

						if (replaces.Count() > 0)
						{
							results.RemoveAt(i);
							FOREACH_INDEXER(ResolveExpressionResult, replaceResult, index, replaces)
							{
								results.Insert(i + index, replaceResult);
							}
						}
					}
				}
			}

/***********************************************************************
GetExpressionScopeName
***********************************************************************/

			Ptr<WfLexicalScopeName> GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.scopeName)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotScopeName(expression.Obj()));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(expression, result);
				return result.scopeName;
			}

/***********************************************************************
GetExpressionEventInfo
***********************************************************************/

			reflection::description::IEventInfo* GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.eventInfo)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotEvent(expression.Obj()));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(expression, result);
				return result.eventInfo;
			}

/***********************************************************************
GetExpressionTypes/GetExpressionType/GetLeftValueExpressionType
***********************************************************************/

			void GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateExpressionSemantic(manager, expression, expectedType, results);
				if (results.Count() == 0) return;

				Ptr<WfLexicalScopeName> scopeName;
				IEventInfo* eventInfo = 0;
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (result.scopeName && !scopeName)
					{
						scopeName = result.scopeName;
					}
					if (result.eventInfo && !eventInfo)
					{
						eventInfo = result.eventInfo;
					}
					if (!result.type)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					if (scopeName)
					{
						manager->errors.Add(WfErrors::ScopeNameIsNotExpression(expression.Obj(), scopeName));
					}
					if (eventInfo)
					{
						manager->errors.Add(WfErrors::EventIsNotExpression(expression.Obj(), eventInfo));
					}
				}

				if (expectedType)
				{
					List<Ptr<ITypeInfo>> failedTypes;
					for (vint i = results.Count() - 1; i >= 0; i--)
					{
						auto& result = results[i];
						if (!CanConvertToType(result.type.Obj(), expectedType.Obj(), false))
						{
							failedTypes.Add(result.type);
							results.RemoveAt(i);
						}
					}

					if (results.Count() == 0)
					{
						FOREACH(Ptr<ITypeInfo>, type, failedTypes)
						{
							manager->errors.Add(WfErrors::ExpressionCannotImplicitlyConvertToType(expression.Obj(), type.Obj(), expectedType.Obj()));
						}
					}
				}
			}

			Ptr<reflection::description::ITypeInfo> GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, expectedType, results);

				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
					return expectedType;
				}
				else if (results.Count() == 1)
				{
					auto result = results[0];
					result.expectedType = expectedType;
					manager->expressionResolvings.Add(expression, result);
					return expectedType ? expectedType : result.type;
				}
				else
				{
					return expectedType;
				}
			}

			Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, 0, results);

				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression.Obj(), results, GetExpressionName(expression)));
				}
				else if (results.Count() == 1)
				{
					if (results[0].leftValueType)
					{
						auto result = results[0];
						manager->expressionResolvings.Add(expression, result);
						return result.leftValueType;
					}
					else
					{
						manager->errors.Add(WfErrors::ExpressionIsNotLeftValue(expression.Obj(), results[0]));
					}
				}
				return 0;
			}

/***********************************************************************
GetEnumerableExpressionItemType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				Ptr<ITypeInfo> collectionType = GetExpressionType(manager, expression, expectedType);
				if (collectionType)
				{
					if (collectionType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()))
					{
						if (collectionType->GetDecorator() == ITypeInfo::SharedPtr)
						{
							ITypeInfo* genericType = collectionType->GetElementType();
							if (genericType->GetDecorator() == ITypeInfo::Generic && genericType->GetGenericArgumentCount() == 1)
							{
								return CopyTypeInfo(genericType->GetGenericArgument(0));
							}
						}
						return TypeInfoRetriver<Value>::CreateTypeInfo();
					}

					manager->errors.Add(WfErrors::ExpressionIsNotCollection(expression.Obj(), collectionType.Obj()));
				}
				return 0;
			}
		}
	}
}

/***********************************************************************
Analyzer\WfAnalyzer_ValidateStructure.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace parsing;

/***********************************************************************
ValidateStructureContext
***********************************************************************/

			ValidateStructureContext::ValidateStructureContext()
				:currentBindExpression(0)
				, currentLoopStatement(0)
				, currentCatchStatement(0)
			{
			}

/***********************************************************************
ValidateStructure(Type)
***********************************************************************/

			class ValidateReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				bool									result;

				ValidateReferenceTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
					, result(true)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					result = false;
				}

				void Visit(WfSharedPointerType* node)override
				{
					result = false;
				}

				void Visit(WfNullableType* node)override
				{
					result = false;
				}

				void Visit(WfEnumerableType* node)override
				{
					result = false;
				}

				void Visit(WfMapType* node)override
				{
					result = false;
				}

				void Visit(WfFunctionType* node)override
				{
					result = false;
				}

				void Visit(WfChildType* node)override
				{
					node->parent->Accept(this);
				}

				static bool Execute(Ptr<WfType> type, WfLexicalScopeManager* manager)
				{
					ValidateReferenceTypeVisitor visitor(manager);
					type->Accept(&visitor);
					return visitor.result;
				}
			};

			class ValidateStructureTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;

				ValidateStructureTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						manager->errors.Add(WfErrors::WrongVoidType(node));
						break;
					case WfPredefinedTypeName::Interface:
						manager->errors.Add(WfErrors::WrongInterfaceType(node));
						break;
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						switch (predefinedType->name)
						{
						case WfPredefinedTypeName::Void:
						case WfPredefinedTypeName::Object:
						case WfPredefinedTypeName::Interface:
							manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
							break;
						}
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					ValidateTypeStructure(manager, node->element);
				}

				void Visit(WfMapType* node)override
				{
					if (node->key)
					{
						ValidateTypeStructure(manager, node->key);
					}
					ValidateTypeStructure(manager, node->value);
				}

				void Visit(WfFunctionType* node)override
				{
					ValidateTypeStructure(manager, node->result, true);
					FOREACH(Ptr<WfType>, argument, node->arguments)
					{
						ValidateTypeStructure(manager, argument);
					}
				}

				void Visit(WfChildType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->parent, manager))
					{
						manager->errors.Add(WfErrors::ChildOfNonReferenceType(node));
					}
				}

				static void Execute(Ptr<WfType> type, WfLexicalScopeManager* manager)
				{
					ValidateStructureTypeVisitor visitor(manager);
					type->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure(Declaration)
***********************************************************************/

			class ValidateStructureDeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ParsingTreeCustomBase*					source;

				ValidateStructureDeclarationVisitor(WfLexicalScopeManager* _manager, ParsingTreeCustomBase* _source)
					:manager(_manager)
					, source(_source)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (vint i = 0; i < node->declarations.Count(); i++)
					{
						ValidateDeclarationStructure(manager, node->declarations[i]);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->anonymity == WfFunctionAnonymity::Anonymous)
					{
						if (!source || !dynamic_cast<WfFunctionExpression*>(source))
						{
							manager->errors.Add(WfErrors::FunctionShouldHaveName(node));
						}
					}
					ValidateTypeStructure(manager, node->returnType, true);
					FOREACH(Ptr<WfFunctionArgument>, argument, node->arguments)
					{
						ValidateTypeStructure(manager, argument->type);
					}
					ValidateStructureContext context;
					ValidateStatementStructure(manager, &context, node->statement);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateStructureContext context;
					ValidateExpressionStructure(manager, &context, node->expression);
				}

				static void Execute(Ptr<WfDeclaration> declaration, WfLexicalScopeManager* manager, ParsingTreeCustomBase* source)
				{
					ValidateStructureDeclarationVisitor visitor(manager, source);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure(Statement)
***********************************************************************/

			class ValidateStructureStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfStatement>						result;

				ValidateStructureStatementVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::BreakNotInLoop(node));
					}
				}

				void Visit(WfContinueStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::ContinueNotInLoop(node));
					}
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
					else if (!context->currentCatchStatement)
					{
						manager->errors.Add(WfErrors::RethrowNotInCatch(node));
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
					ValidateStatementStructure(manager, context, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementStructure(manager, context, node->falseBranch);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
					FOREACH(Ptr<WfSwitchCase>, switchCase, node->caseBranches)
					{
						ValidateExpressionStructure(manager, context, switchCase->expression);
						ValidateStatementStructure(manager, context, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementStructure(manager, context, node->defaultBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfForEachStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->collection);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementStructure(manager, context, node->protectedStatement);
					if (node->catchStatement)
					{
						auto oldCatch = context->currentCatchStatement;
						context->currentCatchStatement = node->catchStatement.Obj();
						ValidateStatementStructure(manager, context, node->catchStatement);
						context->currentCatchStatement = oldCatch;
					}
					if (node->finallyStatement)
					{
						ValidateStatementStructure(manager, context, node->finallyStatement);
					}
					if (!node->catchStatement && !node->finallyStatement)
					{
						manager->errors.Add(WfErrors::TryMissCatchAndFinally(node));
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					for (vint i = 0; i < node->statements.Count(); i++)
					{
						ValidateStatementStructure(manager, context, node->statements[i]);
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationStructure(manager, node->variable, node);
				}

				static void Execute(Ptr<WfStatement>& statement, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureStatementVisitor visitor(manager, context);
					statement->Accept(&visitor);
					if (visitor.result)
					{
						statement = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure(Expression)
***********************************************************************/

			class ValidateStructureExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfExpression>						result;

				ValidateStructureExpressionVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto oldBind = context->currentBindExpression;
					context->currentBindExpression = 0;
					ValidateExpressionStructure(manager, context, node->body);
					context->currentBindExpression = oldBind;
				}

				void Visit(WfMemberExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfFormatExpression* node)override
				{
					if (!node->expandedExpression)
					{
						List<Ptr<WfExpression>> expressions;
						const wchar_t* reading = node->value.value.Buffer();

						while (*reading)
						{
							const wchar_t* begin = wcsstr(reading, L"$(");
							if (begin)
							{
								Ptr<WfStringExpression> expression = new WfStringExpression;
								expression->codeRange = node->codeRange;
								expression->value.value = WString(reading, begin - reading);
								expressions.Add(expression);
							}
							else
							{
								break;
							}

							const wchar_t* end = begin + 2;
							vint counter = 1;
							while (wchar_t c = *end++)
							{
								switch (c)
								{
								case L'(':
									counter++;
									break;
								case L')':
									counter--;
									break;
								}
								if (counter == 0)
								{
									break;
								}
							}

							if (counter != 0)
							{
								auto error = WfErrors::WrongFormatStringSyntax(node);
								error->errorMessage += L" (Does not find matched close bracket.)";
								manager->errors.Add(error);
								return;
							}
							else
							{
								WString input(begin + 2, end - begin - 3);
								List<Ptr<ParsingError>> errors;
								if (auto expression = WfParseExpression(input, manager->parsingTable, errors))
								{
									expressions.Add(expression);
								}
								FOREACH(Ptr<ParsingError>, originalError, errors)
								{
									auto error = WfErrors::WrongFormatStringSyntax(node);
									error->errorMessage += L" (" + originalError->errorMessage + L")";
									manager->errors.Add(error);
								}
								reading = end;
							}
						}
						if (*reading || expressions.Count() == 0)
						{
							Ptr<WfStringExpression> expression = new WfStringExpression;
							expression->codeRange = node->codeRange;
							expression->value.value = reading;
							expressions.Add(expression);
						}

						if (expressions.Count() > 0)
						{
							Ptr<WfExpression> current = expressions[0];
							FOREACH(Ptr<WfExpression>, expression, From(expressions).Skip(1))
							{
								Ptr<WfBinaryExpression> binary = new WfBinaryExpression;
								binary->codeRange = node->codeRange;
								binary->first = current;
								binary->second = expression;
								binary->op = WfBinaryOperator::Concat;
							}

							node->expandedExpression = current;
						}
					}

					if (node->expandedExpression)
					{
						ValidateExpressionStructure(manager, context, node->expandedExpression);
					}
				}

				void Visit(WfUnaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->first);
					ValidateExpressionStructure(manager, context, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					FOREACH(Ptr<WfLetVariable>, variable, node->variables)
					{
						ValidateExpressionStructure(manager, context, variable->value);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateExpressionStructure(manager, context, node->trueBranch);
					ValidateExpressionStructure(manager, context, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->begin);
					ValidateExpressionStructure(manager, context, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->element);
					ValidateExpressionStructure(manager, context, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					vint listElementCount = 0;
					vint mapElementCount = 0;
					FOREACH(Ptr<WfConstructorArgument>, argument, node->arguments)
					{
						ValidateExpressionStructure(manager, context, argument->key);
						if (argument->value)
						{
							ValidateExpressionStructure(manager, context, argument->value);
							mapElementCount++;
						}
						else
						{
							listElementCount++;
						}
					}

					if (listElementCount*mapElementCount != 0)
					{
						manager->errors.Add(WfErrors::ConstructorMixMapAndList(node));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->event);
					ValidateExpressionStructure(manager, context, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->handler);
				}

				void Visit(WfBindExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::BindInBind(node));
					}

					auto bind = context->currentBindExpression;
					context->currentBindExpression = node;
					ValidateExpressionStructure(manager, context, node->expression);
					context->currentBindExpression = bind;
				}

				void Visit(WfObserveExpression* node)override
				{
					if (!context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::ObserveNotInBind(node));
					}

					if (node->observeType == WfObserveType::SimpleObserve)
					{
						if (!node->expression.Cast<WfReferenceExpression>())
						{
							manager->errors.Add(WfErrors::WrongSimpleObserveExpression(node->expression.Obj()));
						}
						FOREACH(Ptr<WfExpression>, event, node->events)
						{
							if (!event.Cast<WfReferenceExpression>())
							{
								manager->errors.Add(WfErrors::WrongSimpleObserveEvent(event.Obj()));
							}
						}
					}
					else
					{
						if (node->events.Count() == 0)
						{
							manager->errors.Add(WfErrors::EmptyExtendedObserveEvent(node));
						}
					}

					ValidateExpressionStructure(manager, context, node->parent);
					ValidateExpressionStructure(manager, context, node->expression);
					for (vint i = 0; i < node->events.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->events[i]);
					}
				}

				void Visit(WfCallExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->function);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationStructure(manager, node->function, node);
				}

				void Visit(WfNewTypeExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
					FOREACH(Ptr<WfFunctionDeclaration>, function, node->functions)
					{
						ValidateDeclarationStructure(manager, function);
					}

					if (node->arguments.Count()*node->functions.Count() != 0)
					{
						manager->errors.Add(WfErrors::ConstructorMixClassAndInterface(node));
					}
				}

				static void Execute(Ptr<WfExpression>& expression, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureExpressionVisitor visitor(manager, context);
					expression->Accept(&visitor);
					if (visitor.result)
					{
						expression = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, bool returnType)
			{
				if (returnType)
				{
					if (auto predefinedType = type.Cast<WfPredefinedType>())
					{
						if (predefinedType->name == WfPredefinedTypeName::Void)
						{
							return;
						}
					}
				}
				ValidateStructureTypeVisitor::Execute(type, manager);
			}

			void ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				FOREACH(Ptr<WfModuleUsingPath>, path, module->paths)
				{
					FOREACH_INDEXER(Ptr<WfModuleUsingItem>, item, index, path->items)
					{
						vint counter = 0;
						FOREACH(Ptr<WfModuleUsingFragment>, fragment, item->fragments)
						{
							if (fragment.Cast<WfModuleUsingWildCardFragment>())
							{
								if (index == path->items.Count() - 1)
								{
									counter++;
								}
								else
								{
									goto USING_PATH_INCORRECT;
								}
							}
						}

						if (index == path->items.Count() - 1 && counter != 1)
						{
							goto USING_PATH_INCORRECT;
						}
					}
					continue;
				USING_PATH_INCORRECT:
					manager->errors.Add(WfErrors::WrongUsingPathWildCard(path.Obj()));
				}
				for (vint i = 0; i < module->declarations.Count(); i++)
				{
					ValidateDeclarationStructure(manager, module->declarations[i]);
				}
			}

			void ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, parsing::ParsingTreeCustomBase* source)
			{
				ValidateStructureDeclarationVisitor::Execute(declaration, manager, source);
			}

			void ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement)
			{
				ValidateStructureStatementVisitor::Execute(statement, manager, context);
			}

			void ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression)
			{
				ValidateStructureExpressionVisitor::Execute(expression, manager, context);
			}
		}
	}
}

/***********************************************************************
Expression\WfExpression.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		using namespace stream;

/***********************************************************************
Unescaping Functions
***********************************************************************/

		void UnescapeStringInternal(vl::parsing::ParsingToken& value, bool formatString)
		{
			MemoryStream memoryStream;
			{
				WString input = formatString ? value.value.Sub(2, value.value.Length() - 3) : value.value.Sub(1, value.value.Length() - 2);
				const wchar_t* reading = input.Buffer();
				StreamWriter writer(memoryStream);

				while (wchar_t c = *reading++)
				{
					if (c == L'\\')
					{
						switch (wchar_t e = *reading++)
						{
						case L'r':
							writer.WriteChar('\r');
							break;
						case L'n':
							writer.WriteChar('\n');
							break;
						case L't':
							writer.WriteChar('\t');
							break;
						default:
							writer.WriteChar(e);
						}
					}
					else
					{
						writer.WriteChar(c);
					}
				}
			}

			memoryStream.SeekFromBegin(0);
			{
				StreamReader reader(memoryStream);
				value.value = reader.ReadToEnd();
			}
		}

		void UnescapeFormatString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, true);
		}

		void UnescapeString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, false);
		}
	}
}

/***********************************************************************
Expression\WfExpressionParser.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Type"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum PredefinedTypeName"
L"\r\n" L"{"
L"\r\n" L"\tVoid,"
L"\r\n" L"\tObject,"
L"\r\n" L"\tInterface,"
L"\r\n" L"\tInt,"
L"\r\n" L"\tUInt,"
L"\r\n" L"\tFloat,"
L"\r\n" L"\tDouble,"
L"\r\n" L"\tString,"
L"\r\n" L"\tChar,"
L"\r\n" L"\tBool,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class PredefinedType : Type"
L"\r\n" L"{"
L"\r\n" L"\tPredefinedTypeName\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TopQualifiedType : Type"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReferenceType : Type"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RawPointerType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SharedPointerType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NullableType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class EnumerableType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\telement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum MapWritability"
L"\r\n" L"{"
L"\r\n" L"\tReadonly,"
L"\r\n" L"\tWritable,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class MapType : Type"
L"\r\n" L"{"
L"\r\n" L"\tMapWritability\t\t\twritability;"
L"\r\n" L"\tType\t\t\t\t\tkey;"
L"\r\n" L"\tType\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\tresult;"
L"\r\n" L"\tType[]\t\t\t\t\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ChildType : Type"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Expression"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TopQualifiedExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReferenceExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class OrderedNameExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class OrderedLambdaExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tbody;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class MemberExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ChildExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum LiteralValue"
L"\r\n" L"{"
L"\r\n" L"\tNull,"
L"\r\n" L"\tTrue,"
L"\r\n" L"\tFalse,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LiteralExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tLiteralValue\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FloatingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IntegerExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class StringExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue(UnescapeString);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FormatExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tvalue(UnescapeFormatString);"
L"\r\n" L"\tExpression\t\t\t\texpandedExpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum UnaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tPositive,"
L"\r\n" L"\tNegative,"
L"\r\n" L"\tNot,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class UnaryExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tUnaryOperator\t\t\top;"
L"\r\n" L"\tExpression\t\t\t\toperand;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum BinaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tAssign,"
L"\r\n" L"\tIndex,"
L"\r\n" L"\tConcat,"
L"\r\n" L"\tFailedThen,"
L"\r\n" L"\tExp,"
L"\r\n" L"\tAdd,"
L"\r\n" L"\tSub,"
L"\r\n" L"\tMul,"
L"\r\n" L"\tDiv,"
L"\r\n" L"\tShl,"
L"\r\n" L"\tShr,"
L"\r\n" L"\tLT,"
L"\r\n" L"\tGT,"
L"\r\n" L"\tLE,"
L"\r\n" L"\tGE,"
L"\r\n" L"\tEQ,"
L"\r\n" L"\tNE,"
L"\r\n" L"\tXor,"
L"\r\n" L"\tAnd,"
L"\r\n" L"\tOr,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BinaryExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tBinaryOperator\t\t\top;"
L"\r\n" L"\tExpression\t\t\t\tfirst;"
L"\r\n" L"\tExpression\t\t\t\tsecond;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LetVariable"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class LetExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tLetVariable[]\t\t\tvariables;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IfExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tcondition;"
L"\r\n" L"\tExpression\t\t\t\ttrueBranch;"
L"\r\n" L"\tExpression\t\t\t\tfalseBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum RangeBoundary"
L"\r\n" L"{"
L"\r\n" L"\tInclusive,"
L"\r\n" L"\tExclusive,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RangeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tbegin;"
L"\r\n" L"\tRangeBoundary\t\t\tbeginBoundary;"
L"\r\n" L"\tExpression\t\t\t\tend;"
L"\r\n" L"\tRangeBoundary\t\t\tendBoundary;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum SetTesting"
L"\r\n" L"{"
L"\r\n" L"\tIn,"
L"\r\n" L"\tNotIn,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SetTestingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tSetTesting\t\t\t\ttest;"
L"\r\n" L"\tExpression\t\t\t\telement;"
L"\r\n" L"\tExpression\t\t\t\tcollection;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ConstructorArgument"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tkey;"
L"\r\n" L"\tExpression\t\t\t\tvalue;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ConstructorExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tConstructorArgument[]\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class InferExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum TypeCastingStrategy"
L"\r\n" L"{"
L"\r\n" L"\tStrong,"
L"\r\n" L"\tWeak,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeCastingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tTypeCastingStrategy\t\tstrategy;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum TypeTesting"
L"\r\n" L"{"
L"\r\n" L"\tIsType,"
L"\r\n" L"\tIsNotType,"
L"\r\n" L"\tIsNull,"
L"\r\n" L"\tIsNotNull,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeTestingExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tTypeTesting\t\t\t\ttest;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeOfTypeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TypeOfExpressionExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class AttachEventExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tevent;"
L"\r\n" L"\tExpression\t\t\t\tfunction;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class DetachEventExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\thandler;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BindExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ObserveType"
L"\r\n" L"{"
L"\r\n" L"\tSimpleObserve,"
L"\r\n" L"\tExtendedObserve,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ObserveExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tparent;"
L"\r\n" L"\tObserveType\t\t\t\tobserveType;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tExpression[]\t\t\tevents;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CallExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tfunction;"
L"\r\n" L"\tExpression[]\t\t\targuments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BreakStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ContinueStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ReturnStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class DeleteStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class RaiseExceptionStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class IfStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tStatement\t\t\t\ttrueBranch;"
L"\r\n" L"\tStatement\t\t\t\tfalseBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SwitchCase"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SwitchStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"\tSwitchCase[]\t\t\tcaseBranches;"
L"\r\n" L"\tStatement\t\t\t\tdefaultBranch;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class WhileStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\tcondition;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ForEachDirection"
L"\r\n" L"{"
L"\r\n" L"\tNormal,"
L"\r\n" L"\tReversed,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ForEachStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tForEachDirection\t\tdirection;"
L"\r\n" L"\tExpression\t\t\t\tcollection;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class TryStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tStatement\t\t\t\tprotectedStatement;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tStatement\t\t\t\tcatchStatement;"
L"\r\n" L"\tStatement\t\t\t\tfinallyStatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class BlockStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tStatement[]\t\t\t\tstatements;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ExpressionStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Declaration"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NamespaceDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tDeclaration[]\t\t\tdeclarations;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionArgument"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum FunctionAnonymity"
L"\r\n" L"{"
L"\r\n" L"\tNamed,"
L"\r\n" L"\tAnonymous,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tFunctionAnonymity\t\tanonymity;"
L"\r\n" L"\tFunctionArgument[]\t\targuments;"
L"\r\n" L"\tType\t\t\t\t\treturnType;"
L"\r\n" L"\tStatement\t\t\t\tstatement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class FunctionExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tFunctionDeclaration\t\tfunction;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class VariableDeclaration : Declaration"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\tExpression\t\t\t\texpression;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class VariableStatement : Statement"
L"\r\n" L"{"
L"\r\n" L"\tVariableDeclaration\t\tvariable;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class NewTypeExpression : Expression"
L"\r\n" L"{"
L"\r\n" L"\tType\t\t\t\t\ttype;"
L"\r\n" L"\tExpression[]\t\t\targuments;"
L"\r\n" L"\tFunctionDeclaration[]\tfunctions;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingNameFragment : ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingWildCardFragment : ModuleUsingFragment"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingItem"
L"\r\n" L"{"
L"\r\n" L"\tModuleUsingFragment[]\tfragments;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class ModuleUsingPath"
L"\r\n" L"{"
L"\r\n" L"\tModuleUsingItem[]\t\titems;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ModuleType"
L"\r\n" L"{"
L"\r\n" L"\tModule,"
L"\r\n" L"\tUnit,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Module"
L"\r\n" L"{"
L"\r\n" L"\tModuleType\t\t\t\tmoduleType;"
L"\r\n" L"\ttoken\t\t\t\t\tname;"
L"\r\n" L"\tModuleUsingPath[]\t\tpaths;"
L"\r\n" L"\tDeclaration[]\t\t\tdeclarations;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token EXP = \"/^\";"
L"\r\n" L"token ADD = \"/+\";"
L"\r\n" L"token SUB = \"-\";"
L"\r\n" L"token MUL = \"/*\";"
L"\r\n" L"token DIV = \"//\";"
L"\r\n" L"token CONCAT = \"&\";"
L"\r\n" L"token LE = \"/</=\";"
L"\r\n" L"token GE = \"/>/=\";"
L"\r\n" L"token LT = \"/<\";"
L"\r\n" L"token GT = \"/>\";"
L"\r\n" L"token EQ = \"/=/=\";"
L"\r\n" L"token NE = \"/!/=\";"
L"\r\n" L"token ASSIGN = \"/=\";"
L"\r\n" L"token FAILED_THEN = \"/?/?\";"
L"\r\n" L"token QUESTION_MARK = \"/?\";"
L"\r\n" L"token SCOPE_DELIMITER = \"::\";"
L"\r\n" L"token COLON = \":\";"
L"\r\n" L"token SEMICOLON = \";\";"
L"\r\n" L"token COMMA = \",\";"
L"\r\n" L"token DOT = \".\";"
L"\r\n" L"token OPEN_ARRAY = \"/[\";"
L"\r\n" L"token CLOSE_ARRAY = \"/]\";"
L"\r\n" L"token OPEN_BRACE = \"/{\";"
L"\r\n" L"token CLOSE_BRACE = \"/}\";"
L"\r\n" L"token OPEN_BRACKET = \"/(\";"
L"\r\n" L"token CLOSE_BRACKET = \"/)\";"
L"\r\n" L""
L"\r\n" L"token TYPE_VOID = \"void\";"
L"\r\n" L"token TYPE_OBJECT = \"object\";"
L"\r\n" L"token TYPE_INTERFACE = \"interface\";"
L"\r\n" L"token TYPE_INT = \"int\";"
L"\r\n" L"token TYPE_UINT = \"uint\";"
L"\r\n" L"token TYPE_FLOAT = \"float\";"
L"\r\n" L"token TYPE_DOUBLE = \"double\";"
L"\r\n" L"token TYPE_STRING = \"string\";"
L"\r\n" L"token TYPE_CHAR = \"char\";"
L"\r\n" L"token TYPE_BOOL = \"bool\";"
L"\r\n" L""
L"\r\n" L"token KEYWORD_CONST = \"const\";"
L"\r\n" L"token KEYWORD_SHL = \"shl\";"
L"\r\n" L"token KEYWORD_SHR = \"shr\";"
L"\r\n" L"token KEYWORD_XOR = \"xor\";"
L"\r\n" L"token KEYWORD_AND = \"and\";"
L"\r\n" L"token KEYWORD_OR = \"or\";"
L"\r\n" L"token KEYWORD_NOT = \"not\";"
L"\r\n" L"token KEYWORD_NULL= \"null\";"
L"\r\n" L"token KEYWORD_TRUE= \"true\";"
L"\r\n" L"token KEYWORD_FALSE = \"false\";"
L"\r\n" L"token KEYWORD_LET = \"let\";"
L"\r\n" L"token KEYWORD_IN = \"in\";"
L"\r\n" L"token KEYWORD_RANGE = \"range\";"
L"\r\n" L"token KEYWORD_NEW = \"new\";"
L"\r\n" L"token KEYWORD_OF = \"of\";"
L"\r\n" L"token KEYWORD_AS = \"as\";"
L"\r\n" L"token KEYWORD_IS = \"is\";"
L"\r\n" L"token KEYWORD_CAST = \"cast\";"
L"\r\n" L"token KEYWORD_FUNC = \"func\";"
L"\r\n" L"token KEYWORD_TYPEOF = \"typeof\";"
L"\r\n" L"token KEYWORD_TYPE = \"type\";"
L"\r\n" L"token KEYWORD_BIND = \"bind\";"
L"\r\n" L"token KEYWORD_OBSERVE = \"observe\";"
L"\r\n" L"token KEYWORD_ON = \"on\";"
L"\r\n" L"token KEYWORD_ATTACH = \"attach\";"
L"\r\n" L"token KEYWORD_DETACH = \"detach\";"
L"\r\n" L"token KEYWORD_VAR = \"var\";"
L"\r\n" L"token KEYWORD_BREAK = \"break\";"
L"\r\n" L"token KEYWORD_CONTINUE = \"continue\";"
L"\r\n" L"token KEYWORD_RETURN = \"return\";"
L"\r\n" L"token KEYWORD_DELETE = \"delete\";"
L"\r\n" L"token KEYWORD_RAISE = \"raise\";"
L"\r\n" L"token KEYWORD_IF = \"if\";"
L"\r\n" L"token KEYWORD_ELSE = \"else\";"
L"\r\n" L"token KEYWORD_SWITCH = \"switch\";"
L"\r\n" L"token KEYWORD_CASE = \"case\";"
L"\r\n" L"token KEYWORD_DEFAULT = \"default\";"
L"\r\n" L"token KEYWORD_WHILE = \"while\";"
L"\r\n" L"token KEYWORD_FOR = \"for\";"
L"\r\n" L"token KEYWORD_REVERSED = \"reversed\";"
L"\r\n" L"token KEYWORD_TRY = \"try\";"
L"\r\n" L"token KEYWORD_CATCH = \"catch\";"
L"\r\n" L"token KEYWORD_FINALLY = \"finally\";"
L"\r\n" L"token KEYWORD_USING = \"using\";"
L"\r\n" L"token KEYWORD_NAMESPACE = \"namespace\";"
L"\r\n" L"token KEYWORD_MODULE = \"module\";"
L"\r\n" L"token KEYWORD_UNIT = \"unit\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z_]/w*\";"
L"\r\n" L"token ORDERED_NAME = \"/$[0-9]*\";"
L"\r\n" L"token FLOAT = \"/d+./d+\";"
L"\r\n" L"token INTEGER = \"/d+\";"
L"\r\n" L"token STRING = \"\'([^\'\\\\]|\\\\\\.)*\'|\"\"([^\"\"\\\\]|\\\\\\.)*\"\"\";"
L"\r\n" L"token FORMATSTRING = \"/$(\'([^\'\\\\]|\\\\\\.)*\'|\"\"([^\"\"\\\\]|\\\\\\.)*\"\")\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Type WorkflowType"
L"\r\n" L"\t= \"void\" as PredefinedType with {name=\"Void\"}"
L"\r\n" L"\t= \"object\" as PredefinedType with {name=\"Object\"}"
L"\r\n" L"\t= \"interface\" as PredefinedType with {name=\"Interface\"}"
L"\r\n" L"\t= \"int\" as PredefinedType with {name=\"Int\"}"
L"\r\n" L"\t= \"uint\" as PredefinedType with {name=\"UInt\"}"
L"\r\n" L"\t= \"float\" as PredefinedType with {name=\"Float\"}"
L"\r\n" L"\t= \"double\" as PredefinedType with {name=\"Double\"}"
L"\r\n" L"\t= \"string\" as PredefinedType with {name=\"String\"}"
L"\r\n" L"\t= \"char\" as PredefinedType with {name=\"Char\"}"
L"\r\n" L"\t= \"bool\" as PredefinedType with {name=\"Bool\"}"
L"\r\n" L"\t= NAME : name as ReferenceType"
L"\r\n" L"\t= \"func\" \"(\" [WorkflowType : arguments {\",\" WorkflowType : arguments}] \")\" \":\" WorkflowType : result as FunctionType"
L"\r\n" L"\t= WorkflowType : element \"*\" as RawPointerType"
L"\r\n" L"\t= WorkflowType : element \"^\" as SharedPointerType"
L"\r\n" L"\t= WorkflowType : element \"?\" as NullableType"
L"\r\n" L"\t= WorkflowType : element \"{\" \"}\" as EnumerableType"
L"\r\n" L"\t= WorkflowType : value \"[\" [WorkflowType : key] \"]\" as MapType with {writability=\"Writable\"}"
L"\r\n" L"\t= \"const\" WorkflowType : value \"[\" [WorkflowType : key] \"]\" as MapType with {writability=\"Readonly\"}"
L"\r\n" L"\t= WorkflowType : parent \"::\" NAME : name as ChildType"
L"\r\n" L"\t= \"::\" NAME : name as TopQualifiedType"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule LiteralExpression Literal"
L"\r\n" L"\t= \"null\" as LiteralExpression with {value = \"Null\"}"
L"\r\n" L"\t= \"true\" as LiteralExpression with {value = \"True\"}"
L"\r\n" L"\t= \"false\" as LiteralExpression with {value = \"False\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule IntegerExpression Integer"
L"\r\n" L"\t= INTEGER : value as IntegerExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule FloatingExpression FloatingPoint"
L"\r\n" L"\t= FLOAT : value as FloatingExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule StringExpression String"
L"\r\n" L"\t= STRING : value as StringExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule FormatExpression FormatString"
L"\r\n" L"\t= FORMATSTRING : value as FormatExpression"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ConstructorArgument CtorFragment"
L"\r\n" L"\t= WorkflowExpression : key [ \":\" WorkflowExpression : value] as ConstructorArgument"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule LetVariable LetVariableFragment"
L"\r\n" L"\t= NAME : name \"=\" WorkflowExpression : value as LetVariable"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression Exp0"
L"\r\n" L"\t= !Literal"
L"\r\n" L"\t= !Integer"
L"\r\n" L"\t= !FloatingPoint"
L"\r\n" L"\t= !String"
L"\r\n" L"\t= !FormatString"
L"\r\n" L"\t= NAME : name as ReferenceExpression"
L"\r\n" L"\t= ORDERED_NAME : name as OrderedNameExpression"
L"\r\n" L"\t= \"(\" !WorkflowExpression \")\""
L"\r\n" L"\t= \"[\" WorkflowExpression : body \"]\" as OrderedLambdaExpression"
L"\r\n" L"\t= Function : function as FunctionExpression"
L"\r\n" L"\t= \"let\" LetVariableFragment : variables {\",\" LetVariableFragment : variables} \"in\" \"(\" WorkflowExpression : expression \")\" as LetExpression"
L"\r\n" L"\t= \"+\" Exp0 : operand as UnaryExpression with {op = \"Positive\"}"
L"\r\n" L"\t= \"-\" Exp0 : operand as UnaryExpression with {op = \"Negative\"}"
L"\r\n" L"\t= \"not\" Exp0 : operand as UnaryExpression with {op = \"Not\"}"
L"\r\n" L"\t= \"range\""
L"\r\n" L"\t\t((\"(\" with {beginBoundary = \"Exclusive\"}) | (\"[\" with {beginBoundary = \"Inclusive\"}))"
L"\r\n" L"\t\tWorkflowExpression : begin \",\" WorkflowExpression : end"
L"\r\n" L"\t\t((\")\" with {endBoundary = \"Exclusive\"}) | (\"]\" with {endBoundary = \"Inclusive\"}))"
L"\r\n" L"\t\tas RangeExpression"
L"\r\n" L"\t= \"{\" {CtorFragment : arguments} \"}\" as ConstructorExpression"
L"\r\n" L"\t= \"new\" WorkflowType : type (\"(\" [WorkflowExpression : arguments {\",\" WorkflowExpression : arguments}] \")\" | \"{\" {Function : functions} \"}\") as NewTypeExpression"
L"\r\n" L"\t= \"bind\" \"(\" WorkflowExpression : expression \")\" as BindExpression"
L"\r\n" L"\t= Exp0 : parent \".\" \"observe\" \"(\" WorkflowExpression : expression [\"on\" WorkflowExpression : events {\",\" WorkflowExpression : events}]\")\" as ObserveExpression with {observeType = \"SimpleObserve\"}"
L"\r\n" L"\t= Exp0 : parent \".\" \"observe\" \"as\" NAME : name \"(\" WorkflowExpression : expression [\"on\" WorkflowExpression : events {\",\" WorkflowExpression : events}]\")\" as ObserveExpression with {observeType = \"ExtendedObserve\"}"
L"\r\n" L"\t= Exp0 : function \"(\" [WorkflowExpression : arguments {\",\" WorkflowExpression : arguments}] \")\" as CallExpression"
L"\r\n" L"\t= Exp0 : parent \".\" NAME : name as MemberExpression"
L"\r\n" L"\t= Exp0 : parent \"::\" NAME : name as ChildExpression"
L"\r\n" L"\t= Exp0 : first \"[\" WorkflowExpression : second \"]\" as BinaryExpression with {op = \"Index\"}"
L"\r\n" L"\t= Exp0 : element"
L"\r\n" L"\t\t((\"in\" with {test=\"In\"}) | (\"not\" \"in\" with {test=\"NotIn\"}))"
L"\r\n" L"\t\tWorkflowExpression : collection as SetTestingExpression"
L"\r\n" L"\t= Exp0 : expression \"of\" WorkflowType : type as InferExpression"
L"\r\n" L"\t= Exp0 : expression"
L"\r\n" L"\t\t("
L"\r\n" L"\t\t\t("
L"\r\n" L"\t\t\t\t("
L"\r\n" L"\t\t\t\t\t(\"is\" with {test=\"IsType\"})"
L"\r\n" L"\t\t\t\t\t| (\"is\" \"not\" with {test=\"IsNotType\"})"
L"\r\n" L"\t\t\t\t) WorkflowType : type as TypeTestingExpression"
L"\r\n" L"\t\t\t)"
L"\r\n" L"\t\t\t| (\"is\" \"null\" as TypeTestingExpression with {test=\"IsNull\"})"
L"\r\n" L"\t\t\t| (\"is\" \"not\" \"null\" as TypeTestingExpression with {test=\"IsNotNull\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t= Exp0 : expression \"as\" WorkflowType : type as TypeCastingExpression with {strategy = \"Weak\"}"
L"\r\n" L"\t= \"cast\" WorkflowType : type Exp0 : expression as TypeCastingExpression with {strategy = \"Strong\"}"
L"\r\n" L"\t= \"typeof\" \"(\" WorkflowType : type \")\" as TypeOfTypeExpression"
L"\r\n" L"\t= \"type\" \"(\" WorkflowExpression : expression \")\" as TypeOfExpressionExpression"
L"\r\n" L"\t= \"attach\" \"(\" WorkflowExpression : event \",\" WorkflowExpression : function \")\" as AttachEventExpression"
L"\r\n" L"\t= \"detach\" \"(\" WorkflowExpression : handler \")\" as DetachEventExpression"
L"\r\n" L"\t= \"::\" NAME : name as TopQualifiedExpression"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression Exp1"
L"\r\n" L"\t= !Exp0"
L"\r\n" L"\t= Exp1 : first \"^\" Exp0 : second as BinaryExpression with {op = \"Exp\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp2"
L"\r\n" L"\t= !Exp1"
L"\r\n" L"\t= Exp2 : first \"*\" Exp1 : second as BinaryExpression with {op = \"Mul\"}"
L"\r\n" L"\t= Exp2 : first \"/\" Exp1 : second as BinaryExpression with {op = \"Div\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp3"
L"\r\n" L"\t= !Exp2"
L"\r\n" L"\t= Exp3 : first \"+\" Exp2 : second as BinaryExpression with {op = \"Add\"}"
L"\r\n" L"\t= Exp3 : first \"-\" Exp2 : second as BinaryExpression with {op = \"Sub\"}"
L"\r\n" L"\t= Exp3 : first \"&\" Exp2 : second as BinaryExpression with {op = \"Concat\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp4"
L"\r\n" L"\t= !Exp3"
L"\r\n" L"\t= Exp4 : first \"shl\" Exp3 : second as BinaryExpression with {op = \"Shl\"}"
L"\r\n" L"\t= Exp4 : first \"shr\" Exp3 : second as BinaryExpression with {op = \"Shr\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp5"
L"\r\n" L"\t= !Exp4"
L"\r\n" L"\t= Exp5 : first \"<\" Exp4 : second as BinaryExpression with {op = \"LT\"}"
L"\r\n" L"\t= Exp5 : first \">\" Exp4 : second as BinaryExpression with {op = \"GT\"}"
L"\r\n" L"\t= Exp5 : first \"<=\" Exp4 : second as BinaryExpression with {op = \"LE\"}"
L"\r\n" L"\t= Exp5 : first \">=\" Exp4 : second as BinaryExpression with {op = \"GE\"}"
L"\r\n" L"\t= Exp5 : first \"==\" Exp4 : second as BinaryExpression with {op = \"EQ\"}"
L"\r\n" L"\t= Exp5 : first \"!=\" Exp4 : second as BinaryExpression with {op = \"NE\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp6"
L"\r\n" L"\t= !Exp5"
L"\r\n" L"\t= Exp6 : first \"xor\" Exp5 : second as BinaryExpression with {op = \"Xor\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp7"
L"\r\n" L"\t= !Exp6"
L"\r\n" L"\t= Exp7 : first \"and\" Exp6 : second as BinaryExpression with {op = \"And\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp8"
L"\r\n" L"\t= !Exp7"
L"\r\n" L"\t= Exp8 : first \"or\" Exp7 : second as BinaryExpression with {op = \"Or\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp9"
L"\r\n" L"\t= !Exp8"
L"\r\n" L"\t= Exp9 : first \"??\" Exp8 : second as BinaryExpression with {op = \"FailedThen\"}"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp10"
L"\r\n" L"\t= !Exp9"
L"\r\n" L"\t= Exp9 : condition \"?\" Exp10 : trueBranch \":\" Exp10 : falseBranch as IfExpression"
L"\r\n" L"\t;"
L"\r\n" L"rule Expression Exp11"
L"\r\n" L"\t= !Exp10"
L"\r\n" L"\t= Exp10 : first \"=\" Exp11 : second as BinaryExpression with {op = \"Assign\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Expression WorkflowExpression"
L"\r\n" L"\t= !Exp11"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule SwitchCase SwitchCaseFragment"
L"\r\n" L"\t= \"case\" WorkflowExpression : expression \":\" Block : statement as SwitchCase"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Statement Block"
L"\r\n" L"\t= \"{\" {WorkflowStatement : statements} \"}\" as BlockStatement"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Statement WorkflowStatement"
L"\r\n" L"\t= !Block"
L"\r\n" L"\t= Variable : variable as VariableStatement"
L"\r\n" L"\t= \"break\" \";\" as BreakStatement"
L"\r\n" L"\t= \"continue\" \";\" as ContinueStatement"
L"\r\n" L"\t= \"return\" [WorkflowExpression : expression] \";\" as ReturnStatement"
L"\r\n" L"\t= \"delete\" WorkflowExpression : expression \";\" as DeleteStatement"
L"\r\n" L"\t= \"raise\" [WorkflowExpression : expression] \";\" as RaiseExceptionStatement"
L"\r\n" L"\t= \"if\" \"(\" [\"var\" NAME : name \":\" WorkflowType : type \"=\"] WorkflowExpression : expression \")\" Block : trueBranch [\"else\" Block : falseBranch] as IfStatement"
L"\r\n" L"\t= \"switch\" \"(\" WorkflowExpression : expression \")\" \"{\" {SwitchCaseFragment : caseBranches} [\"default\" \":\" Block : defaultBranch] \"}\" as SwitchStatement"
L"\r\n" L"\t= \"while\" \"(\" WorkflowExpression : condition \")\" Block : statement as WhileStatement"
L"\r\n" L"\t= \"for\" \"(\" NAME : name "
L"\r\n" L"\t\t((\"in\" with {direction=\"Normal\"}) | (\"in\" \"reversed\" with {direction=\"Reversed\"}))"
L"\r\n" L"\t\tWorkflowExpression : collection \")\" Block : statement as ForEachStatement"
L"\r\n" L"\t= \"try\" Block : protectedStatement [\"catch\" \"(\" NAME : name \")\" Block : catchStatement] [\"finally\" Block : finallyStatement] as TryStatement"
L"\r\n" L"\t= WorkflowExpression : expression \";\" as ExpressionStatement"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule NamespaceDeclaration Namespace"
L"\r\n" L"\t= \"namespace\" NAME : name \"{\" {WorkflowDeclaration : declarations} \"}\" as NamespaceDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule FunctionArgument FunctionArgumentFragment"
L"\r\n" L"\t= NAME : name \":\" WorkflowType : type as FunctionArgument"
L"\r\n" L"\t;"
L"\r\n" L"rule FunctionDeclaration Function"
L"\r\n" L"\t= \"func\" "
L"\r\n" L"\t\t("
L"\r\n" L"\t\t\t(NAME : name \"(\" with {anonymity=\"Named\"})"
L"\r\n" L"\t\t\t| (\"(\" with {anonymity=\"Anonymous\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t\t[FunctionArgumentFragment : arguments {\",\" FunctionArgumentFragment : arguments}] \")\" \":\" WorkflowType : returnType Block : statement as FunctionDeclaration"
L"\r\n" L"\t;"
L"\r\n" L"rule VariableDeclaration Variable"
L"\r\n" L"\t= \"var\" NAME : name [\":\" WorkflowType : type] \"=\" WorkflowExpression : expression \";\" as VariableDeclaration"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Declaration WorkflowDeclaration"
L"\r\n" L"\t= !Namespace"
L"\r\n" L"\t= !Function"
L"\r\n" L"\t= !Variable"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule ModuleUsingFragment UsingFragment"
L"\r\n" L"\t= NAME : name as ModuleUsingNameFragment"
L"\r\n" L"\t= \"*\" as ModuleUsingWildCardFragment"
L"\r\n" L"\t;"
L"\r\n" L"rule ModuleUsingItem UsingItem"
L"\r\n" L"\t= UsingFragment : fragments {UsingFragment : fragments} as ModuleUsingItem"
L"\r\n" L"\t;"
L"\r\n" L"rule ModuleUsingPath UsingPath"
L"\r\n" L"\t= \"using\" UsingItem : items {\"::\" UsingItem : items} \";\" as ModuleUsingPath"
L"\r\n" L"\t;"
L"\r\n" L"rule Module WorkflowModule"
L"\r\n" L"\t= ("
L"\r\n" L"\t\t(\"module\" with {moduleType=\"Module\"})"
L"\r\n" L"\t\t| (\"unit\" with {moduleType=\"Unit\"})"
L"\r\n" L"\t\t) NAME : name \";\" {UsingPath : paths} {WorkflowDeclaration : declarations} as Module"
L"\r\n" L"\t;"
;

		vl::WString WfGetParserTextBuffer()
		{
			return parserTextBuffer;
		}

/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

		extern void UnescapeFormatString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern void UnescapeString(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

		class WfTreeConverter : public vl::parsing::ParsingTreeConverter
		{
		public:
			using vl::parsing::ParsingTreeConverter::SetMember;

			bool SetMember(WfPredefinedTypeName& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Void") { member=WfPredefinedTypeName::Void; return true; }
					else if(token->GetValue()==L"Object") { member=WfPredefinedTypeName::Object; return true; }
					else if(token->GetValue()==L"Interface") { member=WfPredefinedTypeName::Interface; return true; }
					else if(token->GetValue()==L"Int") { member=WfPredefinedTypeName::Int; return true; }
					else if(token->GetValue()==L"UInt") { member=WfPredefinedTypeName::UInt; return true; }
					else if(token->GetValue()==L"Float") { member=WfPredefinedTypeName::Float; return true; }
					else if(token->GetValue()==L"Double") { member=WfPredefinedTypeName::Double; return true; }
					else if(token->GetValue()==L"String") { member=WfPredefinedTypeName::String; return true; }
					else if(token->GetValue()==L"Char") { member=WfPredefinedTypeName::Char; return true; }
					else if(token->GetValue()==L"Bool") { member=WfPredefinedTypeName::Bool; return true; }
					else { member=WfPredefinedTypeName::Void; return false; }
				}
				member=WfPredefinedTypeName::Void;
				return false;
			}

			bool SetMember(WfMapWritability& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Readonly") { member=WfMapWritability::Readonly; return true; }
					else if(token->GetValue()==L"Writable") { member=WfMapWritability::Writable; return true; }
					else { member=WfMapWritability::Readonly; return false; }
				}
				member=WfMapWritability::Readonly;
				return false;
			}

			bool SetMember(WfLiteralValue& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Null") { member=WfLiteralValue::Null; return true; }
					else if(token->GetValue()==L"True") { member=WfLiteralValue::True; return true; }
					else if(token->GetValue()==L"False") { member=WfLiteralValue::False; return true; }
					else { member=WfLiteralValue::Null; return false; }
				}
				member=WfLiteralValue::Null;
				return false;
			}

			bool SetMember(WfUnaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Positive") { member=WfUnaryOperator::Positive; return true; }
					else if(token->GetValue()==L"Negative") { member=WfUnaryOperator::Negative; return true; }
					else if(token->GetValue()==L"Not") { member=WfUnaryOperator::Not; return true; }
					else { member=WfUnaryOperator::Positive; return false; }
				}
				member=WfUnaryOperator::Positive;
				return false;
			}

			bool SetMember(WfBinaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Assign") { member=WfBinaryOperator::Assign; return true; }
					else if(token->GetValue()==L"Index") { member=WfBinaryOperator::Index; return true; }
					else if(token->GetValue()==L"Concat") { member=WfBinaryOperator::Concat; return true; }
					else if(token->GetValue()==L"FailedThen") { member=WfBinaryOperator::FailedThen; return true; }
					else if(token->GetValue()==L"Exp") { member=WfBinaryOperator::Exp; return true; }
					else if(token->GetValue()==L"Add") { member=WfBinaryOperator::Add; return true; }
					else if(token->GetValue()==L"Sub") { member=WfBinaryOperator::Sub; return true; }
					else if(token->GetValue()==L"Mul") { member=WfBinaryOperator::Mul; return true; }
					else if(token->GetValue()==L"Div") { member=WfBinaryOperator::Div; return true; }
					else if(token->GetValue()==L"Shl") { member=WfBinaryOperator::Shl; return true; }
					else if(token->GetValue()==L"Shr") { member=WfBinaryOperator::Shr; return true; }
					else if(token->GetValue()==L"LT") { member=WfBinaryOperator::LT; return true; }
					else if(token->GetValue()==L"GT") { member=WfBinaryOperator::GT; return true; }
					else if(token->GetValue()==L"LE") { member=WfBinaryOperator::LE; return true; }
					else if(token->GetValue()==L"GE") { member=WfBinaryOperator::GE; return true; }
					else if(token->GetValue()==L"EQ") { member=WfBinaryOperator::EQ; return true; }
					else if(token->GetValue()==L"NE") { member=WfBinaryOperator::NE; return true; }
					else if(token->GetValue()==L"Xor") { member=WfBinaryOperator::Xor; return true; }
					else if(token->GetValue()==L"And") { member=WfBinaryOperator::And; return true; }
					else if(token->GetValue()==L"Or") { member=WfBinaryOperator::Or; return true; }
					else { member=WfBinaryOperator::Assign; return false; }
				}
				member=WfBinaryOperator::Assign;
				return false;
			}

			bool SetMember(WfRangeBoundary& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Inclusive") { member=WfRangeBoundary::Inclusive; return true; }
					else if(token->GetValue()==L"Exclusive") { member=WfRangeBoundary::Exclusive; return true; }
					else { member=WfRangeBoundary::Inclusive; return false; }
				}
				member=WfRangeBoundary::Inclusive;
				return false;
			}

			bool SetMember(WfSetTesting& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"In") { member=WfSetTesting::In; return true; }
					else if(token->GetValue()==L"NotIn") { member=WfSetTesting::NotIn; return true; }
					else { member=WfSetTesting::In; return false; }
				}
				member=WfSetTesting::In;
				return false;
			}

			bool SetMember(WfTypeCastingStrategy& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Strong") { member=WfTypeCastingStrategy::Strong; return true; }
					else if(token->GetValue()==L"Weak") { member=WfTypeCastingStrategy::Weak; return true; }
					else { member=WfTypeCastingStrategy::Strong; return false; }
				}
				member=WfTypeCastingStrategy::Strong;
				return false;
			}

			bool SetMember(WfTypeTesting& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"IsType") { member=WfTypeTesting::IsType; return true; }
					else if(token->GetValue()==L"IsNotType") { member=WfTypeTesting::IsNotType; return true; }
					else if(token->GetValue()==L"IsNull") { member=WfTypeTesting::IsNull; return true; }
					else if(token->GetValue()==L"IsNotNull") { member=WfTypeTesting::IsNotNull; return true; }
					else { member=WfTypeTesting::IsType; return false; }
				}
				member=WfTypeTesting::IsType;
				return false;
			}

			bool SetMember(WfObserveType& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"SimpleObserve") { member=WfObserveType::SimpleObserve; return true; }
					else if(token->GetValue()==L"ExtendedObserve") { member=WfObserveType::ExtendedObserve; return true; }
					else { member=WfObserveType::SimpleObserve; return false; }
				}
				member=WfObserveType::SimpleObserve;
				return false;
			}

			bool SetMember(WfForEachDirection& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Normal") { member=WfForEachDirection::Normal; return true; }
					else if(token->GetValue()==L"Reversed") { member=WfForEachDirection::Reversed; return true; }
					else { member=WfForEachDirection::Normal; return false; }
				}
				member=WfForEachDirection::Normal;
				return false;
			}

			bool SetMember(WfFunctionAnonymity& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Named") { member=WfFunctionAnonymity::Named; return true; }
					else if(token->GetValue()==L"Anonymous") { member=WfFunctionAnonymity::Anonymous; return true; }
					else { member=WfFunctionAnonymity::Named; return false; }
				}
				member=WfFunctionAnonymity::Named;
				return false;
			}

			bool SetMember(WfModuleType& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Module") { member=WfModuleType::Module; return true; }
					else if(token->GetValue()==L"Unit") { member=WfModuleType::Unit; return true; }
					else { member=WfModuleType::Module; return false; }
				}
				member=WfModuleType::Module;
				return false;
			}

			void Fill(vl::Ptr<WfType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfPredefinedType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfTopQualifiedType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfReferenceType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfRawPointerType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfSharedPointerType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfNullableType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfEnumerableType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
			}

			void Fill(vl::Ptr<WfMapType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->writability, obj->GetMember(L"writability"), tokens);
				SetMember(tree->key, obj->GetMember(L"key"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->result, obj->GetMember(L"result"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfChildType> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfTopQualifiedExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfReferenceExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfOrderedNameExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfOrderedLambdaExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->body, obj->GetMember(L"body"), tokens);
			}

			void Fill(vl::Ptr<WfMemberExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfChildExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfLiteralExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfFloatingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfIntegerExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfStringExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
				{
					UnescapeString(tree->value, tokens);
				}
			}

			void Fill(vl::Ptr<WfFormatExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
				{
					UnescapeFormatString(tree->value, tokens);
				}
				SetMember(tree->expandedExpression, obj->GetMember(L"expandedExpression"), tokens);
			}

			void Fill(vl::Ptr<WfUnaryExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
				SetMember(tree->operand, obj->GetMember(L"operand"), tokens);
			}

			void Fill(vl::Ptr<WfBinaryExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
				SetMember(tree->first, obj->GetMember(L"first"), tokens);
				SetMember(tree->second, obj->GetMember(L"second"), tokens);
			}

			void Fill(vl::Ptr<WfLetVariable> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfLetExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->variables, obj->GetMember(L"variables"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfIfExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->condition, obj->GetMember(L"condition"), tokens);
				SetMember(tree->trueBranch, obj->GetMember(L"trueBranch"), tokens);
				SetMember(tree->falseBranch, obj->GetMember(L"falseBranch"), tokens);
			}

			void Fill(vl::Ptr<WfRangeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->begin, obj->GetMember(L"begin"), tokens);
				SetMember(tree->beginBoundary, obj->GetMember(L"beginBoundary"), tokens);
				SetMember(tree->end, obj->GetMember(L"end"), tokens);
				SetMember(tree->endBoundary, obj->GetMember(L"endBoundary"), tokens);
			}

			void Fill(vl::Ptr<WfSetTestingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->test, obj->GetMember(L"test"), tokens);
				SetMember(tree->element, obj->GetMember(L"element"), tokens);
				SetMember(tree->collection, obj->GetMember(L"collection"), tokens);
			}

			void Fill(vl::Ptr<WfConstructorArgument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->key, obj->GetMember(L"key"), tokens);
				SetMember(tree->value, obj->GetMember(L"value"), tokens);
			}

			void Fill(vl::Ptr<WfConstructorExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfInferExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeCastingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->strategy, obj->GetMember(L"strategy"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeTestingExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->test, obj->GetMember(L"test"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeOfTypeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfTypeOfExpressionExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfAttachEventExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->event, obj->GetMember(L"event"), tokens);
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
			}

			void Fill(vl::Ptr<WfDetachEventExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->handler, obj->GetMember(L"handler"), tokens);
			}

			void Fill(vl::Ptr<WfBindExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfObserveExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->observeType, obj->GetMember(L"observeType"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->events, obj->GetMember(L"events"), tokens);
			}

			void Fill(vl::Ptr<WfCallExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
			}

			void Fill(vl::Ptr<WfStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfBreakStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfContinueStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfReturnStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfDeleteStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfRaiseExceptionStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfIfStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->trueBranch, obj->GetMember(L"trueBranch"), tokens);
				SetMember(tree->falseBranch, obj->GetMember(L"falseBranch"), tokens);
			}

			void Fill(vl::Ptr<WfSwitchCase> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfSwitchStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
				SetMember(tree->caseBranches, obj->GetMember(L"caseBranches"), tokens);
				SetMember(tree->defaultBranch, obj->GetMember(L"defaultBranch"), tokens);
			}

			void Fill(vl::Ptr<WfWhileStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->condition, obj->GetMember(L"condition"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfForEachStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->direction, obj->GetMember(L"direction"), tokens);
				SetMember(tree->collection, obj->GetMember(L"collection"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfTryStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->protectedStatement, obj->GetMember(L"protectedStatement"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->catchStatement, obj->GetMember(L"catchStatement"), tokens);
				SetMember(tree->finallyStatement, obj->GetMember(L"finallyStatement"), tokens);
			}

			void Fill(vl::Ptr<WfBlockStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->statements, obj->GetMember(L"statements"), tokens);
			}

			void Fill(vl::Ptr<WfExpressionStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfNamespaceDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->declarations, obj->GetMember(L"declarations"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionArgument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->anonymity, obj->GetMember(L"anonymity"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
				SetMember(tree->returnType, obj->GetMember(L"returnType"), tokens);
				SetMember(tree->statement, obj->GetMember(L"statement"), tokens);
			}

			void Fill(vl::Ptr<WfFunctionExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->function, obj->GetMember(L"function"), tokens);
			}

			void Fill(vl::Ptr<WfVariableDeclaration> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->expression, obj->GetMember(L"expression"), tokens);
			}

			void Fill(vl::Ptr<WfVariableStatement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->variable, obj->GetMember(L"variable"), tokens);
			}

			void Fill(vl::Ptr<WfNewTypeExpression> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->type, obj->GetMember(L"type"), tokens);
				SetMember(tree->arguments, obj->GetMember(L"arguments"), tokens);
				SetMember(tree->functions, obj->GetMember(L"functions"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfModuleUsingNameFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingWildCardFragment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<WfModuleUsingItem> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->fragments, obj->GetMember(L"fragments"), tokens);
			}

			void Fill(vl::Ptr<WfModuleUsingPath> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->items, obj->GetMember(L"items"), tokens);
			}

			void Fill(vl::Ptr<WfModule> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->moduleType, obj->GetMember(L"moduleType"), tokens);
				SetMember(tree->name, obj->GetMember(L"name"), tokens);
				SetMember(tree->paths, obj->GetMember(L"paths"), tokens);
				SetMember(tree->declarations, obj->GetMember(L"declarations"), tokens);
			}

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
			{
				if(obj->GetType()==L"PredefinedType")
				{
					vl::Ptr<WfPredefinedType> tree = new WfPredefinedType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TopQualifiedType")
				{
					vl::Ptr<WfTopQualifiedType> tree = new WfTopQualifiedType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReferenceType")
				{
					vl::Ptr<WfReferenceType> tree = new WfReferenceType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RawPointerType")
				{
					vl::Ptr<WfRawPointerType> tree = new WfRawPointerType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SharedPointerType")
				{
					vl::Ptr<WfSharedPointerType> tree = new WfSharedPointerType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NullableType")
				{
					vl::Ptr<WfNullableType> tree = new WfNullableType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"EnumerableType")
				{
					vl::Ptr<WfEnumerableType> tree = new WfEnumerableType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"MapType")
				{
					vl::Ptr<WfMapType> tree = new WfMapType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionType")
				{
					vl::Ptr<WfFunctionType> tree = new WfFunctionType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ChildType")
				{
					vl::Ptr<WfChildType> tree = new WfChildType;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfType>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TopQualifiedExpression")
				{
					vl::Ptr<WfTopQualifiedExpression> tree = new WfTopQualifiedExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReferenceExpression")
				{
					vl::Ptr<WfReferenceExpression> tree = new WfReferenceExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"OrderedNameExpression")
				{
					vl::Ptr<WfOrderedNameExpression> tree = new WfOrderedNameExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"OrderedLambdaExpression")
				{
					vl::Ptr<WfOrderedLambdaExpression> tree = new WfOrderedLambdaExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"MemberExpression")
				{
					vl::Ptr<WfMemberExpression> tree = new WfMemberExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ChildExpression")
				{
					vl::Ptr<WfChildExpression> tree = new WfChildExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LiteralExpression")
				{
					vl::Ptr<WfLiteralExpression> tree = new WfLiteralExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FloatingExpression")
				{
					vl::Ptr<WfFloatingExpression> tree = new WfFloatingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IntegerExpression")
				{
					vl::Ptr<WfIntegerExpression> tree = new WfIntegerExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"StringExpression")
				{
					vl::Ptr<WfStringExpression> tree = new WfStringExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FormatExpression")
				{
					vl::Ptr<WfFormatExpression> tree = new WfFormatExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"UnaryExpression")
				{
					vl::Ptr<WfUnaryExpression> tree = new WfUnaryExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BinaryExpression")
				{
					vl::Ptr<WfBinaryExpression> tree = new WfBinaryExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LetVariable")
				{
					vl::Ptr<WfLetVariable> tree = new WfLetVariable;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"LetExpression")
				{
					vl::Ptr<WfLetExpression> tree = new WfLetExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IfExpression")
				{
					vl::Ptr<WfIfExpression> tree = new WfIfExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RangeExpression")
				{
					vl::Ptr<WfRangeExpression> tree = new WfRangeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SetTestingExpression")
				{
					vl::Ptr<WfSetTestingExpression> tree = new WfSetTestingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ConstructorArgument")
				{
					vl::Ptr<WfConstructorArgument> tree = new WfConstructorArgument;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ConstructorExpression")
				{
					vl::Ptr<WfConstructorExpression> tree = new WfConstructorExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"InferExpression")
				{
					vl::Ptr<WfInferExpression> tree = new WfInferExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeCastingExpression")
				{
					vl::Ptr<WfTypeCastingExpression> tree = new WfTypeCastingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeTestingExpression")
				{
					vl::Ptr<WfTypeTestingExpression> tree = new WfTypeTestingExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeOfTypeExpression")
				{
					vl::Ptr<WfTypeOfTypeExpression> tree = new WfTypeOfTypeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TypeOfExpressionExpression")
				{
					vl::Ptr<WfTypeOfExpressionExpression> tree = new WfTypeOfExpressionExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"AttachEventExpression")
				{
					vl::Ptr<WfAttachEventExpression> tree = new WfAttachEventExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"DetachEventExpression")
				{
					vl::Ptr<WfDetachEventExpression> tree = new WfDetachEventExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BindExpression")
				{
					vl::Ptr<WfBindExpression> tree = new WfBindExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ObserveExpression")
				{
					vl::Ptr<WfObserveExpression> tree = new WfObserveExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"CallExpression")
				{
					vl::Ptr<WfCallExpression> tree = new WfCallExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BreakStatement")
				{
					vl::Ptr<WfBreakStatement> tree = new WfBreakStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ContinueStatement")
				{
					vl::Ptr<WfContinueStatement> tree = new WfContinueStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ReturnStatement")
				{
					vl::Ptr<WfReturnStatement> tree = new WfReturnStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"DeleteStatement")
				{
					vl::Ptr<WfDeleteStatement> tree = new WfDeleteStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"RaiseExceptionStatement")
				{
					vl::Ptr<WfRaiseExceptionStatement> tree = new WfRaiseExceptionStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"IfStatement")
				{
					vl::Ptr<WfIfStatement> tree = new WfIfStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SwitchCase")
				{
					vl::Ptr<WfSwitchCase> tree = new WfSwitchCase;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SwitchStatement")
				{
					vl::Ptr<WfSwitchStatement> tree = new WfSwitchStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"WhileStatement")
				{
					vl::Ptr<WfWhileStatement> tree = new WfWhileStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ForEachStatement")
				{
					vl::Ptr<WfForEachStatement> tree = new WfForEachStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"TryStatement")
				{
					vl::Ptr<WfTryStatement> tree = new WfTryStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"BlockStatement")
				{
					vl::Ptr<WfBlockStatement> tree = new WfBlockStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ExpressionStatement")
				{
					vl::Ptr<WfExpressionStatement> tree = new WfExpressionStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NamespaceDeclaration")
				{
					vl::Ptr<WfNamespaceDeclaration> tree = new WfNamespaceDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionArgument")
				{
					vl::Ptr<WfFunctionArgument> tree = new WfFunctionArgument;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionDeclaration")
				{
					vl::Ptr<WfFunctionDeclaration> tree = new WfFunctionDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"FunctionExpression")
				{
					vl::Ptr<WfFunctionExpression> tree = new WfFunctionExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"VariableDeclaration")
				{
					vl::Ptr<WfVariableDeclaration> tree = new WfVariableDeclaration;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfDeclaration>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"VariableStatement")
				{
					vl::Ptr<WfVariableStatement> tree = new WfVariableStatement;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfStatement>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"NewTypeExpression")
				{
					vl::Ptr<WfNewTypeExpression> tree = new WfNewTypeExpression;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfExpression>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingNameFragment")
				{
					vl::Ptr<WfModuleUsingNameFragment> tree = new WfModuleUsingNameFragment;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfModuleUsingFragment>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingWildCardFragment")
				{
					vl::Ptr<WfModuleUsingWildCardFragment> tree = new WfModuleUsingWildCardFragment;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<WfModuleUsingFragment>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingItem")
				{
					vl::Ptr<WfModuleUsingItem> tree = new WfModuleUsingItem;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"ModuleUsingPath")
				{
					vl::Ptr<WfModuleUsingPath> tree = new WfModuleUsingPath;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"Module")
				{
					vl::Ptr<WfModule> tree = new WfModule;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					return tree;
				}
				else 
					return 0;
			}
		};

		vl::Ptr<vl::parsing::ParsingTreeCustomBase> WfConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			WfTreeConverter converter;
			vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
			converter.SetMember(tree, node, tokens);
			return tree;
		}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

		vl::Ptr<WfPredefinedType> WfPredefinedType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfPredefinedType>();
		}

		vl::Ptr<WfTopQualifiedType> WfTopQualifiedType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTopQualifiedType>();
		}

		vl::Ptr<WfReferenceType> WfReferenceType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReferenceType>();
		}

		vl::Ptr<WfRawPointerType> WfRawPointerType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRawPointerType>();
		}

		vl::Ptr<WfSharedPointerType> WfSharedPointerType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSharedPointerType>();
		}

		vl::Ptr<WfNullableType> WfNullableType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNullableType>();
		}

		vl::Ptr<WfEnumerableType> WfEnumerableType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfEnumerableType>();
		}

		vl::Ptr<WfMapType> WfMapType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfMapType>();
		}

		vl::Ptr<WfFunctionType> WfFunctionType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionType>();
		}

		vl::Ptr<WfChildType> WfChildType::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfChildType>();
		}

		vl::Ptr<WfTopQualifiedExpression> WfTopQualifiedExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTopQualifiedExpression>();
		}

		vl::Ptr<WfReferenceExpression> WfReferenceExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReferenceExpression>();
		}

		vl::Ptr<WfOrderedNameExpression> WfOrderedNameExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfOrderedNameExpression>();
		}

		vl::Ptr<WfOrderedLambdaExpression> WfOrderedLambdaExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfOrderedLambdaExpression>();
		}

		vl::Ptr<WfMemberExpression> WfMemberExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfMemberExpression>();
		}

		vl::Ptr<WfChildExpression> WfChildExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfChildExpression>();
		}

		vl::Ptr<WfLiteralExpression> WfLiteralExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLiteralExpression>();
		}

		vl::Ptr<WfFloatingExpression> WfFloatingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFloatingExpression>();
		}

		vl::Ptr<WfIntegerExpression> WfIntegerExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIntegerExpression>();
		}

		vl::Ptr<WfStringExpression> WfStringExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfStringExpression>();
		}

		vl::Ptr<WfFormatExpression> WfFormatExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFormatExpression>();
		}

		vl::Ptr<WfUnaryExpression> WfUnaryExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfUnaryExpression>();
		}

		vl::Ptr<WfBinaryExpression> WfBinaryExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBinaryExpression>();
		}

		vl::Ptr<WfLetVariable> WfLetVariable::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLetVariable>();
		}

		vl::Ptr<WfLetExpression> WfLetExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfLetExpression>();
		}

		vl::Ptr<WfIfExpression> WfIfExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIfExpression>();
		}

		vl::Ptr<WfRangeExpression> WfRangeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRangeExpression>();
		}

		vl::Ptr<WfSetTestingExpression> WfSetTestingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSetTestingExpression>();
		}

		vl::Ptr<WfConstructorArgument> WfConstructorArgument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfConstructorArgument>();
		}

		vl::Ptr<WfConstructorExpression> WfConstructorExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfConstructorExpression>();
		}

		vl::Ptr<WfInferExpression> WfInferExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfInferExpression>();
		}

		vl::Ptr<WfTypeCastingExpression> WfTypeCastingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeCastingExpression>();
		}

		vl::Ptr<WfTypeTestingExpression> WfTypeTestingExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeTestingExpression>();
		}

		vl::Ptr<WfTypeOfTypeExpression> WfTypeOfTypeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeOfTypeExpression>();
		}

		vl::Ptr<WfTypeOfExpressionExpression> WfTypeOfExpressionExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTypeOfExpressionExpression>();
		}

		vl::Ptr<WfAttachEventExpression> WfAttachEventExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfAttachEventExpression>();
		}

		vl::Ptr<WfDetachEventExpression> WfDetachEventExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfDetachEventExpression>();
		}

		vl::Ptr<WfBindExpression> WfBindExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBindExpression>();
		}

		vl::Ptr<WfObserveExpression> WfObserveExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfObserveExpression>();
		}

		vl::Ptr<WfCallExpression> WfCallExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfCallExpression>();
		}

		vl::Ptr<WfBreakStatement> WfBreakStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBreakStatement>();
		}

		vl::Ptr<WfContinueStatement> WfContinueStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfContinueStatement>();
		}

		vl::Ptr<WfReturnStatement> WfReturnStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfReturnStatement>();
		}

		vl::Ptr<WfDeleteStatement> WfDeleteStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfDeleteStatement>();
		}

		vl::Ptr<WfRaiseExceptionStatement> WfRaiseExceptionStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfRaiseExceptionStatement>();
		}

		vl::Ptr<WfIfStatement> WfIfStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfIfStatement>();
		}

		vl::Ptr<WfSwitchCase> WfSwitchCase::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSwitchCase>();
		}

		vl::Ptr<WfSwitchStatement> WfSwitchStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfSwitchStatement>();
		}

		vl::Ptr<WfWhileStatement> WfWhileStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfWhileStatement>();
		}

		vl::Ptr<WfForEachStatement> WfForEachStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfForEachStatement>();
		}

		vl::Ptr<WfTryStatement> WfTryStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfTryStatement>();
		}

		vl::Ptr<WfBlockStatement> WfBlockStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfBlockStatement>();
		}

		vl::Ptr<WfExpressionStatement> WfExpressionStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfExpressionStatement>();
		}

		vl::Ptr<WfNamespaceDeclaration> WfNamespaceDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNamespaceDeclaration>();
		}

		vl::Ptr<WfFunctionArgument> WfFunctionArgument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionArgument>();
		}

		vl::Ptr<WfFunctionDeclaration> WfFunctionDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionDeclaration>();
		}

		vl::Ptr<WfFunctionExpression> WfFunctionExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfFunctionExpression>();
		}

		vl::Ptr<WfVariableDeclaration> WfVariableDeclaration::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfVariableDeclaration>();
		}

		vl::Ptr<WfVariableStatement> WfVariableStatement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfVariableStatement>();
		}

		vl::Ptr<WfNewTypeExpression> WfNewTypeExpression::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfNewTypeExpression>();
		}

		vl::Ptr<WfModuleUsingNameFragment> WfModuleUsingNameFragment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingNameFragment>();
		}

		vl::Ptr<WfModuleUsingWildCardFragment> WfModuleUsingWildCardFragment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingWildCardFragment>();
		}

		vl::Ptr<WfModuleUsingItem> WfModuleUsingItem::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingItem>();
		}

		vl::Ptr<WfModuleUsingPath> WfModuleUsingPath::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModuleUsingPath>();
		}

		vl::Ptr<WfModule> WfModule::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return WfConvertParsingTreeNode(node, tokens).Cast<WfModule>();
		}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

		void WfPredefinedType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTopQualifiedType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReferenceType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRawPointerType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSharedPointerType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNullableType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfEnumerableType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfMapType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfChildType::Accept(WfType::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTopQualifiedExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReferenceExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfOrderedNameExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfOrderedLambdaExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfMemberExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfChildExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfLiteralExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFloatingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIntegerExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfStringExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFormatExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfUnaryExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBinaryExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfLetExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIfExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRangeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSetTestingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfConstructorExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfInferExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeCastingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeTestingExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeOfTypeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTypeOfExpressionExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfAttachEventExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfDetachEventExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBindExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfObserveExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfCallExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBreakStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfContinueStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfReturnStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfDeleteStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfRaiseExceptionStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfIfStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfSwitchStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfWhileStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfForEachStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfTryStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfBlockStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfExpressionStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNamespaceDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfFunctionExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfVariableDeclaration::Accept(WfDeclaration::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfVariableStatement::Accept(WfStatement::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfNewTypeExpression::Accept(WfExpression::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfModuleUsingNameFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void WfModuleUsingWildCardFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

/***********************************************************************
Parser Function
***********************************************************************/

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowDeclaration");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseDeclarationAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowDeclaration");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfDeclaration>();
			}
			return 0;
		}

		vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseDeclaration(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowExpression");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseExpressionAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowExpression");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfExpression>();
			}
			return 0;
		}

		vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseExpression(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowModule");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseModuleAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowModule");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfModule>();
			}
			return 0;
		}

		vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseModule(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowStatement");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseStatementAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowStatement");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfStatement>();
			}
			return 0;
		}

		vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseStatement(input, table, errors, codeIndex);
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowType");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseTypeAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"WorkflowType");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return WfConvertParsingTreeNode(node, state.GetTokens()).Cast<WfType>();
			}
			return 0;
		}

		vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return WfParseType(input, table, errors, codeIndex);
		}

/***********************************************************************
Table Generation
***********************************************************************/

		vl::Ptr<vl::parsing::tabling::ParsingTable> WfLoadTable()
		{
		    vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateBootstrapStrictParser();
		    vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
		    vl::Ptr<vl::parsing::ParsingTreeNode> definitionNode=parser->Parse(parserTextBuffer, L"ParserDecl", errors);
		    vl::Ptr<vl::parsing::definitions::ParsingDefinition> definition=vl::parsing::definitions::DeserializeDefinition(definitionNode);
		    vl::Ptr<vl::parsing::tabling::ParsingTable> table=vl::parsing::analyzing::GenerateTable(definition, true, errors);
		    return table;
		}

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::workflow;

			IMPL_TYPE_INFO_RENAME(WfType, Workflow::WfType)
			IMPL_TYPE_INFO_RENAME(WfPredefinedTypeName, Workflow::WfPredefinedTypeName)
			IMPL_TYPE_INFO_RENAME(WfPredefinedType, Workflow::WfPredefinedType)
			IMPL_TYPE_INFO_RENAME(WfTopQualifiedType, Workflow::WfTopQualifiedType)
			IMPL_TYPE_INFO_RENAME(WfReferenceType, Workflow::WfReferenceType)
			IMPL_TYPE_INFO_RENAME(WfRawPointerType, Workflow::WfRawPointerType)
			IMPL_TYPE_INFO_RENAME(WfSharedPointerType, Workflow::WfSharedPointerType)
			IMPL_TYPE_INFO_RENAME(WfNullableType, Workflow::WfNullableType)
			IMPL_TYPE_INFO_RENAME(WfEnumerableType, Workflow::WfEnumerableType)
			IMPL_TYPE_INFO_RENAME(WfMapWritability, Workflow::WfMapWritability)
			IMPL_TYPE_INFO_RENAME(WfMapType, Workflow::WfMapType)
			IMPL_TYPE_INFO_RENAME(WfFunctionType, Workflow::WfFunctionType)
			IMPL_TYPE_INFO_RENAME(WfChildType, Workflow::WfChildType)
			IMPL_TYPE_INFO_RENAME(WfExpression, Workflow::WfExpression)
			IMPL_TYPE_INFO_RENAME(WfTopQualifiedExpression, Workflow::WfTopQualifiedExpression)
			IMPL_TYPE_INFO_RENAME(WfReferenceExpression, Workflow::WfReferenceExpression)
			IMPL_TYPE_INFO_RENAME(WfOrderedNameExpression, Workflow::WfOrderedNameExpression)
			IMPL_TYPE_INFO_RENAME(WfOrderedLambdaExpression, Workflow::WfOrderedLambdaExpression)
			IMPL_TYPE_INFO_RENAME(WfMemberExpression, Workflow::WfMemberExpression)
			IMPL_TYPE_INFO_RENAME(WfChildExpression, Workflow::WfChildExpression)
			IMPL_TYPE_INFO_RENAME(WfLiteralValue, Workflow::WfLiteralValue)
			IMPL_TYPE_INFO_RENAME(WfLiteralExpression, Workflow::WfLiteralExpression)
			IMPL_TYPE_INFO_RENAME(WfFloatingExpression, Workflow::WfFloatingExpression)
			IMPL_TYPE_INFO_RENAME(WfIntegerExpression, Workflow::WfIntegerExpression)
			IMPL_TYPE_INFO_RENAME(WfStringExpression, Workflow::WfStringExpression)
			IMPL_TYPE_INFO_RENAME(WfFormatExpression, Workflow::WfFormatExpression)
			IMPL_TYPE_INFO_RENAME(WfUnaryOperator, Workflow::WfUnaryOperator)
			IMPL_TYPE_INFO_RENAME(WfUnaryExpression, Workflow::WfUnaryExpression)
			IMPL_TYPE_INFO_RENAME(WfBinaryOperator, Workflow::WfBinaryOperator)
			IMPL_TYPE_INFO_RENAME(WfBinaryExpression, Workflow::WfBinaryExpression)
			IMPL_TYPE_INFO_RENAME(WfLetVariable, Workflow::WfLetVariable)
			IMPL_TYPE_INFO_RENAME(WfLetExpression, Workflow::WfLetExpression)
			IMPL_TYPE_INFO_RENAME(WfIfExpression, Workflow::WfIfExpression)
			IMPL_TYPE_INFO_RENAME(WfRangeBoundary, Workflow::WfRangeBoundary)
			IMPL_TYPE_INFO_RENAME(WfRangeExpression, Workflow::WfRangeExpression)
			IMPL_TYPE_INFO_RENAME(WfSetTesting, Workflow::WfSetTesting)
			IMPL_TYPE_INFO_RENAME(WfSetTestingExpression, Workflow::WfSetTestingExpression)
			IMPL_TYPE_INFO_RENAME(WfConstructorArgument, Workflow::WfConstructorArgument)
			IMPL_TYPE_INFO_RENAME(WfConstructorExpression, Workflow::WfConstructorExpression)
			IMPL_TYPE_INFO_RENAME(WfInferExpression, Workflow::WfInferExpression)
			IMPL_TYPE_INFO_RENAME(WfTypeCastingStrategy, Workflow::WfTypeCastingStrategy)
			IMPL_TYPE_INFO_RENAME(WfTypeCastingExpression, Workflow::WfTypeCastingExpression)
			IMPL_TYPE_INFO_RENAME(WfTypeTesting, Workflow::WfTypeTesting)
			IMPL_TYPE_INFO_RENAME(WfTypeTestingExpression, Workflow::WfTypeTestingExpression)
			IMPL_TYPE_INFO_RENAME(WfTypeOfTypeExpression, Workflow::WfTypeOfTypeExpression)
			IMPL_TYPE_INFO_RENAME(WfTypeOfExpressionExpression, Workflow::WfTypeOfExpressionExpression)
			IMPL_TYPE_INFO_RENAME(WfAttachEventExpression, Workflow::WfAttachEventExpression)
			IMPL_TYPE_INFO_RENAME(WfDetachEventExpression, Workflow::WfDetachEventExpression)
			IMPL_TYPE_INFO_RENAME(WfBindExpression, Workflow::WfBindExpression)
			IMPL_TYPE_INFO_RENAME(WfObserveType, Workflow::WfObserveType)
			IMPL_TYPE_INFO_RENAME(WfObserveExpression, Workflow::WfObserveExpression)
			IMPL_TYPE_INFO_RENAME(WfCallExpression, Workflow::WfCallExpression)
			IMPL_TYPE_INFO_RENAME(WfStatement, Workflow::WfStatement)
			IMPL_TYPE_INFO_RENAME(WfBreakStatement, Workflow::WfBreakStatement)
			IMPL_TYPE_INFO_RENAME(WfContinueStatement, Workflow::WfContinueStatement)
			IMPL_TYPE_INFO_RENAME(WfReturnStatement, Workflow::WfReturnStatement)
			IMPL_TYPE_INFO_RENAME(WfDeleteStatement, Workflow::WfDeleteStatement)
			IMPL_TYPE_INFO_RENAME(WfRaiseExceptionStatement, Workflow::WfRaiseExceptionStatement)
			IMPL_TYPE_INFO_RENAME(WfIfStatement, Workflow::WfIfStatement)
			IMPL_TYPE_INFO_RENAME(WfSwitchCase, Workflow::WfSwitchCase)
			IMPL_TYPE_INFO_RENAME(WfSwitchStatement, Workflow::WfSwitchStatement)
			IMPL_TYPE_INFO_RENAME(WfWhileStatement, Workflow::WfWhileStatement)
			IMPL_TYPE_INFO_RENAME(WfForEachDirection, Workflow::WfForEachDirection)
			IMPL_TYPE_INFO_RENAME(WfForEachStatement, Workflow::WfForEachStatement)
			IMPL_TYPE_INFO_RENAME(WfTryStatement, Workflow::WfTryStatement)
			IMPL_TYPE_INFO_RENAME(WfBlockStatement, Workflow::WfBlockStatement)
			IMPL_TYPE_INFO_RENAME(WfExpressionStatement, Workflow::WfExpressionStatement)
			IMPL_TYPE_INFO_RENAME(WfDeclaration, Workflow::WfDeclaration)
			IMPL_TYPE_INFO_RENAME(WfNamespaceDeclaration, Workflow::WfNamespaceDeclaration)
			IMPL_TYPE_INFO_RENAME(WfFunctionArgument, Workflow::WfFunctionArgument)
			IMPL_TYPE_INFO_RENAME(WfFunctionAnonymity, Workflow::WfFunctionAnonymity)
			IMPL_TYPE_INFO_RENAME(WfFunctionDeclaration, Workflow::WfFunctionDeclaration)
			IMPL_TYPE_INFO_RENAME(WfFunctionExpression, Workflow::WfFunctionExpression)
			IMPL_TYPE_INFO_RENAME(WfVariableDeclaration, Workflow::WfVariableDeclaration)
			IMPL_TYPE_INFO_RENAME(WfVariableStatement, Workflow::WfVariableStatement)
			IMPL_TYPE_INFO_RENAME(WfNewTypeExpression, Workflow::WfNewTypeExpression)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingFragment, Workflow::WfModuleUsingFragment)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingNameFragment, Workflow::WfModuleUsingNameFragment)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingWildCardFragment, Workflow::WfModuleUsingWildCardFragment)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingItem, Workflow::WfModuleUsingItem)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingPath, Workflow::WfModuleUsingPath)
			IMPL_TYPE_INFO_RENAME(WfModuleType, Workflow::WfModuleType)
			IMPL_TYPE_INFO_RENAME(WfModule, Workflow::WfModule)
			IMPL_TYPE_INFO_RENAME(WfType::IVisitor, Workflow::WfType::IVisitor)
			IMPL_TYPE_INFO_RENAME(WfExpression::IVisitor, Workflow::WfExpression::IVisitor)
			IMPL_TYPE_INFO_RENAME(WfStatement::IVisitor, Workflow::WfStatement::IVisitor)
			IMPL_TYPE_INFO_RENAME(WfDeclaration::IVisitor, Workflow::WfDeclaration::IVisitor)
			IMPL_TYPE_INFO_RENAME(WfModuleUsingFragment::IVisitor, Workflow::WfModuleUsingFragment::IVisitor)

			BEGIN_CLASS_MEMBER(WfType)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfType)

			BEGIN_ENUM_ITEM(WfPredefinedTypeName)
				ENUM_ITEM_NAMESPACE(WfPredefinedTypeName)
				ENUM_NAMESPACE_ITEM(Void)
				ENUM_NAMESPACE_ITEM(Object)
				ENUM_NAMESPACE_ITEM(Interface)
				ENUM_NAMESPACE_ITEM(Int)
				ENUM_NAMESPACE_ITEM(UInt)
				ENUM_NAMESPACE_ITEM(Float)
				ENUM_NAMESPACE_ITEM(Double)
				ENUM_NAMESPACE_ITEM(String)
				ENUM_NAMESPACE_ITEM(Char)
				ENUM_NAMESPACE_ITEM(Bool)
			END_ENUM_ITEM(WfPredefinedTypeName)

			BEGIN_CLASS_MEMBER(WfPredefinedType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfPredefinedType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(name)
			END_CLASS_MEMBER(WfPredefinedType)

			BEGIN_CLASS_MEMBER(WfTopQualifiedType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTopQualifiedType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTopQualifiedType::*)(), [](WfTopQualifiedType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTopQualifiedType::*)(const vl::WString&), [](WfTopQualifiedType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfTopQualifiedType)

			BEGIN_CLASS_MEMBER(WfReferenceType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReferenceType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfReferenceType::*)(), [](WfReferenceType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfReferenceType::*)(const vl::WString&), [](WfReferenceType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfReferenceType)

			BEGIN_CLASS_MEMBER(WfRawPointerType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRawPointerType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfRawPointerType)

			BEGIN_CLASS_MEMBER(WfSharedPointerType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSharedPointerType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfSharedPointerType)

			BEGIN_CLASS_MEMBER(WfNullableType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNullableType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfNullableType)

			BEGIN_CLASS_MEMBER(WfEnumerableType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfEnumerableType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(element)
			END_CLASS_MEMBER(WfEnumerableType)

			BEGIN_ENUM_ITEM(WfMapWritability)
				ENUM_ITEM_NAMESPACE(WfMapWritability)
				ENUM_NAMESPACE_ITEM(Readonly)
				ENUM_NAMESPACE_ITEM(Writable)
			END_ENUM_ITEM(WfMapWritability)

			BEGIN_CLASS_MEMBER(WfMapType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfMapType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(writability)
				CLASS_MEMBER_FIELD(key)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfMapType)

			BEGIN_CLASS_MEMBER(WfFunctionType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionType>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(result)
				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfFunctionType)

			BEGIN_CLASS_MEMBER(WfChildType)
				CLASS_MEMBER_BASE(WfType)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfChildType>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfChildType::*)(), [](WfChildType* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfChildType::*)(const vl::WString&), [](WfChildType* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfChildType)

			BEGIN_CLASS_MEMBER(WfExpression)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfExpression)

			BEGIN_CLASS_MEMBER(WfTopQualifiedExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTopQualifiedExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTopQualifiedExpression::*)(), [](WfTopQualifiedExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTopQualifiedExpression::*)(const vl::WString&), [](WfTopQualifiedExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfTopQualifiedExpression)

			BEGIN_CLASS_MEMBER(WfReferenceExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReferenceExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfReferenceExpression::*)(), [](WfReferenceExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfReferenceExpression::*)(const vl::WString&), [](WfReferenceExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfReferenceExpression)

			BEGIN_CLASS_MEMBER(WfOrderedNameExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfOrderedNameExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfOrderedNameExpression::*)(), [](WfOrderedNameExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfOrderedNameExpression::*)(const vl::WString&), [](WfOrderedNameExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfOrderedNameExpression)

			BEGIN_CLASS_MEMBER(WfOrderedLambdaExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfOrderedLambdaExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(body)
			END_CLASS_MEMBER(WfOrderedLambdaExpression)

			BEGIN_CLASS_MEMBER(WfMemberExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfMemberExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfMemberExpression::*)(), [](WfMemberExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfMemberExpression::*)(const vl::WString&), [](WfMemberExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfMemberExpression)

			BEGIN_CLASS_MEMBER(WfChildExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfChildExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfChildExpression::*)(), [](WfChildExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfChildExpression::*)(const vl::WString&), [](WfChildExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfChildExpression)

			BEGIN_ENUM_ITEM(WfLiteralValue)
				ENUM_ITEM_NAMESPACE(WfLiteralValue)
				ENUM_NAMESPACE_ITEM(Null)
				ENUM_NAMESPACE_ITEM(True)
				ENUM_NAMESPACE_ITEM(False)
			END_ENUM_ITEM(WfLiteralValue)

			BEGIN_CLASS_MEMBER(WfLiteralExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLiteralExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfLiteralExpression)

			BEGIN_CLASS_MEMBER(WfFloatingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFloatingExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfFloatingExpression::*)(), [](WfFloatingExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfFloatingExpression::*)(const vl::WString&), [](WfFloatingExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfFloatingExpression)

			BEGIN_CLASS_MEMBER(WfIntegerExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIntegerExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfIntegerExpression::*)(), [](WfIntegerExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfIntegerExpression::*)(const vl::WString&), [](WfIntegerExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfIntegerExpression)

			BEGIN_CLASS_MEMBER(WfStringExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfStringExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfStringExpression::*)(), [](WfStringExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfStringExpression::*)(const vl::WString&), [](WfStringExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(WfStringExpression)

			BEGIN_CLASS_MEMBER(WfFormatExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFormatExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(WfFormatExpression::*)(), [](WfFormatExpression* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(WfFormatExpression::*)(const vl::WString&), [](WfFormatExpression* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
				CLASS_MEMBER_FIELD(expandedExpression)
			END_CLASS_MEMBER(WfFormatExpression)

			BEGIN_ENUM_ITEM(WfUnaryOperator)
				ENUM_ITEM_NAMESPACE(WfUnaryOperator)
				ENUM_NAMESPACE_ITEM(Positive)
				ENUM_NAMESPACE_ITEM(Negative)
				ENUM_NAMESPACE_ITEM(Not)
			END_ENUM_ITEM(WfUnaryOperator)

			BEGIN_CLASS_MEMBER(WfUnaryExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfUnaryExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(op)
				CLASS_MEMBER_FIELD(operand)
			END_CLASS_MEMBER(WfUnaryExpression)

			BEGIN_ENUM_ITEM(WfBinaryOperator)
				ENUM_ITEM_NAMESPACE(WfBinaryOperator)
				ENUM_NAMESPACE_ITEM(Assign)
				ENUM_NAMESPACE_ITEM(Index)
				ENUM_NAMESPACE_ITEM(Concat)
				ENUM_NAMESPACE_ITEM(FailedThen)
				ENUM_NAMESPACE_ITEM(Exp)
				ENUM_NAMESPACE_ITEM(Add)
				ENUM_NAMESPACE_ITEM(Sub)
				ENUM_NAMESPACE_ITEM(Mul)
				ENUM_NAMESPACE_ITEM(Div)
				ENUM_NAMESPACE_ITEM(Shl)
				ENUM_NAMESPACE_ITEM(Shr)
				ENUM_NAMESPACE_ITEM(LT)
				ENUM_NAMESPACE_ITEM(GT)
				ENUM_NAMESPACE_ITEM(LE)
				ENUM_NAMESPACE_ITEM(GE)
				ENUM_NAMESPACE_ITEM(EQ)
				ENUM_NAMESPACE_ITEM(NE)
				ENUM_NAMESPACE_ITEM(Xor)
				ENUM_NAMESPACE_ITEM(And)
				ENUM_NAMESPACE_ITEM(Or)
			END_ENUM_ITEM(WfBinaryOperator)

			BEGIN_CLASS_MEMBER(WfBinaryExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBinaryExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(op)
				CLASS_MEMBER_FIELD(first)
				CLASS_MEMBER_FIELD(second)
			END_CLASS_MEMBER(WfBinaryExpression)

			BEGIN_CLASS_MEMBER(WfLetVariable)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLetVariable>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfLetVariable::*)(), [](WfLetVariable* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfLetVariable::*)(const vl::WString&), [](WfLetVariable* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfLetVariable)

			BEGIN_CLASS_MEMBER(WfLetExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfLetExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(variables)
				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfLetExpression)

			BEGIN_CLASS_MEMBER(WfIfExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIfExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(condition)
				CLASS_MEMBER_FIELD(trueBranch)
				CLASS_MEMBER_FIELD(falseBranch)
			END_CLASS_MEMBER(WfIfExpression)

			BEGIN_ENUM_ITEM(WfRangeBoundary)
				ENUM_ITEM_NAMESPACE(WfRangeBoundary)
				ENUM_NAMESPACE_ITEM(Inclusive)
				ENUM_NAMESPACE_ITEM(Exclusive)
			END_ENUM_ITEM(WfRangeBoundary)

			BEGIN_CLASS_MEMBER(WfRangeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRangeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(begin)
				CLASS_MEMBER_FIELD(beginBoundary)
				CLASS_MEMBER_FIELD(end)
				CLASS_MEMBER_FIELD(endBoundary)
			END_CLASS_MEMBER(WfRangeExpression)

			BEGIN_ENUM_ITEM(WfSetTesting)
				ENUM_ITEM_NAMESPACE(WfSetTesting)
				ENUM_NAMESPACE_ITEM(In)
				ENUM_NAMESPACE_ITEM(NotIn)
			END_ENUM_ITEM(WfSetTesting)

			BEGIN_CLASS_MEMBER(WfSetTestingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSetTestingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(test)
				CLASS_MEMBER_FIELD(element)
				CLASS_MEMBER_FIELD(collection)
			END_CLASS_MEMBER(WfSetTestingExpression)

			BEGIN_CLASS_MEMBER(WfConstructorArgument)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfConstructorArgument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(key)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(WfConstructorArgument)

			BEGIN_CLASS_MEMBER(WfConstructorExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfConstructorExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfConstructorExpression)

			BEGIN_CLASS_MEMBER(WfInferExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfInferExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfInferExpression)

			BEGIN_ENUM_ITEM(WfTypeCastingStrategy)
				ENUM_ITEM_NAMESPACE(WfTypeCastingStrategy)
				ENUM_NAMESPACE_ITEM(Strong)
				ENUM_NAMESPACE_ITEM(Weak)
			END_ENUM_ITEM(WfTypeCastingStrategy)

			BEGIN_CLASS_MEMBER(WfTypeCastingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeCastingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(strategy)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeCastingExpression)

			BEGIN_ENUM_ITEM(WfTypeTesting)
				ENUM_ITEM_NAMESPACE(WfTypeTesting)
				ENUM_NAMESPACE_ITEM(IsType)
				ENUM_NAMESPACE_ITEM(IsNotType)
				ENUM_NAMESPACE_ITEM(IsNull)
				ENUM_NAMESPACE_ITEM(IsNotNull)
			END_ENUM_ITEM(WfTypeTesting)

			BEGIN_CLASS_MEMBER(WfTypeTestingExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeTestingExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(test)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeTestingExpression)

			BEGIN_CLASS_MEMBER(WfTypeOfTypeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeOfTypeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfTypeOfTypeExpression)

			BEGIN_CLASS_MEMBER(WfTypeOfExpressionExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTypeOfExpressionExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfTypeOfExpressionExpression)

			BEGIN_CLASS_MEMBER(WfAttachEventExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfAttachEventExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(event)
				CLASS_MEMBER_FIELD(function)
			END_CLASS_MEMBER(WfAttachEventExpression)

			BEGIN_CLASS_MEMBER(WfDetachEventExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfDetachEventExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(handler)
			END_CLASS_MEMBER(WfDetachEventExpression)

			BEGIN_CLASS_MEMBER(WfBindExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBindExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfBindExpression)

			BEGIN_ENUM_ITEM(WfObserveType)
				ENUM_ITEM_NAMESPACE(WfObserveType)
				ENUM_NAMESPACE_ITEM(SimpleObserve)
				ENUM_NAMESPACE_ITEM(ExtendedObserve)
			END_ENUM_ITEM(WfObserveType)

			BEGIN_CLASS_MEMBER(WfObserveExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfObserveExpression>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfObserveExpression::*)(), [](WfObserveExpression* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfObserveExpression::*)(const vl::WString&), [](WfObserveExpression* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_FIELD(observeType)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(events)
			END_CLASS_MEMBER(WfObserveExpression)

			BEGIN_CLASS_MEMBER(WfCallExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfCallExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(function)
				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(WfCallExpression)

			BEGIN_CLASS_MEMBER(WfStatement)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfStatement)

			BEGIN_CLASS_MEMBER(WfBreakStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBreakStatement>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfBreakStatement)

			BEGIN_CLASS_MEMBER(WfContinueStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfContinueStatement>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfContinueStatement)

			BEGIN_CLASS_MEMBER(WfReturnStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfReturnStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfReturnStatement)

			BEGIN_CLASS_MEMBER(WfDeleteStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfDeleteStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfDeleteStatement)

			BEGIN_CLASS_MEMBER(WfRaiseExceptionStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfRaiseExceptionStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfRaiseExceptionStatement)

			BEGIN_CLASS_MEMBER(WfIfStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfIfStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfIfStatement::*)(), [](WfIfStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfIfStatement::*)(const vl::WString&), [](WfIfStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(trueBranch)
				CLASS_MEMBER_FIELD(falseBranch)
			END_CLASS_MEMBER(WfIfStatement)

			BEGIN_CLASS_MEMBER(WfSwitchCase)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSwitchCase>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfSwitchCase)

			BEGIN_CLASS_MEMBER(WfSwitchStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfSwitchStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
				CLASS_MEMBER_FIELD(caseBranches)
				CLASS_MEMBER_FIELD(defaultBranch)
			END_CLASS_MEMBER(WfSwitchStatement)

			BEGIN_CLASS_MEMBER(WfWhileStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfWhileStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(condition)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfWhileStatement)

			BEGIN_ENUM_ITEM(WfForEachDirection)
				ENUM_ITEM_NAMESPACE(WfForEachDirection)
				ENUM_NAMESPACE_ITEM(Normal)
				ENUM_NAMESPACE_ITEM(Reversed)
			END_ENUM_ITEM(WfForEachDirection)

			BEGIN_CLASS_MEMBER(WfForEachStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfForEachStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfForEachStatement::*)(), [](WfForEachStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfForEachStatement::*)(const vl::WString&), [](WfForEachStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(direction)
				CLASS_MEMBER_FIELD(collection)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfForEachStatement)

			BEGIN_CLASS_MEMBER(WfTryStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfTryStatement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfTryStatement::*)(), [](WfTryStatement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfTryStatement::*)(const vl::WString&), [](WfTryStatement* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(protectedStatement)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(catchStatement)
				CLASS_MEMBER_FIELD(finallyStatement)
			END_CLASS_MEMBER(WfTryStatement)

			BEGIN_CLASS_MEMBER(WfBlockStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfBlockStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(statements)
			END_CLASS_MEMBER(WfBlockStatement)

			BEGIN_CLASS_MEMBER(WfExpressionStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfExpressionStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfExpressionStatement)

			BEGIN_CLASS_MEMBER(WfDeclaration)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})
				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfDeclaration::*)(), [](WfDeclaration* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfDeclaration::*)(const vl::WString&), [](WfDeclaration* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfDeclaration)

			BEGIN_CLASS_MEMBER(WfNamespaceDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNamespaceDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(declarations)
			END_CLASS_MEMBER(WfNamespaceDeclaration)

			BEGIN_CLASS_MEMBER(WfFunctionArgument)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionArgument>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfFunctionArgument::*)(), [](WfFunctionArgument* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfFunctionArgument::*)(const vl::WString&), [](WfFunctionArgument* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(type)
			END_CLASS_MEMBER(WfFunctionArgument)

			BEGIN_ENUM_ITEM(WfFunctionAnonymity)
				ENUM_ITEM_NAMESPACE(WfFunctionAnonymity)
				ENUM_NAMESPACE_ITEM(Named)
				ENUM_NAMESPACE_ITEM(Anonymous)
			END_ENUM_ITEM(WfFunctionAnonymity)

			BEGIN_CLASS_MEMBER(WfFunctionDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(anonymity)
				CLASS_MEMBER_FIELD(arguments)
				CLASS_MEMBER_FIELD(returnType)
				CLASS_MEMBER_FIELD(statement)
			END_CLASS_MEMBER(WfFunctionDeclaration)

			BEGIN_CLASS_MEMBER(WfFunctionExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfFunctionExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(function)
			END_CLASS_MEMBER(WfFunctionExpression)

			BEGIN_CLASS_MEMBER(WfVariableDeclaration)
				CLASS_MEMBER_BASE(WfDeclaration)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfVariableDeclaration>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_FIELD(expression)
			END_CLASS_MEMBER(WfVariableDeclaration)

			BEGIN_CLASS_MEMBER(WfVariableStatement)
				CLASS_MEMBER_BASE(WfStatement)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfVariableStatement>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(variable)
			END_CLASS_MEMBER(WfVariableStatement)

			BEGIN_CLASS_MEMBER(WfNewTypeExpression)
				CLASS_MEMBER_BASE(WfExpression)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfNewTypeExpression>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(type)
				CLASS_MEMBER_FIELD(arguments)
				CLASS_MEMBER_FIELD(functions)
			END_CLASS_MEMBER(WfNewTypeExpression)

			BEGIN_CLASS_MEMBER(WfModuleUsingFragment)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(WfModuleUsingFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingNameFragment)
				CLASS_MEMBER_BASE(WfModuleUsingFragment)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingNameFragment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfModuleUsingNameFragment::*)(), [](WfModuleUsingNameFragment* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfModuleUsingNameFragment::*)(const vl::WString&), [](WfModuleUsingNameFragment* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
			END_CLASS_MEMBER(WfModuleUsingNameFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingWildCardFragment)
				CLASS_MEMBER_BASE(WfModuleUsingFragment)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingWildCardFragment>(), NO_PARAMETER)


			END_CLASS_MEMBER(WfModuleUsingWildCardFragment)

			BEGIN_CLASS_MEMBER(WfModuleUsingItem)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingItem>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(fragments)
			END_CLASS_MEMBER(WfModuleUsingItem)

			BEGIN_CLASS_MEMBER(WfModuleUsingPath)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModuleUsingPath>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(items)
			END_CLASS_MEMBER(WfModuleUsingPath)

			BEGIN_ENUM_ITEM(WfModuleType)
				ENUM_ITEM_NAMESPACE(WfModuleType)
				ENUM_NAMESPACE_ITEM(Module)
				ENUM_NAMESPACE_ITEM(Unit)
			END_ENUM_ITEM(WfModuleType)

			BEGIN_CLASS_MEMBER(WfModule)
				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<WfModule>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(WfModule::*)(), [](WfModule* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(WfModule::*)(const vl::WString&), [](WfModule* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_FIELD(moduleType)
				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(paths)
				CLASS_MEMBER_FIELD(declarations)
			END_CLASS_MEMBER(WfModule)

			BEGIN_CLASS_MEMBER(WfType::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfType::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfType_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfPredefinedType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfTopQualifiedType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfReferenceType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfRawPointerType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfSharedPointerType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfNullableType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfEnumerableType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfMapType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfFunctionType* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfType::IVisitor::*)(WfChildType* node))
			END_CLASS_MEMBER(WfType)

			BEGIN_CLASS_MEMBER(WfExpression::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfExpression::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfExpression_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTopQualifiedExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfReferenceExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfOrderedNameExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfOrderedLambdaExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfMemberExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfChildExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfLiteralExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFloatingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfIntegerExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfStringExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFormatExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfUnaryExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfBinaryExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfLetExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfIfExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfRangeExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfSetTestingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfConstructorExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfInferExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeCastingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeTestingExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeOfTypeExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfTypeOfExpressionExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfAttachEventExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfDetachEventExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfBindExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfObserveExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfCallExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfFunctionExpression* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfExpression::IVisitor::*)(WfNewTypeExpression* node))
			END_CLASS_MEMBER(WfExpression)

			BEGIN_CLASS_MEMBER(WfStatement::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfStatement::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfStatement_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfBreakStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfContinueStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfReturnStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfDeleteStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfRaiseExceptionStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfIfStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfSwitchStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfWhileStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfForEachStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfTryStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfBlockStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfExpressionStatement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfStatement::IVisitor::*)(WfVariableStatement* node))
			END_CLASS_MEMBER(WfStatement)

			BEGIN_CLASS_MEMBER(WfDeclaration::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfDeclaration::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfDeclaration_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfNamespaceDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfFunctionDeclaration* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfDeclaration::IVisitor::*)(WfVariableDeclaration* node))
			END_CLASS_MEMBER(WfDeclaration)

			BEGIN_CLASS_MEMBER(WfModuleUsingFragment::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<WfModuleUsingFragment::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::WfModuleUsingFragment_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfModuleUsingFragment::IVisitor::*)(WfModuleUsingNameFragment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(WfModuleUsingFragment::IVisitor::*)(WfModuleUsingWildCardFragment* node))
			END_CLASS_MEMBER(WfModuleUsingFragment)

			class WfTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::workflow::WfType)
					ADD_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
					ADD_TYPE_INFO(vl::workflow::WfPredefinedType)
					ADD_TYPE_INFO(vl::workflow::WfTopQualifiedType)
					ADD_TYPE_INFO(vl::workflow::WfReferenceType)
					ADD_TYPE_INFO(vl::workflow::WfRawPointerType)
					ADD_TYPE_INFO(vl::workflow::WfSharedPointerType)
					ADD_TYPE_INFO(vl::workflow::WfNullableType)
					ADD_TYPE_INFO(vl::workflow::WfEnumerableType)
					ADD_TYPE_INFO(vl::workflow::WfMapWritability)
					ADD_TYPE_INFO(vl::workflow::WfMapType)
					ADD_TYPE_INFO(vl::workflow::WfFunctionType)
					ADD_TYPE_INFO(vl::workflow::WfChildType)
					ADD_TYPE_INFO(vl::workflow::WfExpression)
					ADD_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
					ADD_TYPE_INFO(vl::workflow::WfReferenceExpression)
					ADD_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
					ADD_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
					ADD_TYPE_INFO(vl::workflow::WfMemberExpression)
					ADD_TYPE_INFO(vl::workflow::WfChildExpression)
					ADD_TYPE_INFO(vl::workflow::WfLiteralValue)
					ADD_TYPE_INFO(vl::workflow::WfLiteralExpression)
					ADD_TYPE_INFO(vl::workflow::WfFloatingExpression)
					ADD_TYPE_INFO(vl::workflow::WfIntegerExpression)
					ADD_TYPE_INFO(vl::workflow::WfStringExpression)
					ADD_TYPE_INFO(vl::workflow::WfFormatExpression)
					ADD_TYPE_INFO(vl::workflow::WfUnaryOperator)
					ADD_TYPE_INFO(vl::workflow::WfUnaryExpression)
					ADD_TYPE_INFO(vl::workflow::WfBinaryOperator)
					ADD_TYPE_INFO(vl::workflow::WfBinaryExpression)
					ADD_TYPE_INFO(vl::workflow::WfLetVariable)
					ADD_TYPE_INFO(vl::workflow::WfLetExpression)
					ADD_TYPE_INFO(vl::workflow::WfIfExpression)
					ADD_TYPE_INFO(vl::workflow::WfRangeBoundary)
					ADD_TYPE_INFO(vl::workflow::WfRangeExpression)
					ADD_TYPE_INFO(vl::workflow::WfSetTesting)
					ADD_TYPE_INFO(vl::workflow::WfSetTestingExpression)
					ADD_TYPE_INFO(vl::workflow::WfConstructorArgument)
					ADD_TYPE_INFO(vl::workflow::WfConstructorExpression)
					ADD_TYPE_INFO(vl::workflow::WfInferExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
					ADD_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeTesting)
					ADD_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
					ADD_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
					ADD_TYPE_INFO(vl::workflow::WfAttachEventExpression)
					ADD_TYPE_INFO(vl::workflow::WfDetachEventExpression)
					ADD_TYPE_INFO(vl::workflow::WfBindExpression)
					ADD_TYPE_INFO(vl::workflow::WfObserveType)
					ADD_TYPE_INFO(vl::workflow::WfObserveExpression)
					ADD_TYPE_INFO(vl::workflow::WfCallExpression)
					ADD_TYPE_INFO(vl::workflow::WfStatement)
					ADD_TYPE_INFO(vl::workflow::WfBreakStatement)
					ADD_TYPE_INFO(vl::workflow::WfContinueStatement)
					ADD_TYPE_INFO(vl::workflow::WfReturnStatement)
					ADD_TYPE_INFO(vl::workflow::WfDeleteStatement)
					ADD_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
					ADD_TYPE_INFO(vl::workflow::WfIfStatement)
					ADD_TYPE_INFO(vl::workflow::WfSwitchCase)
					ADD_TYPE_INFO(vl::workflow::WfSwitchStatement)
					ADD_TYPE_INFO(vl::workflow::WfWhileStatement)
					ADD_TYPE_INFO(vl::workflow::WfForEachDirection)
					ADD_TYPE_INFO(vl::workflow::WfForEachStatement)
					ADD_TYPE_INFO(vl::workflow::WfTryStatement)
					ADD_TYPE_INFO(vl::workflow::WfBlockStatement)
					ADD_TYPE_INFO(vl::workflow::WfExpressionStatement)
					ADD_TYPE_INFO(vl::workflow::WfDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfFunctionArgument)
					ADD_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
					ADD_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfFunctionExpression)
					ADD_TYPE_INFO(vl::workflow::WfVariableDeclaration)
					ADD_TYPE_INFO(vl::workflow::WfVariableStatement)
					ADD_TYPE_INFO(vl::workflow::WfNewTypeExpression)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingItem)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingPath)
					ADD_TYPE_INFO(vl::workflow::WfModuleType)
					ADD_TYPE_INFO(vl::workflow::WfModule)
					ADD_TYPE_INFO(vl::workflow::WfType::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
					ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool WfLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new WfTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
Runtime\WfRuntime.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfInstruction
***********************************************************************/

			WfInstruction::WfInstruction()
				:flagParameter(Value::Null)
				, typeDescriptorParameter(0)
			{

			}

			#define CTOR(NAME)\
				WfInstruction WfInstruction::NAME()\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					return ins;\
				}\

			#define CTOR_VALUE(NAME)\
				WfInstruction WfInstruction::NAME(const reflection::description::Value& value)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.valueParameter = value;\
					return ins;\
				}\

			#define CTOR_FUNCTION(NAME)\
				WfInstruction WfInstruction::NAME(vint function)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.indexParameter = function;\
					return ins;\
				}\

			#define CTOR_FUNCTION_COUNT(NAME)\
				WfInstruction WfInstruction::NAME(vint function, vint count)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.indexParameter = function;\
					ins.countParameter = count;\
					return ins;\
				}\

			#define CTOR_VARIABLE(NAME)\
				WfInstruction WfInstruction::NAME(vint variable)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.indexParameter = variable;\
					return ins;\
				}\

			#define CTOR_COUNT(NAME)\
				WfInstruction WfInstruction::NAME(vint count)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.countParameter = count;\
					return ins;\
				}\

			#define CTOR_FLAG_TYPEDESCRIPTOR(NAME)\
				WfInstruction WfInstruction::NAME(reflection::description::Value::ValueType flag, reflection::description::ITypeDescriptor* typeDescriptor)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.flagParameter = flag;\
					ins.typeDescriptorParameter = typeDescriptor;\
					return ins;\
				}\

			#define CTOR_PROPERTY(NAME)\
				WfInstruction WfInstruction::NAME(reflection::description::IPropertyInfo* propertyInfo)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.propertyParameter = propertyInfo;\
					return ins;\
				}\

			#define CTOR_METHOD_COUNT(NAME)\
				WfInstruction WfInstruction::NAME(reflection::description::IMethodInfo* methodInfo, vint count)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.methodParameter = methodInfo;\
					ins.countParameter = count;\
					return ins;\
				}\

			#define CTOR_EVENT(NAME)\
				WfInstruction WfInstruction::NAME(reflection::description::IEventInfo* eventInfo)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.eventParameter = eventInfo;\
					return ins;\
				}\

			#define CTOR_LABEL(NAME)\
				WfInstruction WfInstruction::NAME(vint label)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.indexParameter = label;\
					return ins;\
				}\

			#define CTOR_TYPE(NAME)\
				WfInstruction WfInstruction::NAME(WfInsType type)\
				{\
					WfInstruction ins;\
					ins.code = WfInsCode::NAME;\
					ins.typeParameter = type;\
					return ins;\
				}\

			INSTRUCTION_CASES(
				CTOR,
				CTOR_VALUE,
				CTOR_FUNCTION,
				CTOR_FUNCTION_COUNT,
				CTOR_VARIABLE,
				CTOR_COUNT,
				CTOR_FLAG_TYPEDESCRIPTOR,
				CTOR_PROPERTY,
				CTOR_METHOD_COUNT,
				CTOR_EVENT,
				CTOR_LABEL,
				CTOR_TYPE)

			#undef CTOR
			#undef CTOR_VALUE
			#undef CTOR_FUNCTION
			#undef CTOR_FUNCTION_COUNT
			#undef CTOR_VARIABLE
			#undef CTOR_COUNT
			#undef CTOR_FLAG_TYPEDESCRIPTOR
			#undef CTOR_PROPERTY
			#undef CTOR_METHOD_COUNT
			#undef CTOR_EVENT
			#undef CTOR_LABEL
			#undef CTOR_TYPE

/***********************************************************************
WfRuntimeGlobalContext
***********************************************************************/

			WfRuntimeGlobalContext::WfRuntimeGlobalContext(Ptr<WfAssembly> _assembly)
				:assembly(_assembly)
			{
				globalVariables = new WfRuntimeVariableContext;
				globalVariables->variables.Resize(assembly->variableNames.Count());
			}

/***********************************************************************
WfRuntimeThreadContext
***********************************************************************/

			WfRuntimeThreadContext::WfRuntimeThreadContext(Ptr<WfRuntimeGlobalContext> _context)
				:globalContext(_context)
			{
				stack.SetLessMemoryMode(false);
				stackFrames.SetLessMemoryMode(false);
			}

			WfRuntimeThreadContext::WfRuntimeThreadContext(Ptr<WfAssembly> _assembly)
				:globalContext(new WfRuntimeGlobalContext(_assembly))
			{
				stack.SetLessMemoryMode(false);
				stackFrames.SetLessMemoryMode(false);
			}

			WfRuntimeStackFrame& WfRuntimeThreadContext::GetCurrentStackFrame()
			{
				return stackFrames[stackFrames.Count() - 1];
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushStackFrame(vint functionIndex, vint argumentCount, Ptr<WfRuntimeVariableContext> capturedVariables)
			{
				if (stackFrames.Count() == 0)
				{
					if (stack.Count() < argumentCount)
					{
						return WfRuntimeThreadContextError::StackCorrupted;
					}
				}
				else
				{
					auto& frame = GetCurrentStackFrame();
					if (stack.Count() - frame.freeStackBase < argumentCount)
					{
						return WfRuntimeThreadContextError::StackCorrupted;
					}
				}
				if (functionIndex < 0 || functionIndex >= globalContext->assembly->functions.Count())
				{
					return WfRuntimeThreadContextError::WrongFunctionIndex;
				}
				auto meta = globalContext->assembly->functions[functionIndex];
				if (meta->argumentNames.Count() != argumentCount)
				{
					return WfRuntimeThreadContextError::WrongArgumentCount;
				}
				if (meta->capturedVariableNames.Count() == 0)
				{
					if (capturedVariables)
					{
						return WfRuntimeThreadContextError::WrongCapturedVariableCount;
					}
				}
				else
				{
					if (!capturedVariables || capturedVariables->variables.Count() != meta->capturedVariableNames.Count())
					{
						return WfRuntimeThreadContextError::WrongCapturedVariableCount;
					}
				}

				WfRuntimeStackFrame frame;
				frame.capturedVariables = capturedVariables;
				frame.functionIndex = functionIndex;
				frame.nextInstructionIndex = globalContext->assembly->functions[functionIndex]->firstInstruction;
				frame.stackBase = stack.Count() - argumentCount;

				frame.fixedVariableCount = meta->argumentNames.Count() + meta->localVariableNames.Count();
				frame.freeStackBase = frame.stackBase + frame.fixedVariableCount;
				stackFrames.Add(frame);

				for (vint i = 0; i < meta->localVariableNames.Count(); i++)
				{
					stack.Add(Value());
				}
				if (status == WfRuntimeExecutionStatus::Finished || status == WfRuntimeExecutionStatus::FatalError)
				{
					status = WfRuntimeExecutionStatus::Ready;
				}
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopStackFrame()
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				WfRuntimeStackFrame frame = GetCurrentStackFrame();
				stackFrames.RemoveAt(stackFrames.Count() - 1);

				if (stack.Count() > frame.stackBase)
				{
					stack.RemoveRange(frame.stackBase, stack.Count() - frame.stackBase);
				}
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushTrapFrame(vint instructionIndex)
			{
				WfRuntimeTrapFrame frame;
				frame.stackFrameIndex = stackFrames.Count() - 1;
				frame.instructionIndex = instructionIndex;
				trapFrames.Add(frame);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopTrapFrame()
			{
				if (trapFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyTrapFrame;
				WfRuntimeTrapFrame& frame = trapFrames[trapFrames.Count() - 1];
				if (frame.stackFrameIndex != stackFrames.Count() - 1) return WfRuntimeThreadContextError::TrapFrameCorrupted;
				trapFrames.RemoveAt(trapFrames.Count() - 1);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PushValue(const reflection::description::Value& value)
			{
				stack.Add(value);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::PopValue(reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0)
				{
					if (stack.Count() == 0) return WfRuntimeThreadContextError::EmptyStack;
				}
				else
				{
					WfRuntimeStackFrame& frame = GetCurrentStackFrame();
					if (stack.Count() <= frame.freeStackBase) return WfRuntimeThreadContextError::StackCorrupted;
				}
				value = stack[stack.Count() - 1];
				stack.RemoveAt(stack.Count() - 1);
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::RaiseException(const reflection::description::Value& exception, bool fatalError)
			{
				exceptionValue = exception;
				status = fatalError ? WfRuntimeExecutionStatus::FatalError : WfRuntimeExecutionStatus::RaisedException;
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadStackValue(vint stackItemIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (stackItemIndex < frame.freeStackBase || stackItemIndex >= stack.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = stack[stackItemIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadGlobalVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (variableIndex < 0 || variableIndex >= globalContext->globalVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = globalContext->globalVariables->variables[variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::StoreGlobalVariable(vint variableIndex, const reflection::description::Value& value)
			{
				if (variableIndex < 0 || variableIndex >= globalContext->globalVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				globalContext->globalVariables->variables[variableIndex] = value;
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadCapturedVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.capturedVariables->variables.Count())
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = frame.capturedVariables->variables[variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::LoadLocalVariable(vint variableIndex, reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.fixedVariableCount)
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				value = stack[frame.stackBase + variableIndex];
				return WfRuntimeThreadContextError::Success;
			}

			WfRuntimeThreadContextError WfRuntimeThreadContext::StoreLocalVariable(vint variableIndex, const reflection::description::Value& value)
			{
				if (stackFrames.Count() == 0) return WfRuntimeThreadContextError::EmptyStackFrame;
				auto frame = GetCurrentStackFrame();
				if (variableIndex < 0 || variableIndex >= frame.fixedVariableCount)
				{
					return WfRuntimeThreadContextError::WrongVariableIndex;
				}

				stack[frame.stackBase + variableIndex] = value;
				return WfRuntimeThreadContextError::Success;
			}

			void WfRuntimeThreadContext::ExecuteToEnd()
			{
				while (Execute() != WfRuntimeExecutionAction::Nop);
			}
		}
	}
}

/***********************************************************************
Runtime\WfRuntime_Execution.cpp
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfRuntimeThreadContext (Operators)
***********************************************************************/

#define INTERNAL_ERROR(MESSAGE)\
				do{\
					context.RaiseException(BoxValue<WString>(L"Internal error: " MESSAGE), true);\
					return WfRuntimeExecutionAction::Nop; \
				} while (0)\

#define CONTEXT_ACTION(ACTION, MESSAGE)\
				do{\
					if ((context.ACTION) != WfRuntimeThreadContextError::Success)\
					{\
						INTERNAL_ERROR(MESSAGE);\
					}\
				} while (0)\

			//-------------------------------------------------------------------------------

#define UNARY_OPERATOR(NAME, OPERATOR)\
			template<typename T>\
			WfRuntimeExecutionAction OPERATOR_##NAME(WfRuntimeThreadContext& context)\
			{\
				Value operand;\
				CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");\
				T value = OPERATOR UnboxValue<T>(operand);\
				context.PushValue(BoxValue(value));\
				return WfRuntimeExecutionAction::ExecuteInstruction;\
			}\

#define BINARY_OPERATOR(NAME, OPERATOR)\
			template<typename T>\
			WfRuntimeExecutionAction OPERATOR_##NAME(WfRuntimeThreadContext& context)\
			{\
				Value first, second;\
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");\
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");\
				T value = UnboxValue<T>(first) OPERATOR UnboxValue<T>(second);\
				context.PushValue(BoxValue(value));\
				return WfRuntimeExecutionAction::ExecuteInstruction;\
			}\

			//-------------------------------------------------------------------------------

			UNARY_OPERATOR(OpNot, ~)
			UNARY_OPERATOR(OpNot_Bool, !)
			UNARY_OPERATOR(OpPositive, +)
			UNARY_OPERATOR(OpNegative, -)

			BINARY_OPERATOR(OpAdd, +)
			BINARY_OPERATOR(OpSub, -)
			BINARY_OPERATOR(OpMul, *)
			BINARY_OPERATOR(OpDiv, /)
			BINARY_OPERATOR(OpShl, <<)
			BINARY_OPERATOR(OpShr, >>)
			BINARY_OPERATOR(OpAnd, &)
			BINARY_OPERATOR(OpAnd_Bool, &&)
			BINARY_OPERATOR(OpOr, |)
			BINARY_OPERATOR(OpOr_Bool, ||)
			BINARY_OPERATOR(OpXor, ^)
			
			template<typename T>
			WfRuntimeExecutionAction OPERATOR_OpCompare(WfRuntimeThreadContext& context)
			{
				Value first, second;
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");

				bool firstNull = first.GetValueType() == Value::Null;
				bool secondNull = second.GetValueType() == Value::Null;
				if (firstNull)
				{
					if (secondNull)
					{
						context.PushValue(BoxValue((vint)0));
					}
					else
					{
						context.PushValue(BoxValue((vint)-1));
					}
				}
				else
				{
					if (secondNull)
					{context.PushValue(BoxValue((vint)1));
					}
					else
					{
						T firstValue = UnboxValue<T>(first);
						T secondValue = UnboxValue<T>(second);
						if (firstValue < secondValue)
						{
							context.PushValue(BoxValue((vint)-1));
						}
						else if (firstValue > secondValue)
						{
							context.PushValue(BoxValue((vint)1));
						}
						else
						{
							context.PushValue(BoxValue((vint)0));
						}
					}
				}
				return WfRuntimeExecutionAction::ExecuteInstruction;
			}
			
/***********************************************************************
WfRuntimeThreadContext (TypeConversion)
***********************************************************************/

			bool OPERATOR_OpConvertToType(const Value& result, Value& converted, const WfInstruction& ins)
			{
				switch (ins.flagParameter)
				{
				case Value::Null:
					return false;
				case Value::RawPtr:
					if (result.GetValueType() == Value::Text)
					{
						return false;
					}
					else if (result.GetRawPtr())
					{
						if (result.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
						{
							converted = Value::From(result.GetRawPtr());
						}
						else
						{
							return false;
						}
					}
					break;
				case Value::SharedPtr:
					if (result.GetValueType() == Value::Text)
					{
						return false;
					}
					else if (result.GetRawPtr())
					{
						if (result.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
						{
							converted = Value::From(Ptr<DescriptableObject>(result.GetRawPtr()));
						}
						else
						{
							return false;
						}
					}
					break;
				case Value::Text:
					if (result.GetValueType() != Value::Text)
					{
						return false;
					}
					else if (ins.typeDescriptorParameter == GetTypeDescriptor<void>())
					{
						if (result.GetText() != L"")
						{
							return false;
						}
					}
					else
					{
						auto serializer = ins.typeDescriptorParameter->GetValueSerializer();
						if (!serializer)
						{
							return false;
						}
						if (!serializer->Parse(result.GetText(), converted))
						{
							return false;
						}
					}
					break;
				}

				return true;
			}
			
/***********************************************************************
WfRuntimeThreadContext (Range)
***********************************************************************/

			template<typename T>
			class WfRuntimeRange : public Object, public IValueEnumerable
			{
			protected:
				T						begin;
				T						end;

				class Enumerator : public Object, public IValueEnumerator
				{
				protected:
					T					begin;
					T					end;
					T					current;
				public:
					Enumerator(T _begin, T _end)
						:begin(_begin), end(_end), current(_begin - 1)
					{
					}

					Value GetCurrent()
					{
						return BoxValue<T>(current);
					}

					vint GetIndex()
					{
						return (vint)(current - begin);
					}

					bool Next()
					{
						if (current >= end) return false;
						current++;
						return true;
					}
				};
			public:
				WfRuntimeRange(T _begin, T _end)
					:begin(_begin), end(_end)
				{
				}

				Ptr<IValueEnumerator> CreateEnumerator()override
				{
					return MakePtr<Enumerator>(begin, end);
				}
			};
			
			template<typename T>
			WfRuntimeExecutionAction OPERATOR_OpCreateRange(WfRuntimeThreadContext& context)
			{
				Value first, second;
				CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
				CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
				T firstValue = UnboxValue<T>(first);
				T secondValue = UnboxValue<T>(second);
				auto enumerable = MakePtr<WfRuntimeRange<T>>(firstValue, secondValue);
				context.PushValue(Value::From(enumerable));
				return WfRuntimeExecutionAction::ExecuteInstruction;
			}
			
/***********************************************************************
WfRuntimeThreadContext (ReverseEnumerable)
***********************************************************************/

			class WfRuntimeReverseEnumerable : public Object, public IValueEnumerable
			{
			protected:
				Ptr<IValueList>			list;

				class Enumerator : public Object, public IValueEnumerator
				{
				protected:
					Ptr<IValueList>			list;
					vint					index;
				public:
					Enumerator(Ptr<IValueList> _list)
						:list(_list), index(_list->GetCount())
					{
					}

					Value GetCurrent()
					{
						return list->Get(index);
					}

					vint GetIndex()
					{
						return list->GetCount() - 1 - index;
					}

					bool Next()
					{
						if (index <= 0) return false;
						index--;
						return true;
					}
				};
			public:
				WfRuntimeReverseEnumerable(Ptr<IValueList> _list)
					:list(_list)
				{
				}

				Ptr<IValueEnumerator> CreateEnumerator()override
				{
					return MakePtr<Enumerator>(list);
				}
			};
			
			Value OPERATOR_OpReverseEnumerable(Value operand)
			{
				auto enumerable = UnboxValue<Ptr<IValueEnumerable>>(operand);
				auto list = enumerable.Cast<IValueList>();
				if (!list)
				{
					list = IValueList::Create(GetLazyList<Value>(enumerable));
				}
				return Value::From(MakePtr<WfRuntimeReverseEnumerable>(list));
			}
			
/***********************************************************************
WfRuntimeThreadContext (Lambda)
***********************************************************************/

			class WfRuntimeLambda : public Object, public IValueFunctionProxy
			{
			public:
				Ptr<WfRuntimeGlobalContext>			globalContext;
				Ptr<WfRuntimeVariableContext>		capturedVariables;
				vint								functionIndex;

				WfRuntimeLambda(Ptr<WfRuntimeGlobalContext> _globalContext, Ptr<WfRuntimeVariableContext> _capturedVariables, vint _functionIndex)
					:globalContext(_globalContext)
					, capturedVariables(_capturedVariables)
					, functionIndex(_functionIndex)
				{
				}

				Value Invoke(Ptr<IValueList> arguments)override
				{
					WfRuntimeThreadContext context(globalContext);
					vint count = arguments->GetCount();
					for (vint i = 0; i < count; i++)
					{
						context.PushValue(arguments->Get(i));
					}
					
					WString message;
					if (context.PushStackFrame(functionIndex, count, capturedVariables) == WfRuntimeThreadContextError::Success)
					{
						context.ExecuteToEnd();

						if (context.status == WfRuntimeExecutionStatus::Finished)
						{
							Value result;
							if (context.PopValue(result) == WfRuntimeThreadContextError::Success)
							{
								return result;
							}
							else
							{
								message = L"Internal error: failed to pop the function result.";
							}
						}
						else
						{
							message = L"Exception from external function: " + context.exceptionValue.GetText();
						}
					}
					else
					{
						message = L"Internal error: failed to invoke a function.";
					}

					throw TypeDescriptorException(message);
				}
			};

#undef INTERNAL_ERROR
#undef CONTEXT_ACTION
#undef UNARY_OPERATOR
#undef BINARY_OPERATOR

/***********************************************************************
Helper Functions
***********************************************************************/

			Ptr<reflection::description::IValueFunctionProxy> LoadFunction(Ptr<WfRuntimeGlobalContext> context, const WString& name)
			{
				vint functionIndex = context->assembly->functionByName[name];
				auto lambda = MakePtr<WfRuntimeLambda>(context, nullptr, functionIndex);
				return lambda;
			}

/***********************************************************************
WfRuntimeThreadContext
***********************************************************************/

			WfRuntimeExecutionAction WfRuntimeThreadContext::Execute()
			{
#define INTERNAL_ERROR(MESSAGE)\
				do{\
					RaiseException(BoxValue<WString>(L"Internal error: " MESSAGE), true);\
					return WfRuntimeExecutionAction::Nop; \
				} while (0)\

#define CONTEXT_ACTION(ACTION, MESSAGE)\
				do{\
					if ((ACTION) != WfRuntimeThreadContextError::Success)\
					{\
						INTERNAL_ERROR(MESSAGE);\
					}\
				} while (0)\

#define TYPE_OF_Bool							bool
#define TYPE_OF_I1								vint8_t
#define TYPE_OF_I2								vint16_t
#define TYPE_OF_I4								vint32_t
#define TYPE_OF_I8								vint64_t
#define TYPE_OF_U1								vuint8_t
#define TYPE_OF_U2								vuint16_t
#define TYPE_OF_U4								vuint32_t
#define TYPE_OF_U8								vuint64_t
#define TYPE_OF_F4								float
#define TYPE_OF_F8								double
#define TYPE_OF_String							WString
#define EXECUTE(OPERATION, TYPE)				case WfInsType::TYPE: return OPERATOR_##OPERATION<TYPE_OF_##TYPE>(*this);
#define BEGIN_TYPE								switch(ins.typeParameter) {
#define END_TYPE								default: INTERNAL_ERROR(L"unexpected type argument."); }

				try
				{
					switch (status)
					{
					case WfRuntimeExecutionStatus::Ready:
					case WfRuntimeExecutionStatus::Executing:
						{
							if (stackFrames.Count() == 0)
							{
								INTERNAL_ERROR(L"empty stack frame.");
							}
							auto& stackFrame = GetCurrentStackFrame();
							if (stackFrame.nextInstructionIndex < 0 || stackFrame.nextInstructionIndex >= globalContext->assembly->instructions.Count())
							{
								INTERNAL_ERROR(L"illegal instruction index.");
							}
							auto& ins = globalContext->assembly->instructions[stackFrame.nextInstructionIndex++];

							switch (ins.code)
							{
							case WfInsCode::LoadValue:
								PushValue(ins.valueParameter);
								return WfRuntimeExecutionAction::ExecuteInstruction;
							case WfInsCode::LoadClosure:
								{
									Ptr<WfRuntimeVariableContext> capturedVariables;
									if (ins.countParameter > 0)
									{
										capturedVariables = new WfRuntimeVariableContext;
										capturedVariables->variables.Resize(ins.countParameter);
										Value operand;
										for (vint i = 0; i < ins.countParameter; i++)
										{
											CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
											capturedVariables->variables[ins.countParameter - 1 - i] = operand;
										}
									}

									auto lambda = MakePtr<WfRuntimeLambda>(globalContext, capturedVariables, ins.indexParameter);
									PushValue(Value::From(lambda));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::LoadException:
								// next version
								throw 0;
							case WfInsCode::LoadLocalVar:
								{
									Value operand;
									CONTEXT_ACTION(LoadLocalVariable(ins.indexParameter, operand), L"illegal local variable index.");
									PushValue(operand);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::LoadCapturedVar:
								{
									Value operand;
									CONTEXT_ACTION(LoadCapturedVariable(ins.indexParameter, operand), L"illegal captured variable index.");
									PushValue(operand);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::LoadGlobalVar:
								{
									Value operand;
									CONTEXT_ACTION(LoadGlobalVariable(ins.indexParameter, operand), L"illegal global variable index.");
									PushValue(operand);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::StoreLocalVar:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(StoreLocalVariable(ins.indexParameter, operand), L"illegal local variable index.");
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::StoreGlobalVar:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(StoreGlobalVariable(ins.indexParameter, operand), L"illegal global variable index.");
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::Duplicate:
								{
									vint index = stack.Count() - 1 - ins.countParameter;
									Value operand;
									CONTEXT_ACTION(LoadStackValue(index, operand), L"failed to duplicate a value from the stack.");
									PushValue(operand);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::Pop:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::Return:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop the function result.");
									CONTEXT_ACTION(PopStackFrame(), L"failed to pop the the stack frame.");
									PushValue(operand);
									if (stackFrames.Count() == 0)
									{
										status = WfRuntimeExecutionStatus::Finished;
									}
									return WfRuntimeExecutionAction::ExitStackFrame;
								}
							case WfInsCode::CreateArray:
								{
									auto list = IValueList::Create();
									Value operand;
									for (vint i = 0; i < ins.countParameter; i++)
									{
										CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
										list->Add(operand);
									}
									PushValue(Value::From(list));
									return WfRuntimeExecutionAction::ExitStackFrame;
								}
							case WfInsCode::CreateMap:
								{
									auto map = IValueDictionary::Create();
									Value key, value;
									for (vint i = 0; i < ins.countParameter; i+=2)
									{
										CONTEXT_ACTION(PopValue(value), L"failed to pop a value from the stack.");
										CONTEXT_ACTION(PopValue(key), L"failed to pop a value from the stack.");
										map->Set(key, value);
									}
									PushValue(Value::From(map));
									return WfRuntimeExecutionAction::ExitStackFrame;
								}
							case WfInsCode::CreateRange:
								BEGIN_TYPE
									EXECUTE(OpCreateRange, I1)
									EXECUTE(OpCreateRange, I2)
									EXECUTE(OpCreateRange, I4)
									EXECUTE(OpCreateRange, I8)
									EXECUTE(OpCreateRange, U1)
									EXECUTE(OpCreateRange, U2)
									EXECUTE(OpCreateRange, U4)
									EXECUTE(OpCreateRange, U8)
								END_TYPE
							case WfInsCode::ReverseEnumerable:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									Value reversedEnumerable = OPERATOR_OpReverseEnumerable(operand);
									PushValue(reversedEnumerable);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::DeleteRawPtr:
								// next version
								throw 0;
							case WfInsCode::ConvertToType:
								{
									Value result, converted;
									CONTEXT_ACTION(PopValue(result), L"failed to pop a value from the stack.");
									if (OPERATOR_OpConvertToType(result, converted, ins))
									{
										PushValue(converted);
										return WfRuntimeExecutionAction::ExecuteInstruction;
									}
									else
									{
										INTERNAL_ERROR(L"failed to do type conversion.");
									}
								}
							case WfInsCode::TryConvertToType:
								{
									Value result, converted;
									CONTEXT_ACTION(PopValue(result), L"failed to pop a value from the stack.");
									if (OPERATOR_OpConvertToType(result, converted, ins))
									{
										PushValue(converted);
									}
									else
									{
										PushValue(Value());
									}
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::TestType:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									if (operand.GetTypeDescriptor() && operand.GetValueType() == ins.flagParameter && operand.GetTypeDescriptor()->CanConvertTo(ins.typeDescriptorParameter))
									{
										PushValue(BoxValue(true));
									}
									else
									{
										PushValue(BoxValue(false));
									}
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::GetType:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									PushValue(Value::From(operand.GetTypeDescriptor()));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::Jump:
								{
									stackFrame.nextInstructionIndex = ins.indexParameter;
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::JumpIf:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									if (UnboxValue<bool>(operand))
									{
										stackFrame.nextInstructionIndex = ins.indexParameter;
									}
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::Invoke:
								{
									CONTEXT_ACTION(PushStackFrame(ins.indexParameter, ins.countParameter), L"failed to invoke a function.");
									return WfRuntimeExecutionAction::EnterStackFrame;
								}
							case WfInsCode::GetProperty:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									Value result = ins.propertyParameter->GetValue(operand);
									PushValue(result);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::InvokeProxy:
								{
									Value thisValue;
									CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");
									auto proxy = UnboxValue<Ptr<IValueFunctionProxy>>(thisValue);
									if (!proxy)
									{
										INTERNAL_ERROR(L"failed to invoke a null function proxy.");
										return WfRuntimeExecutionAction::Nop;
									}

									if (auto lambda = proxy.Cast<WfRuntimeLambda>())
									{
										if (lambda->globalContext == globalContext)
										{
											CONTEXT_ACTION(PushStackFrame(lambda->functionIndex, ins.countParameter, lambda->capturedVariables), L"failed to invoke a function.");
											return WfRuntimeExecutionAction::EnterStackFrame;
										}
									}

									List<Value> arguments;
									for (vint i = 0; i < ins.countParameter; i++)
									{
										Value argument;
										CONTEXT_ACTION(PopValue(argument), L"failed to pop a value from the stack.");
										arguments.Insert(0, argument);
									}

									Ptr<IValueList> list = new ValueListWrapper<List<Value>*>(&arguments);
									Value result = proxy->Invoke(list);
									PushValue(result);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::InvokeMethod:
								{
									Value thisValue;
									CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");

									Array<Value> arguments(ins.countParameter);
									for (vint i = 0; i < ins.countParameter; i++)
									{
										Value argument;
										CONTEXT_ACTION(PopValue(argument), L"failed to pop a value from the stack.");
										arguments[ins.countParameter - i - 1] = argument;
									}

									Value result = ins.methodParameter->Invoke(thisValue, arguments);
									PushValue(result);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::AttachEvent:
								{
									Value thisValue, function;
									CONTEXT_ACTION(PopValue(function), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(PopValue(thisValue), L"failed to pop a value from the stack.");
									auto proxy = UnboxValue<Ptr<IValueFunctionProxy>>(function);
									auto handler = ins.eventParameter->Attach(thisValue, proxy);
									PushValue(Value::From(handler));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::DetachEvent:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									auto handler = UnboxValue<Ptr<IEventHandler>>(operand);
									auto result = handler->Detach();
									PushValue(BoxValue(result));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::InstallTry:
								// next version
								throw 0;
							case WfInsCode::UninstallTry:
								// next version
								throw 0;
							case WfInsCode::RaiseException:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									RaiseException(operand, false);
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::TestElementInSet:
								{
									Value element, set;
									CONTEXT_ACTION(PopValue(set), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(PopValue(element), L"failed to pop a value from the stack.");

									auto enumerable = UnboxValue<Ptr<IValueEnumerable>>(set);
									auto enumerator = enumerable->CreateEnumerator();
									while (enumerator->Next())
									{
										if (enumerator->GetCurrent() == element)
										{
											PushValue(BoxValue(true));
											return WfRuntimeExecutionAction::ExecuteInstruction;
										}
									}
									PushValue(BoxValue(false));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::CompareLiteral:
								BEGIN_TYPE
									EXECUTE(OpCompare, Bool)
									EXECUTE(OpCompare, I1)
									EXECUTE(OpCompare, I2)
									EXECUTE(OpCompare, I4)
									EXECUTE(OpCompare, I8)
									EXECUTE(OpCompare, U1)
									EXECUTE(OpCompare, U2)
									EXECUTE(OpCompare, U4)
									EXECUTE(OpCompare, U8)
									EXECUTE(OpCompare, F4)
									EXECUTE(OpCompare, F8)
									EXECUTE(OpCompare, String)
								END_TYPE
							case WfInsCode::CompareReference:
								{
									Value first, second;
									CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
									bool result = first.GetRawPtr() == second.GetRawPtr();
									PushValue(BoxValue(result));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::OpNot:
								BEGIN_TYPE
									EXECUTE(OpNot_Bool, Bool)
									EXECUTE(OpNot, I1)
									EXECUTE(OpNot, I2)
									EXECUTE(OpNot, I4)
									EXECUTE(OpNot, I8)
									EXECUTE(OpNot, U1)
									EXECUTE(OpNot, U2)
									EXECUTE(OpNot, U4)
									EXECUTE(OpNot, U8)
								END_TYPE
							case WfInsCode::OpPositive:
								BEGIN_TYPE
									EXECUTE(OpPositive, I1)
									EXECUTE(OpPositive, I2)
									EXECUTE(OpPositive, I4)
									EXECUTE(OpPositive, I8)
									EXECUTE(OpPositive, U1)
									EXECUTE(OpPositive, U2)
									EXECUTE(OpPositive, U4)
									EXECUTE(OpPositive, U8)
								END_TYPE
							case WfInsCode::OpNegative:
								BEGIN_TYPE
									EXECUTE(OpNegative, I1)
									EXECUTE(OpNegative, I2)
									EXECUTE(OpNegative, I4)
									EXECUTE(OpNegative, I8)
								END_TYPE
							case WfInsCode::OpConcat:
								{
									Value first, second;
									CONTEXT_ACTION(PopValue(second), L"failed to pop a value from the stack.");
									CONTEXT_ACTION(PopValue(first), L"failed to pop a value from the stack.");
									PushValue(BoxValue(first.GetText() + second.GetText()));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
							case WfInsCode::OpExp:
								// next version
								throw 0;
							case WfInsCode::OpAdd:
								BEGIN_TYPE
									EXECUTE(OpAdd, I1)
									EXECUTE(OpAdd, I2)
									EXECUTE(OpAdd, I4)
									EXECUTE(OpAdd, I8)
									EXECUTE(OpAdd, U1)
									EXECUTE(OpAdd, U2)
									EXECUTE(OpAdd, U4)
									EXECUTE(OpAdd, U8)
									EXECUTE(OpAdd, F4)
									EXECUTE(OpAdd, F8)
								END_TYPE
							case WfInsCode::OpSub:
								BEGIN_TYPE
									EXECUTE(OpSub, I1)
									EXECUTE(OpSub, I2)
									EXECUTE(OpSub, I4)
									EXECUTE(OpSub, I8)
									EXECUTE(OpSub, U1)
									EXECUTE(OpSub, U2)
									EXECUTE(OpSub, U4)
									EXECUTE(OpSub, U8)
									EXECUTE(OpSub, F4)
									EXECUTE(OpSub, F8)
								END_TYPE
							case WfInsCode::OpMul:
								BEGIN_TYPE
									EXECUTE(OpMul, I1)
									EXECUTE(OpMul, I2)
									EXECUTE(OpMul, I4)
									EXECUTE(OpMul, I8)
									EXECUTE(OpMul, U1)
									EXECUTE(OpMul, U2)
									EXECUTE(OpMul, U4)
									EXECUTE(OpMul, U8)
									EXECUTE(OpMul, F4)
									EXECUTE(OpMul, F8)
								END_TYPE
							case WfInsCode::OpDiv:
								BEGIN_TYPE
									EXECUTE(OpDiv, I1)
									EXECUTE(OpDiv, I2)
									EXECUTE(OpDiv, I4)
									EXECUTE(OpDiv, I8)
									EXECUTE(OpDiv, U1)
									EXECUTE(OpDiv, U2)
									EXECUTE(OpDiv, U4)
									EXECUTE(OpDiv, U8)
									EXECUTE(OpDiv, F4)
									EXECUTE(OpDiv, F8)
								END_TYPE
							case WfInsCode::OpShl:
								BEGIN_TYPE
									EXECUTE(OpShl, I1)
									EXECUTE(OpShl, I2)
									EXECUTE(OpShl, I4)
									EXECUTE(OpShl, I8)
									EXECUTE(OpShl, U1)
									EXECUTE(OpShl, U2)
									EXECUTE(OpShl, U4)
									EXECUTE(OpShl, U8)
								END_TYPE
							case WfInsCode::OpShr:
								BEGIN_TYPE
									EXECUTE(OpShr, I1)
									EXECUTE(OpShr, I2)
									EXECUTE(OpShr, I4)
									EXECUTE(OpShr, I8)
									EXECUTE(OpShr, U1)
									EXECUTE(OpShr, U2)
									EXECUTE(OpShr, U4)
									EXECUTE(OpShr, U8)
								END_TYPE
							case WfInsCode::OpXor:
								BEGIN_TYPE
									EXECUTE(OpXor, Bool)
									EXECUTE(OpXor, I1)
									EXECUTE(OpXor, I2)
									EXECUTE(OpXor, I4)
									EXECUTE(OpXor, I8)
									EXECUTE(OpXor, U1)
									EXECUTE(OpXor, U2)
									EXECUTE(OpXor, U4)
									EXECUTE(OpXor, U8)
								END_TYPE
							case WfInsCode::OpAnd:
								BEGIN_TYPE
									EXECUTE(OpAnd_Bool, Bool)
									EXECUTE(OpAnd, I1)
									EXECUTE(OpAnd, I2)
									EXECUTE(OpAnd, I4)
									EXECUTE(OpAnd, I8)
									EXECUTE(OpAnd, U1)
									EXECUTE(OpAnd, U2)
									EXECUTE(OpAnd, U4)
									EXECUTE(OpAnd, U8)
								END_TYPE
							case WfInsCode::OpOr:
								BEGIN_TYPE
									EXECUTE(OpOr_Bool, Bool)
									EXECUTE(OpOr, I1)
									EXECUTE(OpOr, I2)
									EXECUTE(OpOr, I4)
									EXECUTE(OpOr, I8)
									EXECUTE(OpOr, U1)
									EXECUTE(OpOr, U2)
									EXECUTE(OpOr, U4)
									EXECUTE(OpOr, U8)
								END_TYPE
							case WfInsCode::OpLT:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value < 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							case WfInsCode::OpGT:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value > 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							case WfInsCode::OpLE:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value <= 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							case WfInsCode::OpGE:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value >= 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							case WfInsCode::OpEQ:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value == 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							case WfInsCode::OpNE:
								{
									Value operand;
									CONTEXT_ACTION(PopValue(operand), L"failed to pop a value from the stack.");
									vint value = UnboxValue<vint>(operand);
									PushValue(BoxValue(value != 0));
									return WfRuntimeExecutionAction::ExecuteInstruction;
								}
								break;
							}
						}
						break;
					case WfRuntimeExecutionStatus::RaisedException:
						break;
					}
					return WfRuntimeExecutionAction::Nop;
				}
				catch (const Exception& ex)
				{
					RaiseException(BoxValue<WString>(ex.Message()), false);
					return WfRuntimeExecutionAction::ExecuteInstruction;
				}
				catch (const Error& ex)
				{
					RaiseException(BoxValue<WString>(ex.Description()), false);
					return WfRuntimeExecutionAction::ExecuteInstruction;
				}

#undef INTERNAL_ERROR
#undef CONTEXT_ACTION
#undef TYPE_OF_Bool
#undef TYPE_OF_I1
#undef TYPE_OF_I2
#undef TYPE_OF_I4
#undef TYPE_OF_I8
#undef TYPE_OF_U1
#undef TYPE_OF_U2
#undef TYPE_OF_U4
#undef TYPE_OF_U8
#undef TYPE_OF_F4
#undef TYPE_OF_F8
#undef TYPE_OF_String
#undef EXECUTE
#undef BEGIN_TYPE
#undef END_TYPE
			}
		}
	}
}
